{
  "version": 3,
  "sources": ["file:///packages/platform-browser/src/dom/events/event_manager.ts", "file:///packages/platform-browser/src/dom/shared_styles_host.ts", "../k8-fastbuild-ST-2e5f3376adb5/bin/packages/platform-browser/src/dom/dom_renderer.mjs", "file:///packages/platform-browser/src/browser/browser_adapter.ts", "file:///packages/platform-browser/src/browser/testability.ts", "file:///packages/platform-browser/src/browser/xhr.ts", "file:///packages/platform-browser/src/dom/events/dom_events.ts", "file:///packages/platform-browser/src/dom/events/key_events.ts", "file:///packages/platform-browser/src/browser.ts", "file:///packages/common/http/src/backend.ts", "file:///packages/common/http/src/headers.ts", "file:///packages/common/http/src/params.ts", "file:///packages/common/http/src/context.ts", "file:///packages/common/http/src/request.ts", "file:///packages/common/http/src/response.ts", "file:///packages/common/http/src/client.ts", "file:///packages/common/http/src/fetch.ts", "file:///packages/common/http/src/interceptor.ts", "file:///packages/common/http/src/jsonp.ts", "file:///packages/common/http/src/xhr.ts", "file:///packages/common/http/src/xsrf.ts", "file:///packages/common/http/src/provider.ts", "file:///packages/common/http/src/module.ts", "file:///packages/platform-browser/src/browser/meta.ts", "file:///packages/platform-browser/src/browser/title.ts", "file:///packages/platform-browser/src/dom/util.ts", "file:///packages/platform-browser/src/browser/tools/common_tools.ts", "file:///packages/platform-browser/src/browser/tools/tools.ts", "file:///packages/platform-browser/src/dom/debug/by.ts", "file:///packages/platform-browser/src/dom/events/hammer_gestures.ts", "file:///packages/platform-browser/src/security/dom_sanitization_service.ts", "file:///packages/platform-browser/src/hydration.ts", "file:///packages/platform-browser/src/version.ts", "file:///packages/router/src/shared.ts", "file:///packages/router/src/utils/collection.ts", "file:///packages/router/src/url_tree.ts", "file:///packages/router/src/create_url_tree.ts", "file:///packages/router/src/events.ts", "file:///packages/router/src/utils/config.ts", "file:///packages/router/src/router_outlet_context.ts", "file:///packages/router/src/utils/tree.ts", "file:///packages/router/src/router_state.ts", "file:///packages/router/src/directives/router_outlet.ts", "file:///packages/router/src/create_router_state.ts", "file:///packages/router/src/models.ts", "file:///packages/router/src/navigation_canceling_error.ts", "file:///packages/router/src/operators/activate_routes.ts", "file:///packages/router/src/utils/preactivation.ts", "file:///packages/router/src/utils/type_guards.ts", "file:///packages/router/src/operators/prioritized_guard_value.ts", "file:///packages/router/src/operators/check_guards.ts", "file:///packages/router/src/apply_redirects.ts", "file:///packages/router/src/utils/config_matching.ts", "file:///packages/router/src/recognize.ts", "file:///packages/router/src/operators/recognize.ts", "file:///packages/router/src/operators/resolve_data.ts", "file:///packages/router/src/operators/switch_tap.ts", "file:///packages/router/src/page_title_strategy.ts", "file:///packages/router/src/router_config.ts", "file:///packages/router/src/components/empty_outlet.ts", "file:///packages/router/src/router_config_loader.ts", "file:///packages/router/src/url_handling_strategy.ts", "file:///packages/router/src/utils/view_transition.ts", "file:///packages/router/src/navigation_transition.ts", "file:///packages/router/src/route_reuse_strategy.ts", "file:///packages/router/src/statemanager/state_manager.ts", "file:///packages/router/src/utils/navigations.ts", "file:///packages/router/src/router.ts", "file:///packages/router/src/directives/router_link.ts", "file:///packages/router/src/directives/router_link_active.ts", "file:///packages/router/src/router_preloader.ts", "file:///packages/router/src/router_scroller.ts", "file:///packages/router/src/provide_router.ts", "file:///packages/router/src/router_module.ts", "src/app/api.service.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  ɵRuntimeError as RuntimeError,\n  type ListenerOptions,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\n/**\n * The injection token for plugins of the `EventManager` service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS = new InjectionToken<EventManagerPlugin[]>(\n  ngDevMode ? 'EventManagerPlugins' : '',\n);\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(\n    @Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[],\n    private _zone: NgZone,\n  ) {\n    plugins.forEach((plugin) => {\n      plugin.manager = this;\n    });\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @param options Options that configure how the event listener is bound.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler, options);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone {\n    return this._zone;\n  }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    let plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    plugin = plugins.find((plugin) => plugin.supports(eventName));\n    if (!plugin) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NO_PLUGIN_FOR_EVENT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `No event manager plugin found for event ${eventName}`,\n      );\n    }\n\n    this._eventNameToPlugin.set(eventName, plugin);\n    return plugin;\n  }\n}\n\n/**\n * The plugin definition for the `EventManager` class\n *\n * It can be used as a base class to create custom manager plugins, i.e. you can create your own\n * class that extends the `EventManagerPlugin` one.\n *\n * @publicApi\n */\nexport abstract class EventManagerPlugin {\n  // TODO: remove (has some usage in G3)\n  constructor(private _doc: any) {}\n\n  // Using non-null assertion because it's set by EventManager's constructor\n  manager!: EventManager;\n\n  /**\n   * Should return `true` for every event name that should be supported by this plugin\n   */\n  abstract supports(eventName: string): boolean;\n\n  /**\n   * Implement the behaviour for the supported events\n   */\n  abstract addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, isPlatformServer} from '@angular/common';\nimport {\n  APP_ID,\n  CSP_NONCE,\n  Inject,\n  Injectable,\n  OnDestroy,\n  Optional,\n  PLATFORM_ID,\n} from '@angular/core';\n\n/** The style elements attribute name used to set value of `APP_ID` token. */\nconst APP_ID_ATTRIBUTE_NAME = 'ng-app-id';\n\n/**\n * A record of usage for a specific style including all elements added to the DOM\n * that contain a given style.\n */\ninterface UsageRecord<T> {\n  elements: T[];\n  usage: number;\n}\n\n/**\n * Removes all provided elements from the document.\n * @param elements An array of HTML Elements.\n */\nfunction removeElements(elements: Iterable<HTMLElement>): void {\n  for (const element of elements) {\n    element.remove();\n  }\n}\n\n/**\n * Creates a `style` element with the provided inline style content.\n * @param style A string of the inline style content.\n * @param doc A DOM Document to use to create the element.\n * @returns An HTMLStyleElement instance.\n */\nfunction createStyleElement(style: string, doc: Document): HTMLStyleElement {\n  const styleElement = doc.createElement('style');\n  styleElement.textContent = style;\n\n  return styleElement;\n}\n\n/**\n * Searches a DOM document's head element for style elements with a matching application\n * identifier attribute (`ng-app-id`) to the provide identifier and adds usage records for each.\n * @param doc An HTML DOM document instance.\n * @param appId A string containing an Angular application identifer.\n * @param inline A Map object for tracking inline (defined via `styles` in component decorator) style usage.\n * @param external A Map object for tracking external (defined via `styleUrls` in component decorator) style usage.\n */\nfunction addServerStyles(\n  doc: Document,\n  appId: string,\n  inline: Map<string, UsageRecord<HTMLStyleElement>>,\n  external: Map<string, UsageRecord<HTMLLinkElement>>,\n): void {\n  const elements = doc.head?.querySelectorAll<HTMLStyleElement | HTMLLinkElement>(\n    `style[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"],link[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"]`,\n  );\n\n  if (elements) {\n    for (const styleElement of elements) {\n      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);\n      if (styleElement instanceof HTMLLinkElement) {\n        // Only use filename from href\n        // The href is build time generated with a unique value to prevent duplicates.\n        external.set(styleElement.href.slice(styleElement.href.lastIndexOf('/') + 1), {\n          usage: 0,\n          elements: [styleElement],\n        });\n      } else if (styleElement.textContent) {\n        inline.set(styleElement.textContent, {usage: 0, elements: [styleElement]});\n      }\n    }\n  }\n}\n\n/**\n * Creates a `link` element for the provided external style URL.\n * @param url A string of the URL for the stylesheet.\n * @param doc A DOM Document to use to create the element.\n * @returns An HTMLLinkElement instance.\n */\nexport function createLinkElement(url: string, doc: Document): HTMLLinkElement {\n  const linkElement = doc.createElement('link');\n  linkElement.setAttribute('rel', 'stylesheet');\n  linkElement.setAttribute('href', url);\n\n  return linkElement;\n}\n\n@Injectable()\nexport class SharedStylesHost implements OnDestroy {\n  /**\n   * Provides usage information for active inline style content and associated HTML <style> elements.\n   * Embedded styles typically originate from the `styles` metadata of a rendered component.\n   */\n  private readonly inline = new Map<string /** content */, UsageRecord<HTMLStyleElement>>();\n\n  /**\n   * Provides usage information for active external style URLs and the associated HTML <link> elements.\n   * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.\n   */\n  private readonly external = new Map<string /** URL */, UsageRecord<HTMLLinkElement>>();\n\n  /**\n   * Set of host DOM nodes that will have styles attached.\n   */\n  private readonly hosts = new Set<Node>();\n\n  /**\n   * Whether the application code is currently executing on a server.\n   */\n  private readonly isServer: boolean;\n\n  constructor(\n    @Inject(DOCUMENT) private readonly doc: Document,\n    @Inject(APP_ID) private readonly appId: string,\n    @Inject(CSP_NONCE) @Optional() private readonly nonce?: string | null,\n    @Inject(PLATFORM_ID) platformId: object = {},\n  ) {\n    this.isServer = isPlatformServer(platformId);\n    addServerStyles(doc, appId, this.inline, this.external);\n    this.hosts.add(doc.head);\n  }\n\n  /**\n   * Adds embedded styles to the DOM via HTML `style` elements.\n   * @param styles An array of style content strings.\n   */\n  addStyles(styles: string[], urls?: string[]): void {\n    for (const value of styles) {\n      this.addUsage(value, this.inline, createStyleElement);\n    }\n\n    urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));\n  }\n\n  /**\n   * Removes embedded styles from the DOM that were added as HTML `style` elements.\n   * @param styles An array of style content strings.\n   */\n  removeStyles(styles: string[], urls?: string[]): void {\n    for (const value of styles) {\n      this.removeUsage(value, this.inline);\n    }\n\n    urls?.forEach((value) => this.removeUsage(value, this.external));\n  }\n\n  protected addUsage<T extends HTMLElement>(\n    value: string,\n    usages: Map<string, UsageRecord<T>>,\n    creator: (value: string, doc: Document) => T,\n  ): void {\n    // Attempt to get any current usage of the value\n    const record = usages.get(value);\n\n    // If existing, just increment the usage count\n    if (record) {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && record.usage === 0) {\n        // A usage count of zero indicates a preexisting server generated style.\n        // This attribute is solely used for debugging purposes of SSR style reuse.\n        record.elements.forEach((element) => element.setAttribute('ng-style-reused', ''));\n      }\n      record.usage++;\n    } else {\n      // Otherwise, create an entry to track the elements and add element for each host\n      usages.set(value, {\n        usage: 1,\n        elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc))),\n      });\n    }\n  }\n\n  protected removeUsage<T extends HTMLElement>(\n    value: string,\n    usages: Map<string, UsageRecord<T>>,\n  ): void {\n    // Attempt to get any current usage of the value\n    const record = usages.get(value);\n\n    // If there is a record, reduce the usage count and if no longer used,\n    // remove from DOM and delete usage record.\n    if (record) {\n      record.usage--;\n      if (record.usage <= 0) {\n        removeElements(record.elements);\n        usages.delete(value);\n      }\n    }\n  }\n\n  ngOnDestroy(): void {\n    for (const [, {elements}] of [...this.inline, ...this.external]) {\n      removeElements(elements);\n    }\n    this.hosts.clear();\n  }\n\n  /**\n   * Adds a host node to the set of style hosts and adds all existing style usage to\n   * the newly added host node.\n   *\n   * This is currently only used for Shadow DOM encapsulation mode.\n   */\n  addHost(hostNode: Node): void {\n    this.hosts.add(hostNode);\n\n    // Add existing styles to new host\n    for (const [style, {elements}] of this.inline) {\n      elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));\n    }\n    for (const [url, {elements}] of this.external) {\n      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));\n    }\n  }\n\n  removeHost(hostNode: Node): void {\n    this.hosts.delete(hostNode);\n  }\n\n  private addElement<T extends HTMLElement>(host: Node, element: T): T {\n    // Add a nonce if present\n    if (this.nonce) {\n      element.setAttribute('nonce', this.nonce);\n    }\n\n    // Add application identifier when on the server to support client-side reuse\n    if (this.isServer) {\n      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);\n    }\n\n    // Insert the element into the DOM with the host node as parent\n    return host.appendChild(element);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport { DOCUMENT, isPlatformServer, ɵgetDOM as getDOM } from '@angular/common';\nimport { APP_ID, CSP_NONCE, Inject, Injectable, InjectionToken, NgZone, PLATFORM_ID, RendererStyleFlags2, ViewEncapsulation, ɵRuntimeError as RuntimeError, ɵTracingService as TracingService, Optional, } from '@angular/core';\nimport { EventManager } from './events/event_manager';\nimport { createLinkElement, SharedStylesHost } from './shared_styles_host';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./events/event_manager\";\nimport * as i2 from \"./shared_styles_host\";\nexport const NAMESPACE_URIS = {\n    'svg': 'http://www.w3.org/2000/svg',\n    'xhtml': 'http://www.w3.org/1999/xhtml',\n    'xlink': 'http://www.w3.org/1999/xlink',\n    'xml': 'http://www.w3.org/XML/1998/namespace',\n    'xmlns': 'http://www.w3.org/2000/xmlns/',\n    'math': 'http://www.w3.org/1998/Math/MathML',\n};\nconst COMPONENT_REGEX = /%COMP%/g;\nconst SOURCEMAP_URL_REGEXP = /\\/\\*#\\s*sourceMappingURL=(.+?)\\s*\\*\\//;\nconst PROTOCOL_REGEXP = /^https?:/;\nexport const COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n/**\n * The default value for the `REMOVE_STYLES_ON_COMPONENT_DESTROY` DI token.\n */\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;\n/**\n * A DI token that indicates whether styles\n * of destroyed components should be removed from DOM.\n *\n * By default, the value is set to `true`.\n * @publicApi\n */\nexport const REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? 'RemoveStylesOnCompDestroy' : '', {\n    providedIn: 'root',\n    factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT,\n});\nexport function shimContentAttribute(componentShortId) {\n    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nexport function shimHostAttribute(componentShortId) {\n    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nexport function shimStylesContent(compId, styles) {\n    return styles.map((s) => s.replace(COMPONENT_REGEX, compId));\n}\n/**\n * Prepends a baseHref to the `sourceMappingURL` within the provided CSS content.\n * If the `sourceMappingURL` contains an inline (encoded) map, the function skips processing.\n *\n * @note For inline stylesheets, the `sourceMappingURL` is relative to the page's origin\n * and not the provided baseHref. This function is needed as when accessing the page with a URL\n * containing two or more segments.\n * For example, if the baseHref is set to `/`, and you visit a URL like `http://localhost/foo/bar`,\n * the map would be requested from `http://localhost/foo/bar/comp.css.map` instead of what you'd expect,\n * which is `http://localhost/comp.css.map`. This behavior is corrected by modifying the `sourceMappingURL`\n * to ensure external source maps are loaded relative to the baseHref.\n *\n\n * @param baseHref - The base URL to prepend to the `sourceMappingURL`.\n * @param styles - An array of CSS content strings, each potentially containing a `sourceMappingURL`.\n * @returns The updated array of CSS content strings with modified `sourceMappingURL` values,\n * or the original content if no modification is needed.\n */\nexport function addBaseHrefToCssSourceMap(baseHref, styles) {\n    if (!baseHref) {\n        return styles;\n    }\n    const absoluteBaseHrefUrl = new URL(baseHref, 'http://localhost');\n    return styles.map((cssContent) => {\n        if (!cssContent.includes('sourceMappingURL=')) {\n            return cssContent;\n        }\n        return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {\n            if (sourceMapUrl[0] === '/' ||\n                sourceMapUrl.startsWith('data:') ||\n                PROTOCOL_REGEXP.test(sourceMapUrl)) {\n                return `/*# sourceMappingURL=${sourceMapUrl} */`;\n            }\n            const { pathname: resolvedSourceMapUrl } = new URL(sourceMapUrl, absoluteBaseHrefUrl);\n            return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;\n        });\n    });\n}\nexport class DomRendererFactory2 {\n    eventManager;\n    sharedStylesHost;\n    appId;\n    removeStylesOnCompDestroy;\n    doc;\n    platformId;\n    ngZone;\n    nonce;\n    tracingService;\n    rendererByCompId = new Map();\n    defaultRenderer;\n    platformIsServer;\n    constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null, tracingService = null) {\n        this.eventManager = eventManager;\n        this.sharedStylesHost = sharedStylesHost;\n        this.appId = appId;\n        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n        this.doc = doc;\n        this.platformId = platformId;\n        this.ngZone = ngZone;\n        this.nonce = nonce;\n        this.tracingService = tracingService;\n        this.platformIsServer = isPlatformServer(platformId);\n        this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer, this.tracingService);\n    }\n    createRenderer(element, type) {\n        if (!element || !type) {\n            return this.defaultRenderer;\n        }\n        if (this.platformIsServer && type.encapsulation === ViewEncapsulation.ShadowDom) {\n            // Domino does not support shadow DOM.\n            type = { ...type, encapsulation: ViewEncapsulation.Emulated };\n        }\n        const renderer = this.getOrCreateRenderer(element, type);\n        // Renderers have different logic due to different encapsulation behaviours.\n        // Ex: for emulated, an attribute is added to the element.\n        if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n            renderer.applyToHost(element);\n        }\n        else if (renderer instanceof NoneEncapsulationDomRenderer) {\n            renderer.applyStyles();\n        }\n        return renderer;\n    }\n    getOrCreateRenderer(element, type) {\n        const rendererByCompId = this.rendererByCompId;\n        let renderer = rendererByCompId.get(type.id);\n        if (!renderer) {\n            const doc = this.doc;\n            const ngZone = this.ngZone;\n            const eventManager = this.eventManager;\n            const sharedStylesHost = this.sharedStylesHost;\n            const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;\n            const platformIsServer = this.platformIsServer;\n            const tracingService = this.tracingService;\n            switch (type.encapsulation) {\n                case ViewEncapsulation.Emulated:\n                    renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);\n                    break;\n                case ViewEncapsulation.ShadowDom:\n                    return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService);\n                default:\n                    renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);\n                    break;\n            }\n            rendererByCompId.set(type.id, renderer);\n        }\n        return renderer;\n    }\n    ngOnDestroy() {\n        this.rendererByCompId.clear();\n    }\n    /**\n     * Used during HMR to clear any cached data about a component.\n     * @param componentId ID of the component that is being replaced.\n     */\n    componentReplaced(componentId) {\n        this.rendererByCompId.delete(componentId);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.10\", ngImport: i0, type: DomRendererFactory2, deps: [{ token: i1.EventManager }, { token: i2.SharedStylesHost }, { token: APP_ID }, { token: REMOVE_STYLES_ON_COMPONENT_DESTROY }, { token: DOCUMENT }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: CSP_NONCE }, { token: TracingService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.10\", ngImport: i0, type: DomRendererFactory2 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.10\", ngImport: i0, type: DomRendererFactory2, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i1.EventManager }, { type: i2.SharedStylesHost }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [APP_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]\n                }] }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CSP_NONCE]\n                }] }, { type: i0.ɵTracingService, decorators: [{\n                    type: Inject,\n                    args: [TracingService]\n                }, {\n                    type: Optional\n                }] }] });\nclass DefaultDomRenderer2 {\n    eventManager;\n    doc;\n    ngZone;\n    platformIsServer;\n    tracingService;\n    data = Object.create(null);\n    /**\n     * By default this renderer throws when encountering synthetic properties\n     * This can be disabled for example by the AsyncAnimationRendererFactory\n     */\n    throwOnSyntheticProps = true;\n    constructor(eventManager, doc, ngZone, platformIsServer, tracingService) {\n        this.eventManager = eventManager;\n        this.doc = doc;\n        this.ngZone = ngZone;\n        this.platformIsServer = platformIsServer;\n        this.tracingService = tracingService;\n    }\n    destroy() { }\n    destroyNode = null;\n    createElement(name, namespace) {\n        if (namespace) {\n            // TODO: `|| namespace` was added in\n            // https://github.com/angular/angular/commit/2b9cc8503d48173492c29f5a271b61126104fbdb to\n            // support how Ivy passed around the namespace URI rather than short name at the time. It did\n            // not, however extend the support to other parts of the system (setAttribute, setAttribute,\n            // and the ServerRenderer). We should decide what exactly the semantics for dealing with\n            // namespaces should be and make it consistent.\n            // Related issues:\n            // https://github.com/angular/angular/issues/44028\n            // https://github.com/angular/angular/issues/44883\n            return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n        }\n        return this.doc.createElement(name);\n    }\n    createComment(value) {\n        return this.doc.createComment(value);\n    }\n    createText(value) {\n        return this.doc.createTextNode(value);\n    }\n    appendChild(parent, newChild) {\n        const targetParent = isTemplateNode(parent) ? parent.content : parent;\n        targetParent.appendChild(newChild);\n    }\n    insertBefore(parent, newChild, refChild) {\n        if (parent) {\n            const targetParent = isTemplateNode(parent) ? parent.content : parent;\n            targetParent.insertBefore(newChild, refChild);\n        }\n    }\n    removeChild(_parent, oldChild) {\n        oldChild.remove();\n    }\n    selectRootElement(selectorOrNode, preserveContent) {\n        let el = typeof selectorOrNode === 'string' ? this.doc.querySelector(selectorOrNode) : selectorOrNode;\n        if (!el) {\n            throw new RuntimeError(-5104 /* RuntimeErrorCode.ROOT_NODE_NOT_FOUND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `The selector \"${selectorOrNode}\" did not match any elements`);\n        }\n        if (!preserveContent) {\n            el.textContent = '';\n        }\n        return el;\n    }\n    parentNode(node) {\n        return node.parentNode;\n    }\n    nextSibling(node) {\n        return node.nextSibling;\n    }\n    setAttribute(el, name, value, namespace) {\n        if (namespace) {\n            name = namespace + ':' + name;\n            const namespaceUri = NAMESPACE_URIS[namespace];\n            if (namespaceUri) {\n                el.setAttributeNS(namespaceUri, name, value);\n            }\n            else {\n                el.setAttribute(name, value);\n            }\n        }\n        else {\n            el.setAttribute(name, value);\n        }\n    }\n    removeAttribute(el, name, namespace) {\n        if (namespace) {\n            const namespaceUri = NAMESPACE_URIS[namespace];\n            if (namespaceUri) {\n                el.removeAttributeNS(namespaceUri, name);\n            }\n            else {\n                el.removeAttribute(`${namespace}:${name}`);\n            }\n        }\n        else {\n            el.removeAttribute(name);\n        }\n    }\n    addClass(el, name) {\n        el.classList.add(name);\n    }\n    removeClass(el, name) {\n        el.classList.remove(name);\n    }\n    setStyle(el, style, value, flags) {\n        if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n            el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n        }\n        else {\n            el.style[style] = value;\n        }\n    }\n    removeStyle(el, style, flags) {\n        if (flags & RendererStyleFlags2.DashCase) {\n            // removeProperty has no effect when used on camelCased properties.\n            el.style.removeProperty(style);\n        }\n        else {\n            el.style[style] = '';\n        }\n    }\n    setProperty(el, name, value) {\n        if (el == null) {\n            return;\n        }\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            this.throwOnSyntheticProps &&\n            checkNoSyntheticProp(name, 'property');\n        el[name] = value;\n    }\n    setValue(node, value) {\n        node.nodeValue = value;\n    }\n    listen(target, event, callback, options) {\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            this.throwOnSyntheticProps &&\n            checkNoSyntheticProp(event, 'listener');\n        if (typeof target === 'string') {\n            target = getDOM().getGlobalEventTarget(this.doc, target);\n            if (!target) {\n                throw new RuntimeError(5102 /* RuntimeErrorCode.UNSUPPORTED_EVENT_TARGET */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    `Unsupported event target ${target} for event ${event}`);\n            }\n        }\n        let wrappedCallback = this.decoratePreventDefault(callback);\n        if (this.tracingService?.wrapEventListener) {\n            wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);\n        }\n        return this.eventManager.addEventListener(target, event, wrappedCallback, options);\n    }\n    decoratePreventDefault(eventHandler) {\n        // `DebugNode.triggerEventHandler` needs to know if the listener was created with\n        // decoratePreventDefault or is a listener added outside the Angular context so it can handle\n        // the two differently. In the first case, the special '__ngUnwrap__' token is passed to the\n        // unwrap the listener (see below).\n        return (event) => {\n            // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function\n            // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The\n            // debug_node can inspect the listener toString contents for the existence of this special\n            // token. Because the token is a string literal, it is ensured to not be modified by compiled\n            // code.\n            if (event === '__ngUnwrap__') {\n                return eventHandler;\n            }\n            // Run the event handler inside the ngZone because event handlers are not patched\n            // by Zone on the server. This is required only for tests.\n            const allowDefaultBehavior = this.platformIsServer\n                ? this.ngZone.runGuarded(() => eventHandler(event))\n                : eventHandler(event);\n            if (allowDefaultBehavior === false) {\n                event.preventDefault();\n            }\n            return undefined;\n        };\n    }\n}\nconst AT_CHARCODE = (() => '@'.charCodeAt(0))();\nfunction checkNoSyntheticProp(name, nameKind) {\n    if (name.charCodeAt(0) === AT_CHARCODE) {\n        throw new RuntimeError(5105 /* RuntimeErrorCode.UNEXPECTED_SYNTHETIC_PROPERTY */, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Make sure \\`provideAnimationsAsync()\\`, \\`provideAnimations()\\` or \\`provideNoopAnimations()\\` call was added to a list of providers used to bootstrap an application.\n  - There is a corresponding animation configuration named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.dev/api/core/Component#animations).`);\n    }\n}\nfunction isTemplateNode(node) {\n    return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n    sharedStylesHost;\n    hostEl;\n    shadowRoot;\n    constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer, tracingService) {\n        super(eventManager, doc, ngZone, platformIsServer, tracingService);\n        this.sharedStylesHost = sharedStylesHost;\n        this.hostEl = hostEl;\n        this.shadowRoot = hostEl.attachShadow({ mode: 'open' });\n        this.sharedStylesHost.addHost(this.shadowRoot);\n        let styles = component.styles;\n        if (ngDevMode) {\n            // We only do this in development, as for production users should not add CSS sourcemaps to components.\n            const baseHref = getDOM().getBaseHref(doc) ?? '';\n            styles = addBaseHrefToCssSourceMap(baseHref, styles);\n        }\n        styles = shimStylesContent(component.id, styles);\n        for (const style of styles) {\n            const styleEl = document.createElement('style');\n            if (nonce) {\n                styleEl.setAttribute('nonce', nonce);\n            }\n            styleEl.textContent = style;\n            this.shadowRoot.appendChild(styleEl);\n        }\n        // Apply any external component styles to the shadow root for the component's element.\n        // The ShadowDOM renderer uses an alternative execution path for component styles that\n        // does not use the SharedStylesHost that other encapsulation modes leverage. Much like\n        // the manual addition of embedded styles directly above, any external stylesheets\n        // must be manually added here to ensure ShadowDOM components are correctly styled.\n        // TODO: Consider reworking the DOM Renderers to consolidate style handling.\n        const styleUrls = component.getExternalStyles?.();\n        if (styleUrls) {\n            for (const styleUrl of styleUrls) {\n                const linkEl = createLinkElement(styleUrl, doc);\n                if (nonce) {\n                    linkEl.setAttribute('nonce', nonce);\n                }\n                this.shadowRoot.appendChild(linkEl);\n            }\n        }\n    }\n    nodeOrShadowRoot(node) {\n        return node === this.hostEl ? this.shadowRoot : node;\n    }\n    appendChild(parent, newChild) {\n        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n    }\n    insertBefore(parent, newChild, refChild) {\n        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n    }\n    removeChild(_parent, oldChild) {\n        return super.removeChild(null, oldChild);\n    }\n    parentNode(node) {\n        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n    }\n    destroy() {\n        this.sharedStylesHost.removeHost(this.shadowRoot);\n    }\n}\nclass NoneEncapsulationDomRenderer extends DefaultDomRenderer2 {\n    sharedStylesHost;\n    removeStylesOnCompDestroy;\n    styles;\n    styleUrls;\n    constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId) {\n        super(eventManager, doc, ngZone, platformIsServer, tracingService);\n        this.sharedStylesHost = sharedStylesHost;\n        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n        let styles = component.styles;\n        if (ngDevMode) {\n            // We only do this in development, as for production users should not add CSS sourcemaps to components.\n            const baseHref = getDOM().getBaseHref(doc) ?? '';\n            styles = addBaseHrefToCssSourceMap(baseHref, styles);\n        }\n        this.styles = compId ? shimStylesContent(compId, styles) : styles;\n        this.styleUrls = component.getExternalStyles?.(compId);\n    }\n    applyStyles() {\n        this.sharedStylesHost.addStyles(this.styles, this.styleUrls);\n    }\n    destroy() {\n        if (!this.removeStylesOnCompDestroy) {\n            return;\n        }\n        this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);\n    }\n}\nclass EmulatedEncapsulationDomRenderer2 extends NoneEncapsulationDomRenderer {\n    contentAttr;\n    hostAttr;\n    constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService) {\n        const compId = appId + '-' + component.id;\n        super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId);\n        this.contentAttr = shimContentAttribute(compId);\n        this.hostAttr = shimHostAttribute(compId);\n    }\n    applyToHost(element) {\n        this.applyStyles();\n        this.setAttribute(element, this.hostAttr, '');\n    }\n    createElement(parent, name) {\n        const el = super.createElement(parent, name);\n        super.setAttribute(el, this.contentAttr, '');\n        return el;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9tX3JlbmRlcmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2RvbV9yZW5kZXJlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsUUFBUSxFQUFFLGdCQUFnQixFQUFFLE9BQU8sSUFBSSxNQUFNLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RSxPQUFPLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxNQUFNLEVBQ04sVUFBVSxFQUNWLGNBQWMsRUFDZCxNQUFNLEVBRU4sV0FBVyxFQUdYLG1CQUFtQixFQUVuQixpQkFBaUIsRUFDakIsYUFBYSxJQUFJLFlBQVksRUFFN0IsZUFBZSxJQUFJLGNBQWMsRUFFakMsUUFBUSxHQUNULE1BQU0sZUFBZSxDQUFDO0FBSXZCLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQzs7OztBQUV6RSxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQTJCO0lBQ3BELEtBQUssRUFBRSw0QkFBNEI7SUFDbkMsT0FBTyxFQUFFLDhCQUE4QjtJQUN2QyxPQUFPLEVBQUUsOEJBQThCO0lBQ3ZDLEtBQUssRUFBRSxzQ0FBc0M7SUFDN0MsT0FBTyxFQUFFLCtCQUErQjtJQUN4QyxNQUFNLEVBQUUsb0NBQW9DO0NBQzdDLENBQUM7QUFFRixNQUFNLGVBQWUsR0FBRyxTQUFTLENBQUM7QUFDbEMsTUFBTSxvQkFBb0IsR0FBRyx1Q0FBdUMsQ0FBQztBQUNyRSxNQUFNLGVBQWUsR0FBRyxVQUFVLENBQUM7QUFFbkMsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsUUFBUSxDQUFDO0FBQzNDLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxXQUFXLGtCQUFrQixFQUFF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RUFBRSxFQUFFLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRVEsYUFBYSxDQUFDLE1BQVcsRUFBRSxJQUFZO1FBQzlDLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzdDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDN0MsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5kZXYvbGljZW5zZVxuICovXG5cbmltcG9ydCB7RE9DVU1FTlQsIGlzUGxhdGZvcm1TZXJ2ZXIsIMm1Z2V0RE9NIGFzIGdldERPTX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFQUF9JRCxcbiAgQ1NQX05PTkNFLFxuICBJbmplY3QsXG4gIEluamVjdGFibGUsXG4gIEluamVjdGlvblRva2VuLFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbiAgUmVuZGVyZXJGYWN0b3J5MixcbiAgUmVuZGVyZXJTdHlsZUZsYWdzMixcbiAgUmVuZGVyZXJUeXBlMixcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIMm1UnVudGltZUVycm9yIGFzIFJ1bnRpbWVFcnJvcixcbiAgdHlwZSBMaXN0ZW5lck9wdGlvbnMsXG4gIMm1VHJhY2luZ1NlcnZpY2UgYXMgVHJhY2luZ1NlcnZpY2UsXG4gIMm1VHJhY2luZ1NuYXBzaG90IGFzIFRyYWNpbmdTbmFwc2hvdCxcbiAgT3B0aW9uYWwsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1J1bnRpbWVFcnJvckNvZGV9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICcuL2V2ZW50cy9ldmVudF9tYW5hZ2VyJztcbmltcG9ydCB7Y3JlYXRlTGlua0VsZW1lbnQsIFNoYXJlZFN0eWxlc0hvc3R9IGZyb20gJy4vc2hhcmVkX3N0eWxlc19ob3N0JztcblxuZXhwb3J0IGNvbnN0IE5BTUVTUEFDRV9VUklTOiB7W25zOiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAnc3ZnJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgJ3hodG1sJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuICAneGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICd4bWwnOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyxcbiAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyxcbiAgJ21hdGgnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG59O1xuXG5jb25zdCBDT01QT05FTlRfUkVHRVggPSAvJUNPTVAlL2c7XG5jb25zdCBTT1VSQ0VNQVBfVVJMX1JFR0VYUCA9IC9cXC9cXCojXFxzKnNvdXJjZU1hcHBpbmdVUkw9KC4rPylcXHMqXFwqXFwvLztcbmNvbnN0IFBST1RPQ09MX1JFR0VYUCA9IC9eaHR0cHM/Oi87XG5cbmV4cG9ydCBjb25zdCBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbmV4cG9ydCBjb25zdCBIT1NUX0FUVFIgPSBgX25naG9zdC0ke0NPTVBPTkVOVF9WQVJJQUJMRX1gO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfQVRUUiA9IGBfbmdjb250ZW50LSR7Q09NUE9ORU5UX1ZBUklBQkxFfWA7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBgUkVNT1ZFX1NUWUxFU19PTl9DT01QT05FTlRfREVTVFJPWWAgREkgdG9rZW4uXG4gKi9cbmNvbnN0IFJFTU9WRV9TVFlMRVNfT05fQ09NUE9ORU5UX0RFU1RST1lfREVGQVVMVCA9IHRydWU7XG5cbi8qKlxuICogQSBESSB0b2tlbiB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHN0eWxlc1xuICogb2YgZGVzdHJveWVkIGNvbXBvbmVudHMgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBET00uXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAuXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCBjb25zdCBSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZID0gbmV3IEluamVjdGlvblRva2VuPGJvb2xlYW4+KFxuICBuZ0Rldk1vZGUgPyAnUmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveScgOiAnJyxcbiAge1xuICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICBmYWN0b3J5OiAoKSA9PiBSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZX0RFRkFVTFQsXG4gIH0sXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNvbnRlbnRBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIENPTlRFTlRfQVRUUi5yZXBsYWNlKENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50U2hvcnRJZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltSG9zdEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gSE9TVF9BVFRSLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1TdHlsZXNDb250ZW50KGNvbXBJZDogc3RyaW5nLCBzdHlsZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gc3R5bGVzLm1hcCgocykgPT4gcy5yZXBsYWNlKENPTVBPTkVOVF9SRUdFWCwgY29tcElkKSk7XG59XG5cbi8qKlxuICogUHJlcGVuZHMgYSBiYXNlSHJlZiB0byB0aGUgYHNvdXJjZU1hcHBpbmdVUkxgIHdpdGhpbiB0aGUgcHJvdmlkZWQgQ1NTIGNvbnRlbnQuXG4gKiBJZiB0aGUgYHNvdXJjZU1hcHBpbmdVUkxgIGNvbnRhaW5zIGFuIGlubGluZSAoZW5jb2RlZCkgbWFwLCB0aGUgZnVuY3Rpb24gc2tpcHMgcHJvY2Vzc2luZy5cbiAqXG4gKiBAbm90ZSBGb3IgaW5saW5lIHN0eWxlc2hlZXRzLCB0aGUgYHNvdXJjZU1hcHBpbmdVUkxgIGlzIHJlbGF0aXZlIHRvIHRoZSBwYWdlJ3Mgb3JpZ2luXG4gKiBhbmQgbm90IHRoZSBwcm92aWRlZCBiYXNlSHJlZi4gVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgYXMgd2hlbiBhY2Nlc3NpbmcgdGhlIHBhZ2Ugd2l0aCBhIFVSTFxuICogY29udGFpbmluZyB0d28gb3IgbW9yZSBzZWdtZW50cy5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgYmFzZUhyZWYgaXMgc2V0IHRvIGAvYCwgYW5kIHlvdSB2aXNpdCBhIFVSTCBsaWtlIGBodHRwOi8vbG9jYWxob3N0L2Zvby9iYXJgLFxuICogdGhlIG1hcCB3b3VsZCBiZSByZXF1ZXN0ZWQgZnJvbSBgaHR0cDovL2xvY2FsaG9zdC9mb28vYmFyL2NvbXAuY3NzLm1hcGAgaW5zdGVhZCBvZiB3aGF0IHlvdSdkIGV4cGVjdCxcbiAqIHdoaWNoIGlzIGBodHRwOi8vbG9jYWxob3N0L2NvbXAuY3NzLm1hcGAuIFRoaXMgYmVoYXZpb3IgaXMgY29ycmVjdGVkIGJ5IG1vZGlmeWluZyB0aGUgYHNvdXJjZU1hcHBpbmdVUkxgXG4gKiB0byBlbnN1cmUgZXh0ZXJuYWwgc291cmNlIG1hcHMgYXJlIGxvYWRlZCByZWxhdGl2ZSB0byB0aGUgYmFzZUhyZWYuXG4gKlxuXG4gKiBAcGFyYW0gYmFzZUhyZWYgLSBUaGUgYmFzZSBVUkwgdG8gcHJlcGVuZCB0byB0aGUgYHNvdXJjZU1hcHBpbmdVUkxgLlxuICogQHBhcmFtIHN0eWxlcyAtIEFuIGFycmF5IG9mIENTUyBjb250ZW50IHN0cmluZ3MsIGVhY2ggcG90ZW50aWFsbHkgY29udGFpbmluZyBhIGBzb3VyY2VNYXBwaW5nVVJMYC5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFycmF5IG9mIENTUyBjb250ZW50IHN0cmluZ3Mgd2l0aCBtb2RpZmllZCBgc291cmNlTWFwcGluZ1VSTGAgdmFsdWVzLFxuICogb3IgdGhlIG9yaWdpbmFsIGNvbnRlbnQgaWYgbm8gbW9kaWZpY2F0aW9uIGlzIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VIcmVmVG9Dc3NTb3VyY2VNYXAoYmFzZUhyZWY6IHN0cmluZywgc3R5bGVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgaWYgKCFiYXNlSHJlZikge1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICBjb25zdCBhYnNvbHV0ZUJhc2VIcmVmVXJsID0gbmV3IFVSTChiYXNlSHJlZiwgJ2h0dHA6Ly9sb2NhbGhvc3QnKTtcblxuICByZXR1cm4gc3R5bGVzLm1hcCgoY3NzQ29udGVudCkgPT4ge1xuICAgIGlmICghY3NzQ29udGVudC5pbmNsdWRlcygnc291cmNlTWFwcGluZ1VSTD0nKSkge1xuICAgICAgcmV0dXJuIGNzc0NvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzc0NvbnRlbnQucmVwbGFjZShTT1VSQ0VNQVBfVVJMX1JFR0VYUCwgKF8sIHNvdXJjZU1hcFVybCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzb3VyY2VNYXBVcmxbMF0gPT09ICcvJyB8fFxuICAgICAgICBzb3VyY2VNYXBVcmwuc3RhcnRzV2l0aCgnZGF0YTonKSB8fFxuICAgICAgICBQUk9UT0NPTF9SRUdFWFAudGVzdChzb3VyY2VNYXBVcmwpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGAvKiMgc291cmNlTWFwcGluZ1VSTD0ke3NvdXJjZU1hcFVybH0gKi9gO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7cGF0aG5hbWU6IHJlc29sdmVkU291cmNlTWFwVXJsfSA9IG5ldyBVUkwoc291cmNlTWFwVXJsLCBhYnNvbHV0ZUJhc2VIcmVmVXJsKTtcblxuICAgICAgcmV0dXJuIGAvKiMgc291cmNlTWFwcGluZ1VSTD0ke3Jlc29sdmVkU291cmNlTWFwVXJsfSAqL2A7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRG9tUmVuZGVyZXJGYWN0b3J5MiBpbXBsZW1lbnRzIFJlbmRlcmVyRmFjdG9yeTIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVuZGVyZXJCeUNvbXBJZCA9IG5ldyBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEVtdWxhdGVkRW5jYXBzdWxhdGlvbkRvbVJlbmRlcmVyMiB8IE5vbmVFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXJcbiAgPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRSZW5kZXJlcjogUmVuZGVyZXIyO1xuICBwcml2YXRlIHJlYWRvbmx5IHBsYXRmb3JtSXNTZXJ2ZXI6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudE1hbmFnZXI6IEV2ZW50TWFuYWdlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNoYXJlZFN0eWxlc0hvc3Q6IFNoYXJlZFN0eWxlc0hvc3QsXG4gICAgQEluamVjdChBUFBfSUQpIHByaXZhdGUgcmVhZG9ubHkgYXBwSWQ6IHN0cmluZyxcbiAgICBASW5qZWN0KFJFTU9WRV9TVFlMRVNfT05fQ09NUE9ORU5UX0RFU1RST1kpIHByaXZhdGUgcmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveTogYm9vbGVhbixcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIHJlYWRvbmx5IGRvYzogRG9jdW1lbnQsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcmVhZG9ubHkgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHJlYWRvbmx5IG5nWm9uZTogTmdab25lLFxuICAgIEBJbmplY3QoQ1NQX05PTkNFKSBwcml2YXRlIHJlYWRvbmx5IG5vbmNlOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICBASW5qZWN0KFRyYWNpbmdTZXJ2aWNlKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHJpdmF0ZSByZWFkb25seSB0cmFjaW5nU2VydmljZTogVHJhY2luZ1NlcnZpY2U8VHJhY2luZ1NuYXBzaG90PiB8IG51bGwgPSBudWxsLFxuICApIHtcbiAgICB0aGlzLnBsYXRmb3JtSXNTZXJ2ZXIgPSBpc1BsYXRmb3JtU2VydmVyKHBsYXRmb3JtSWQpO1xuICAgIHRoaXMuZGVmYXVsdFJlbmRlcmVyID0gbmV3IERlZmF1bHREb21SZW5kZXJlcjIoXG4gICAgICBldmVudE1hbmFnZXIsXG4gICAgICBkb2MsXG4gICAgICBuZ1pvbmUsXG4gICAgICB0aGlzLnBsYXRmb3JtSXNTZXJ2ZXIsXG4gICAgICB0aGlzLnRyYWNpbmdTZXJ2aWNlLFxuICAgICk7XG4gIH1cblxuICBjcmVhdGVSZW5kZXJlcihlbGVtZW50OiBhbnksIHR5cGU6IFJlbmRlcmVyVHlwZTIgfCBudWxsKTogUmVuZGVyZXIyIHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIXR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF0Zm9ybUlzU2VydmVyICYmIHR5cGUuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uU2hhZG93RG9tKSB7XG4gICAgICAvLyBEb21pbm8gZG9lcyBub3Qgc3VwcG9ydCBzaGFkb3cgRE9NLlxuICAgICAgdHlwZSA9IHsuLi50eXBlLCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldE9yQ3JlYXRlUmVuZGVyZXIoZWxlbWVudCwgdHlwZSk7XG4gICAgLy8gUmVuZGVyZXJzIGhhdmUgZGlmZmVyZW50IGxvZ2ljIGR1ZSB0byBkaWZmZXJlbnQgZW5jYXBzdWxhdGlvbiBiZWhhdmlvdXJzLlxuICAgIC8vIEV4OiBmb3IgZW11bGF0ZWQsIGFuIGF0dHJpYnV0ZSBpcyBhZGRlZCB0byB0aGUgZWxlbWVudC5cbiAgICBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBFbXVsYXRlZEVuY2Fwc3VsYXRpb25Eb21SZW5kZXJlcjIpIHtcbiAgICAgIHJlbmRlcmVyLmFwcGx5VG9Ib3N0KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBOb25lRW5jYXBzdWxhdGlvbkRvbVJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5hcHBseVN0eWxlcygpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlcjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3JDcmVhdGVSZW5kZXJlcihlbGVtZW50OiBhbnksIHR5cGU6IFJlbmRlcmVyVHlwZTIpOiBSZW5kZXJlcjIge1xuICAgIGNvbnN0IHJlbmRlcmVyQnlDb21wSWQgPSB0aGlzLnJlbmRlcmVyQnlDb21wSWQ7XG4gICAgbGV0IHJlbmRlcmVyID0gcmVuZGVyZXJCeUNvbXBJZC5nZXQodHlwZS5pZCk7XG5cbiAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLmRvYztcbiAgICAgIGNvbnN0IG5nWm9uZSA9IHRoaXMubmdab25lO1xuICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XG4gICAgICBjb25zdCBzaGFyZWRTdHlsZXNIb3N0ID0gdGhpcy5zaGFyZWRTdHlsZXNIb3N0O1xuICAgICAgY29uc3QgcmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveSA9IHRoaXMucmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveTtcbiAgICAgIGNvbnN0IHBsYXRmb3JtSXNTZXJ2ZXIgPSB0aGlzLnBsYXRmb3JtSXNTZXJ2ZXI7XG4gICAgICBjb25zdCB0cmFjaW5nU2VydmljZSA9IHRoaXMudHJhY2luZ1NlcnZpY2U7XG5cbiAgICAgIHN3aXRjaCAodHlwZS5lbmNhcHN1bGF0aW9uKSB7XG4gICAgICAgIGNhc2UgVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ6XG4gICAgICAgICAgcmVuZGVyZXIgPSBuZXcgRW11bGF0ZWRFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIyKFxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLFxuICAgICAgICAgICAgc2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0aGlzLmFwcElkLFxuICAgICAgICAgICAgcmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveSxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIG5nWm9uZSxcbiAgICAgICAgICAgIHBsYXRmb3JtSXNTZXJ2ZXIsXG4gICAgICAgICAgICB0cmFjaW5nU2VydmljZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZpZXdFbmNhcHN1bGF0aW9uLlNoYWRvd0RvbTpcbiAgICAgICAgICByZXR1cm4gbmV3IFNoYWRvd0RvbVJlbmRlcmVyKFxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLFxuICAgICAgICAgICAgc2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbmdab25lLFxuICAgICAgICAgICAgdGhpcy5ub25jZSxcbiAgICAgICAgICAgIHBsYXRmb3JtSXNTZXJ2ZXIsXG4gICAgICAgICAgICB0cmFjaW5nU2VydmljZSxcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlbmRlcmVyID0gbmV3IE5vbmVFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIoXG4gICAgICAgICAgICBldmVudE1hbmFnZXIsXG4gICAgICAgICAgICBzaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlbW92ZVN0eWxlc09uQ29tcERlc3Ryb3ksXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBuZ1pvbmUsXG4gICAgICAgICAgICBwbGF0Zm9ybUlzU2VydmVyLFxuICAgICAgICAgICAgdHJhY2luZ1NlcnZpY2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXJCeUNvbXBJZC5zZXQodHlwZS5pZCwgcmVuZGVyZXIpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlcjtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXJCeUNvbXBJZC5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgZHVyaW5nIEhNUiB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgYWJvdXQgYSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjb21wb25lbnRJZCBJRCBvZiB0aGUgY29tcG9uZW50IHRoYXQgaXMgYmVpbmcgcmVwbGFjZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgY29tcG9uZW50UmVwbGFjZWQoY29tcG9uZW50SWQ6IHN0cmluZykge1xuICAgIHRoaXMucmVuZGVyZXJCeUNvbXBJZC5kZWxldGUoY29tcG9uZW50SWQpO1xuICB9XG59XG5cbmNsYXNzIERlZmF1bHREb21SZW5kZXJlcjIgaW1wbGVtZW50cyBSZW5kZXJlcjIge1xuICBkYXRhOiB7W2tleTogc3RyaW5nXTogYW55fSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyByZW5kZXJlciB0aHJvd3Mgd2hlbiBlbmNvdW50ZXJpbmcgc3ludGhldGljIHByb3BlcnRpZXNcbiAgICogVGhpcyBjYW4gYmUgZGlzYWJsZWQgZm9yIGV4YW1wbGUgYnkgdGhlIEFzeW5jQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5XG4gICAqL1xuICB0aHJvd09uU3ludGhldGljUHJvcHMgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkb2M6IERvY3VtZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmdab25lOiBOZ1pvbmUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwbGF0Zm9ybUlzU2VydmVyOiBib29sZWFuLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHJhY2luZ1NlcnZpY2U6IFRyYWNpbmdTZXJ2aWNlPFRyYWNpbmdTbmFwc2hvdD4gfCBudWxsLFxuICApIHt9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHt9XG5cbiAgZGVzdHJveU5vZGUgPSBudWxsO1xuXG4gIGNyZWF0ZUVsZW1lbnQobmFtZTogc3RyaW5nLCBuYW1lc3BhY2U/OiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIC8vIFRPRE86IGB8fCBuYW1lc3BhY2VgIHdhcyBhZGRlZCBpblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9jb21taXQvMmI5Y2M4NTAzZDQ4MTczNDkyYzI5ZjVhMjcxYjYxMTI2MTA0ZmJkYiB0b1xuICAgICAgLy8gc3VwcG9ydCBob3cgSXZ5IHBhc3NlZCBhcm91bmQgdGhlIG5hbWVzcGFjZSBVUkkgcmF0aGVyIHRoYW4gc2hvcnQgbmFtZSBhdCB0aGUgdGltZS4gSXQgZGlkXG4gICAgICAvLyBub3QsIGhvd2V2ZXIgZXh0ZW5kIHRoZSBzdXBwb3J0IHRvIG90aGVyIHBhcnRzIG9mIHRoZSBzeXN0ZW0gKHNldEF0dHJpYnV0ZSwgc2V0QXR0cmlidXRlLFxuICAgICAgLy8gYW5kIHRoZSBTZXJ2ZXJSZW5kZXJlcikuIFdlIHNob3VsZCBkZWNpZGUgd2hhdCBleGFjdGx5IHRoZSBzZW1hbnRpY3MgZm9yIGRlYWxpbmcgd2l0aFxuICAgICAgLy8gbmFtZXNwYWNlcyBzaG91bGQgYmUgYW5kIG1ha2UgaXQgY29uc2lzdGVudC5cbiAgICAgIC8vIFJlbGF0ZWQgaXNzdWVzOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNDQwMjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQ0ODgzXG4gICAgICByZXR1cm4gdGhpcy5kb2MuY3JlYXRlRWxlbWVudE5TKE5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0gfHwgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kb2MuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgfVxuXG4gIGNyZWF0ZUNvbW1lbnQodmFsdWU6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpO1xuICB9XG5cbiAgY3JlYXRlVGV4dCh2YWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICB9XG5cbiAgYXBwZW5kQ2hpbGQocGFyZW50OiBhbnksIG5ld0NoaWxkOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXRQYXJlbnQgPSBpc1RlbXBsYXRlTm9kZShwYXJlbnQpID8gcGFyZW50LmNvbnRlbnQgOiBwYXJlbnQ7XG4gICAgdGFyZ2V0UGFyZW50LmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgfVxuXG4gIGluc2VydEJlZm9yZShwYXJlbnQ6IGFueSwgbmV3Q2hpbGQ6IGFueSwgcmVmQ2hpbGQ6IGFueSk6IHZvaWQge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldFBhcmVudCA9IGlzVGVtcGxhdGVOb2RlKHBhcmVudCkgPyBwYXJlbnQuY29udGVudCA6IHBhcmVudDtcbiAgICAgIHRhcmdldFBhcmVudC5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHJlZkNoaWxkKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVDaGlsZChfcGFyZW50OiBhbnksIG9sZENoaWxkOiBhbnkpOiB2b2lkIHtcbiAgICBvbGRDaGlsZC5yZW1vdmUoKTtcbiAgfVxuXG4gIHNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlOiBzdHJpbmcgfCBhbnksIHByZXNlcnZlQ29udGVudD86IGJvb2xlYW4pOiBhbnkge1xuICAgIGxldCBlbDogYW55ID1cbiAgICAgIHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycgPyB0aGlzLmRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yT3JOb2RlKSA6IHNlbGVjdG9yT3JOb2RlO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgIFJ1bnRpbWVFcnJvckNvZGUuUk9PVF9OT0RFX05PVF9GT1VORCxcbiAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiZcbiAgICAgICAgICBgVGhlIHNlbGVjdG9yIFwiJHtzZWxlY3Rvck9yTm9kZX1cIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c2AsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXByZXNlcnZlQ29udGVudCkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgcGFyZW50Tm9kZShub2RlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICBuZXh0U2libGluZyhub2RlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlKGVsOiBhbnksIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgbmFtZSA9IG5hbWVzcGFjZSArICc6JyArIG5hbWU7XG4gICAgICBjb25zdCBuYW1lc3BhY2VVcmkgPSBOQU1FU1BBQ0VfVVJJU1tuYW1lc3BhY2VdO1xuICAgICAgaWYgKG5hbWVzcGFjZVVyaSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVcmksIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQXR0cmlidXRlKGVsOiBhbnksIG5hbWU6IHN0cmluZywgbmFtZXNwYWNlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgY29uc3QgbmFtZXNwYWNlVXJpID0gTkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXTtcbiAgICAgIGlmIChuYW1lc3BhY2VVcmkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMobmFtZXNwYWNlVXJpLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShgJHtuYW1lc3BhY2V9OiR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGFkZENsYXNzKGVsOiBhbnksIG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gIH1cblxuICByZW1vdmVDbGFzcyhlbDogYW55LCBuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICB9XG5cbiAgc2V0U3R5bGUoZWw6IGFueSwgc3R5bGU6IHN0cmluZywgdmFsdWU6IGFueSwgZmxhZ3M6IFJlbmRlcmVyU3R5bGVGbGFnczIpOiB2b2lkIHtcbiAgICBpZiAoZmxhZ3MgJiAoUmVuZGVyZXJTdHlsZUZsYWdzMi5EYXNoQ2FzZSB8IFJlbmRlcmVyU3R5bGVGbGFnczIuSW1wb3J0YW50KSkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGUsIHZhbHVlLCBmbGFncyAmIFJlbmRlcmVyU3R5bGVGbGFnczIuSW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW3N0eWxlXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVN0eWxlKGVsOiBhbnksIHN0eWxlOiBzdHJpbmcsIGZsYWdzOiBSZW5kZXJlclN0eWxlRmxhZ3MyKTogdm9pZCB7XG4gICAgaWYgKGZsYWdzICYgUmVuZGVyZXJTdHlsZUZsYWdzMi5EYXNoQ2FzZSkge1xuICAgICAgLy8gcmVtb3ZlUHJvcGVydHkgaGFzIG5vIGVmZmVjdCB3aGVuIHVzZWQgb24gY2FtZWxDYXNlZCBwcm9wZXJ0aWVzLlxuICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtzdHlsZV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBzZXRQcm9wZXJ0eShlbDogYW55LCBuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmXG4gICAgICB0aGlzLnRocm93T25TeW50aGV0aWNQcm9wcyAmJlxuICAgICAgY2hlY2tOb1N5bnRoZXRpY1Byb3AobmFtZSwgJ3Byb3BlcnR5Jyk7XG4gICAgZWxbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKG5vZGU6IGFueSwgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIG5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBsaXN0ZW4oXG4gICAgdGFyZ2V0OiAnd2luZG93JyB8ICdkb2N1bWVudCcgfCAnYm9keScgfCBhbnksXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBjYWxsYmFjazogKGV2ZW50OiBhbnkpID0+IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IExpc3RlbmVyT3B0aW9ucyxcbiAgKTogKCkgPT4gdm9pZCB7XG4gICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiZcbiAgICAgIHRoaXMudGhyb3dPblN5bnRoZXRpY1Byb3BzICYmXG4gICAgICBjaGVja05vU3ludGhldGljUHJvcChldmVudCwgJ2xpc3RlbmVyJyk7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YXJnZXQgPSBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCh0aGlzLmRvYywgdGFyZ2V0KTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgUnVudGltZUVycm9yQ29kZS5VTlNVUFBPUlRFRF9FVkVOVF9UQVJHRVQsXG4gICAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiZcbiAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBldmVudCB0YXJnZXQgJHt0YXJnZXR9IGZvciBldmVudCAke2V2ZW50fWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZWRDYWxsYmFjayA9IHRoaXMuZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChjYWxsYmFjayk7XG5cbiAgICBpZiAodGhpcy50cmFjaW5nU2VydmljZT8ud3JhcEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdyYXBwZWRDYWxsYmFjayA9IHRoaXMudHJhY2luZ1NlcnZpY2Uud3JhcEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudCwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIHRhcmdldCxcbiAgICAgIGV2ZW50LFxuICAgICAgd3JhcHBlZENhbGxiYWNrLFxuICAgICAgb3B0aW9ucyxcbiAgICApIGFzIFZvaWRGdW5jdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChldmVudEhhbmRsZXI6IEZ1bmN0aW9uKTogRnVuY3Rpb24ge1xuICAgIC8vIGBEZWJ1Z05vZGUudHJpZ2dlckV2ZW50SGFuZGxlcmAgbmVlZHMgdG8ga25vdyBpZiB0aGUgbGlzdGVuZXIgd2FzIGNyZWF0ZWQgd2l0aFxuICAgIC8vIGRlY29yYXRlUHJldmVudERlZmF1bHQgb3IgaXMgYSBsaXN0ZW5lciBhZGRlZCBvdXRzaWRlIHRoZSBBbmd1bGFyIGNvbnRleHQgc28gaXQgY2FuIGhhbmRsZVxuICAgIC8vIHRoZSB0d28gZGlmZmVyZW50bHkuIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgc3BlY2lhbCAnX19uZ1Vud3JhcF9fJyB0b2tlbiBpcyBwYXNzZWQgdG8gdGhlXG4gICAgLy8gdW53cmFwIHRoZSBsaXN0ZW5lciAoc2VlIGJlbG93KS5cbiAgICByZXR1cm4gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgIC8vIEl2eSB1c2VzICdfX25nVW53cmFwX18nIGFzIGEgc3BlY2lhbCB0b2tlbiB0aGF0IGFsbG93cyB1cyB0byB1bndyYXAgdGhlIGZ1bmN0aW9uXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBpbnZva2VkIHByb2dyYW1tYXRpY2FsbHkgYnkgYERlYnVnTm9kZS50cmlnZ2VyRXZlbnRIYW5kbGVyYC4gVGhlXG4gICAgICAvLyBkZWJ1Z19ub2RlIGNhbiBpbnNwZWN0IHRoZSBsaXN0ZW5lciB0b1N0cmluZyBjb250ZW50cyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIHNwZWNpYWxcbiAgICAgIC8vIHRva2VuLiBCZWNhdXNlIHRoZSB0b2tlbiBpcyBhIHN0cmluZyBsaXRlcmFsLCBpdCBpcyBlbnN1cmVkIHRvIG5vdCBiZSBtb2RpZmllZCBieSBjb21waWxlZFxuICAgICAgLy8gY29kZS5cbiAgICAgIGlmIChldmVudCA9PT0gJ19fbmdVbndyYXBfXycpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcjtcbiAgICAgIH1cblxuICAgICAgLy8gUnVuIHRoZSBldmVudCBoYW5kbGVyIGluc2lkZSB0aGUgbmdab25lIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCBwYXRjaGVkXG4gICAgICAvLyBieSBab25lIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgaXMgcmVxdWlyZWQgb25seSBmb3IgdGVzdHMuXG4gICAgICBjb25zdCBhbGxvd0RlZmF1bHRCZWhhdmlvciA9IHRoaXMucGxhdGZvcm1Jc1NlcnZlclxuICAgICAgICA/IHRoaXMubmdab25lLnJ1bkd1YXJkZWQoKCkgPT4gZXZlbnRIYW5kbGVyKGV2ZW50KSlcbiAgICAgICAgOiBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgaWYgKGFsbG93RGVmYXVsdEJlaGF2aW9yID09PSBmYWxzZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbn1cblxuY29uc3QgQVRfQ0hBUkNPREUgPSAoKCkgPT4gJ0AnLmNoYXJDb2RlQXQoMCkpKCk7XG5mdW5jdGlvbiBjaGVja05vU3ludGhldGljUHJvcChuYW1lOiBzdHJpbmcsIG5hbWVLaW5kOiBzdHJpbmcpIHtcbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gQVRfQ0hBUkNPREUpIHtcbiAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgUnVudGltZUVycm9yQ29kZS5VTkVYUEVDVEVEX1NZTlRIRVRJQ19QUk9QRVJUWSxcbiAgICAgIGBVbmV4cGVjdGVkIHN5bnRoZXRpYyAke25hbWVLaW5kfSAke25hbWV9IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQ6XG4gIC0gTWFrZSBzdXJlIFxcYHByb3ZpZGVBbmltYXRpb25zQXN5bmMoKVxcYCwgXFxgcHJvdmlkZUFuaW1hdGlvbnMoKVxcYCBvciBcXGBwcm92aWRlTm9vcEFuaW1hdGlvbnMoKVxcYCBjYWxsIHdhcyBhZGRlZCB0byBhIGxpc3Qgb2YgcHJvdmlkZXJzIHVzZWQgdG8gYm9vdHN0cmFwIGFuIGFwcGxpY2F0aW9uLlxuICAtIFRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBhbmltYXRpb24gY29uZmlndXJhdGlvbiBuYW1lZCBcXGAke25hbWV9XFxgIGRlZmluZWQgaW4gdGhlIFxcYGFuaW1hdGlvbnNcXGAgZmllbGQgb2YgdGhlIFxcYEBDb21wb25lbnRcXGAgZGVjb3JhdG9yIChzZWUgaHR0cHM6Ly9hbmd1bGFyLmRldi9hcGkvY29yZS9Db21wb25lbnQjYW5pbWF0aW9ucykuYCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGU6IGFueSk6IG5vZGUgaXMgSFRNTFRlbXBsYXRlRWxlbWVudCB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdURU1QTEFURScgJiYgbm9kZS5jb250ZW50ICE9PSB1bmRlZmluZWQ7XG59XG5cbmNsYXNzIFNoYWRvd0RvbVJlbmRlcmVyIGV4dGVuZHMgRGVmYXVsdERvbVJlbmRlcmVyMiB7XG4gIHByaXZhdGUgc2hhZG93Um9vdDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyLFxuICAgIHByaXZhdGUgc2hhcmVkU3R5bGVzSG9zdDogU2hhcmVkU3R5bGVzSG9zdCxcbiAgICBwcml2YXRlIGhvc3RFbDogYW55LFxuICAgIGNvbXBvbmVudDogUmVuZGVyZXJUeXBlMixcbiAgICBkb2M6IERvY3VtZW50LFxuICAgIG5nWm9uZTogTmdab25lLFxuICAgIG5vbmNlOiBzdHJpbmcgfCBudWxsLFxuICAgIHBsYXRmb3JtSXNTZXJ2ZXI6IGJvb2xlYW4sXG4gICAgdHJhY2luZ1NlcnZpY2U6IFRyYWNpbmdTZXJ2aWNlPFRyYWNpbmdTbmFwc2hvdD4gfCBudWxsLFxuICApIHtcbiAgICBzdXBlcihldmVudE1hbmFnZXIsIGRvYywgbmdab25lLCBwbGF0Zm9ybUlzU2VydmVyLCB0cmFjaW5nU2VydmljZSk7XG4gICAgdGhpcy5zaGFkb3dSb290ID0gKGhvc3RFbCBhcyBhbnkpLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0LmFkZEhvc3QodGhpcy5zaGFkb3dSb290KTtcbiAgICBsZXQgc3R5bGVzID0gY29tcG9uZW50LnN0eWxlcztcbiAgICBpZiAobmdEZXZNb2RlKSB7XG4gICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaW4gZGV2ZWxvcG1lbnQsIGFzIGZvciBwcm9kdWN0aW9uIHVzZXJzIHNob3VsZCBub3QgYWRkIENTUyBzb3VyY2VtYXBzIHRvIGNvbXBvbmVudHMuXG4gICAgICBjb25zdCBiYXNlSHJlZiA9IGdldERPTSgpLmdldEJhc2VIcmVmKGRvYykgPz8gJyc7XG4gICAgICBzdHlsZXMgPSBhZGRCYXNlSHJlZlRvQ3NzU291cmNlTWFwKGJhc2VIcmVmLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIHN0eWxlcyA9IHNoaW1TdHlsZXNDb250ZW50KGNvbXBvbmVudC5pZCwgc3R5bGVzKTtcblxuICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICBjb25zdCBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IHN0eWxlO1xuICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGFueSBleHRlcm5hbCBjb21wb25lbnQgc3R5bGVzIHRvIHRoZSBzaGFkb3cgcm9vdCBmb3IgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAgLy8gVGhlIFNoYWRvd0RPTSByZW5kZXJlciB1c2VzIGFuIGFsdGVybmF0aXZlIGV4ZWN1dGlvbiBwYXRoIGZvciBjb21wb25lbnQgc3R5bGVzIHRoYXRcbiAgICAvLyBkb2VzIG5vdCB1c2UgdGhlIFNoYXJlZFN0eWxlc0hvc3QgdGhhdCBvdGhlciBlbmNhcHN1bGF0aW9uIG1vZGVzIGxldmVyYWdlLiBNdWNoIGxpa2VcbiAgICAvLyB0aGUgbWFudWFsIGFkZGl0aW9uIG9mIGVtYmVkZGVkIHN0eWxlcyBkaXJlY3RseSBhYm92ZSwgYW55IGV4dGVybmFsIHN0eWxlc2hlZXRzXG4gICAgLy8gbXVzdCBiZSBtYW51YWxseSBhZGRlZCBoZXJlIHRvIGVuc3VyZSBTaGFkb3dET00gY29tcG9uZW50cyBhcmUgY29ycmVjdGx5IHN0eWxlZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciByZXdvcmtpbmcgdGhlIERPTSBSZW5kZXJlcnMgdG8gY29uc29saWRhdGUgc3R5bGUgaGFuZGxpbmcuXG4gICAgY29uc3Qgc3R5bGVVcmxzID0gY29tcG9uZW50LmdldEV4dGVybmFsU3R5bGVzPy4oKTtcbiAgICBpZiAoc3R5bGVVcmxzKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0eWxlVXJsIG9mIHN0eWxlVXJscykge1xuICAgICAgICBjb25zdCBsaW5rRWwgPSBjcmVhdGVMaW5rRWxlbWVudChzdHlsZVVybCwgZG9jKTtcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgbGlua0VsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGxpbmtFbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBub2RlT3JTaGFkb3dSb290KG5vZGU6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIG5vZGUgPT09IHRoaXMuaG9zdEVsID8gdGhpcy5zaGFkb3dSb290IDogbm9kZTtcbiAgfVxuXG4gIG92ZXJyaWRlIGFwcGVuZENoaWxkKHBhcmVudDogYW55LCBuZXdDaGlsZDogYW55KTogdm9pZCB7XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZU9yU2hhZG93Um9vdChwYXJlbnQpLCBuZXdDaGlsZCk7XG4gIH1cbiAgb3ZlcnJpZGUgaW5zZXJ0QmVmb3JlKHBhcmVudDogYW55LCBuZXdDaGlsZDogYW55LCByZWZDaGlsZDogYW55KTogdm9pZCB7XG4gICAgcmV0dXJuIHN1cGVyLmluc2VydEJlZm9yZSh0aGlzLm5vZGVPclNoYWRvd1Jvb3QocGFyZW50KSwgbmV3Q2hpbGQsIHJlZkNoaWxkKTtcbiAgfVxuICBvdmVycmlkZSByZW1vdmVDaGlsZChfcGFyZW50OiBhbnksIG9sZENoaWxkOiBhbnkpOiB2b2lkIHtcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlQ2hpbGQobnVsbCwgb2xkQ2hpbGQpO1xuICB9XG4gIG92ZXJyaWRlIHBhcmVudE5vZGUobm9kZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5ub2RlT3JTaGFkb3dSb290KHN1cGVyLnBhcmVudE5vZGUodGhpcy5ub2RlT3JTaGFkb3dSb290KG5vZGUpKSk7XG4gIH1cblxuICBvdmVycmlkZSBkZXN0cm95KCkge1xuICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KHRoaXMuc2hhZG93Um9vdCk7XG4gIH1cbn1cblxuY2xhc3MgTm9uZUVuY2Fwc3VsYXRpb25Eb21SZW5kZXJlciBleHRlbmRzIERlZmF1bHREb21SZW5kZXJlcjIge1xuICBwcml2YXRlIHJlYWRvbmx5IHN0eWxlczogc3RyaW5nW107XG4gIHByaXZhdGUgcmVhZG9ubHkgc3R5bGVVcmxzPzogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaGFyZWRTdHlsZXNIb3N0OiBTaGFyZWRTdHlsZXNIb3N0LFxuICAgIGNvbXBvbmVudDogUmVuZGVyZXJUeXBlMixcbiAgICBwcml2YXRlIHJlbW92ZVN0eWxlc09uQ29tcERlc3Ryb3k6IGJvb2xlYW4sXG4gICAgZG9jOiBEb2N1bWVudCxcbiAgICBuZ1pvbmU6IE5nWm9uZSxcbiAgICBwbGF0Zm9ybUlzU2VydmVyOiBib29sZWFuLFxuICAgIHRyYWNpbmdTZXJ2aWNlOiBUcmFjaW5nU2VydmljZTxUcmFjaW5nU25hcHNob3Q+IHwgbnVsbCxcbiAgICBjb21wSWQ/OiBzdHJpbmcsXG4gICkge1xuICAgIHN1cGVyKGV2ZW50TWFuYWdlciwgZG9jLCBuZ1pvbmUsIHBsYXRmb3JtSXNTZXJ2ZXIsIHRyYWNpbmdTZXJ2aWNlKTtcbiAgICBsZXQgc3R5bGVzID0gY29tcG9uZW50LnN0eWxlcztcbiAgICBpZiAobmdEZXZNb2RlKSB7XG4gICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaW4gZGV2ZWxvcG1lbnQsIGFzIGZvciBwcm9kdWN0aW9uIHVzZXJzIHNob3VsZCBub3QgYWRkIENTUyBzb3VyY2VtYXBzIHRvIGNvbXBvbmVudHMuXG4gICAgICBjb25zdCBiYXNlSHJlZiA9IGdldERPTSgpLmdldEJhc2VIcmVmKGRvYykgPz8gJyc7XG4gICAgICBzdHlsZXMgPSBhZGRCYXNlSHJlZlRvQ3NzU291cmNlTWFwKGJhc2VIcmVmLCBzdHlsZXMpO1xuICAgIH1cblxuICAgIHRoaXMuc3R5bGVzID0gY29tcElkID8gc2hpbVN0eWxlc0NvbnRlbnQoY29tcElkLCBzdHlsZXMpIDogc3R5bGVzO1xuICAgIHRoaXMuc3R5bGVVcmxzID0gY29tcG9uZW50LmdldEV4dGVybmFsU3R5bGVzPy4oY29tcElkKTtcbiAgfVxuXG4gIGFwcGx5U3R5bGVzKCk6IHZvaWQge1xuICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXModGhpcy5zdHlsZXMsIHRoaXMuc3R5bGVVcmxzKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnJlbW92ZVN0eWxlc09uQ29tcERlc3Ryb3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QucmVtb3ZlU3R5bGVzKHRoaXMuc3R5bGVzLCB0aGlzLnN0eWxlVXJscyk7XG4gIH1cbn1cblxuY2xhc3MgRW11bGF0ZWRFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIyIGV4dGVuZHMgTm9uZUVuY2Fwc3VsYXRpb25Eb21SZW5kZXJlciB7XG4gIHByaXZhdGUgY29udGVudEF0dHI6IHN0cmluZztcbiAgcHJpdmF0ZSBob3N0QXR0cjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyLFxuICAgIHNoYXJlZFN0eWxlc0hvc3Q6IFNoYXJlZFN0eWxlc0hvc3QsXG4gICAgY29tcG9uZW50OiBSZW5kZXJlclR5cGUyLFxuICAgIGFwcElkOiBzdHJpbmcsXG4gICAgcmVtb3ZlU3R5bGVzT25Db21wRGVzdHJveTogYm9vbGVhbixcbiAgICBkb2M6IERvY3VtZW50LFxuICAgIG5nWm9uZTogTmdab25lLFxuICAgIHBsYXRmb3JtSXNTZXJ2ZXI6IGJvb2xlYW4sXG4gICAgdHJhY2luZ1NlcnZpY2U6IFRyYWNpbmdTZXJ2aWNlPFRyYWNpbmdTbmFwc2hvdD4gfCBudWxsLFxuICApIHtcbiAgICBjb25zdCBjb21wSWQgPSBhcHBJZCArICctJyArIGNvbXBvbmVudC5pZDtcbiAgICBzdXBlcihcbiAgICAgIGV2ZW50TWFuYWdlcixcbiAgICAgIHNoYXJlZFN0eWxlc0hvc3QsXG4gICAgICBjb21wb25lbnQsXG4gICAgICByZW1vdmVTdHlsZXNPbkNvbXBEZXN0cm95LFxuICAgICAgZG9jLFxuICAgICAgbmdab25lLFxuICAgICAgcGxhdGZvcm1Jc1NlcnZlcixcbiAgICAgIHRyYWNpbmdTZXJ2aWNlLFxuICAgICAgY29tcElkLFxuICAgICk7XG4gICAgdGhpcy5jb250ZW50QXR0ciA9IHNoaW1Db250ZW50QXR0cmlidXRlKGNvbXBJZCk7XG4gICAgdGhpcy5ob3N0QXR0ciA9IHNoaW1Ib3N0QXR0cmlidXRlKGNvbXBJZCk7XG4gIH1cblxuICBhcHBseVRvSG9zdChlbGVtZW50OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdGhpcy5ob3N0QXR0ciwgJycpO1xuICB9XG5cbiAgb3ZlcnJpZGUgY3JlYXRlRWxlbWVudChwYXJlbnQ6IGFueSwgbmFtZTogc3RyaW5nKTogRWxlbWVudCB7XG4gICAgY29uc3QgZWwgPSBzdXBlci5jcmVhdGVFbGVtZW50KHBhcmVudCwgbmFtZSk7XG4gICAgc3VwZXIuc2V0QXR0cmlidXRlKGVsLCB0aGlzLmNvbnRlbnRBdHRyLCAnJyk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG4iXX0=", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ɵparseCookieValue as parseCookieValue,\n  ɵsetRootDomAdapter as setRootDomAdapter,\n  ɵDomAdapter as DomAdapter,\n} from '@angular/common';\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport class BrowserDomAdapter extends DomAdapter {\n  override readonly supportsDOMEvents: boolean = true;\n\n  static makeCurrent() {\n    setRootDomAdapter(new BrowserDomAdapter());\n  }\n\n  override onAndCancel(el: Node, evt: any, listener: any, options: any): Function {\n    el.addEventListener(evt, listener, options);\n    return () => {\n      el.removeEventListener(evt, listener, options);\n    };\n  }\n  override dispatchEvent(el: Node, evt: any) {\n    el.dispatchEvent(evt);\n  }\n  override remove(node: Node): void {\n    (node as Element | Text | Comment).remove();\n  }\n  override createElement(tagName: string, doc?: Document): HTMLElement {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  override createHtmlDocument(): Document {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  override getDefaultDocument(): Document {\n    return document;\n  }\n\n  override isElementNode(node: Node): boolean {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n\n  override isShadowRoot(node: any): boolean {\n    return node instanceof DocumentFragment;\n  }\n\n  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n  override getGlobalEventTarget(doc: Document, target: string): EventTarget | null {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  override getBaseHref(doc: Document): string | null {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  override resetBaseElement(): void {\n    baseElement = null;\n  }\n  override getUserAgent(): string {\n    return window.navigator.userAgent;\n  }\n  override getCookie(name: string): string | null {\n    return parseCookieValue(document.cookie, name);\n  }\n}\n\nlet baseElement: HTMLElement | null = null;\nfunction getBaseElementHref(): string | null {\n  baseElement = baseElement || document.querySelector('base');\n  return baseElement ? baseElement.getAttribute('href') : null;\n}\n\nfunction relativePath(url: string): string {\n  // The base URL doesn't really matter, we just need it so relative paths have something\n  // to resolve against. In the browser `HTMLBaseElement.href` is always absolute.\n  return new URL(url, document.baseURI).pathname;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {\n  GetTestability,\n  Testability,\n  TestabilityRegistry,\n  ɵglobal as global,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nexport class BrowserGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {\n    global['getAngularTestability'] = (elem: any, findInAncestors: boolean = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new RuntimeError(\n          RuntimeErrorCode.TESTABILITY_NOT_FOUND,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            'Could not find testability for element.',\n        );\n      }\n      return testability;\n    };\n\n    global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n\n    global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n\n    const whenAllStable = (callback: () => void) => {\n      const testabilities = global['getAllAngularTestabilities']() as Testability[];\n      let count = testabilities.length;\n      const decrement = function () {\n        count--;\n        if (count == 0) {\n          callback();\n        }\n      };\n      testabilities.forEach((testability) => {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!global['frameworkStabilizers']) {\n      global['frameworkStabilizers'] = [];\n    }\n    global['frameworkStabilizers'].push(whenAllStable);\n  }\n\n  findTestabilityInTree(\n    registry: TestabilityRegistry,\n    elem: any,\n    findInAncestors: boolean,\n  ): Testability | null {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, (<any>elem).host, true);\n    }\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {XhrFactory} from '@angular/common';\nimport {Injectable} from '@angular/core';\n\n/**\n * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.\n */\n@Injectable()\nexport class BrowserXhr implements XhrFactory {\n  build(): XMLHttpRequest {\n    return new XMLHttpRequest();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, type ListenerOptions} from '@angular/core';\n\nimport {EventManagerPlugin} from './event_manager';\n\n@Injectable()\nexport class DomEventsPlugin extends EventManagerPlugin {\n  constructor(@Inject(DOCUMENT) doc: any) {\n    super(doc);\n  }\n\n  // This plugin should come last in the list of plugins, because it accepts all\n  // events.\n  override supports(eventName: string): boolean {\n    return true;\n  }\n\n  override addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    element.addEventListener(eventName, handler as EventListener, options);\n    return () => this.removeEventListener(element, eventName, handler as EventListener, options);\n  }\n\n  removeEventListener(\n    target: any,\n    eventName: string,\n    callback: Function,\n    options?: ListenerOptions,\n  ): void {\n    return target.removeEventListener(eventName, callback as EventListener, options);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable, type ListenerOptions, NgZone} from '@angular/core';\n\nimport {EventManagerPlugin} from './event_manager';\n\n/**\n * Defines supported modifiers for key events.\n */\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\n\n// The following values are here for cross-browser compatibility and to match the W3C standard\n// cf https://www.w3.org/TR/DOM-Level-3-Events-key/\nconst _keyMap: {[k: string]: string} = {\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS',\n};\n\n/**\n * Retrieves modifiers from key-event objects.\n */\nconst MODIFIER_KEY_GETTERS: {[key: string]: (event: KeyboardEvent) => boolean} = {\n  'alt': (event: KeyboardEvent) => event.altKey,\n  'control': (event: KeyboardEvent) => event.ctrlKey,\n  'meta': (event: KeyboardEvent) => event.metaKey,\n  'shift': (event: KeyboardEvent) => event.shiftKey,\n};\n\n/**\n * A browser plug-in that provides support for handling of key events in Angular.\n */\n@Injectable()\nexport class KeyEventsPlugin extends EventManagerPlugin {\n  /**\n   * Initializes an instance of the browser plug-in.\n   * @param doc The document in which key events will be detected.\n   */\n  constructor(@Inject(DOCUMENT) doc: any) {\n    super(doc);\n  }\n\n  /**\n   * Reports whether a named key event is supported.\n   * @param eventName The event name to query.\n   * @return True if the named key event is supported.\n   */\n  override supports(eventName: string): boolean {\n    return KeyEventsPlugin.parseEventName(eventName) != null;\n  }\n\n  /**\n   * Registers a handler for a specific element and key event.\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the key event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns The key event that was registered.\n   */\n  override addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    const parsedEvent = KeyEventsPlugin.parseEventName(eventName)!;\n\n    const outsideHandler = KeyEventsPlugin.eventCallback(\n      parsedEvent['fullKey'],\n      handler,\n      this.manager.getZone(),\n    );\n\n    return this.manager.getZone().runOutsideAngular(() => {\n      return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler, options);\n    });\n  }\n\n  /**\n   * Parses the user provided full keyboard event definition and normalizes it for\n   * later internal use. It ensures the string is all lowercase, converts special\n   * characters to a standard spelling, and orders all the values consistently.\n   *\n   * @param eventName The name of the key event to listen for.\n   * @returns an object with the full, normalized string, and the dom event name\n   * or null in the case when the event doesn't match a keyboard event.\n   */\n  static parseEventName(eventName: string): {fullKey: string; domEventName: string} | null {\n    const parts: string[] = eventName.toLowerCase().split('.');\n\n    const domEventName = parts.shift();\n    if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n      return null;\n    }\n\n    const key = KeyEventsPlugin._normalizeKey(parts.pop()!);\n\n    let fullKey = '';\n    let codeIX = parts.indexOf('code');\n    if (codeIX > -1) {\n      parts.splice(codeIX, 1);\n      fullKey = 'code.';\n    }\n    MODIFIER_KEYS.forEach((modifierName) => {\n      const index: number = parts.indexOf(modifierName);\n      if (index > -1) {\n        parts.splice(index, 1);\n        fullKey += modifierName + '.';\n      }\n    });\n    fullKey += key;\n\n    if (parts.length != 0 || key.length === 0) {\n      // returning null instead of throwing to let another plugin process the event\n      return null;\n    }\n\n    // NOTE: Please don't rewrite this as so, as it will break JSCompiler property renaming.\n    //       The code must remain in the `result['domEventName']` form.\n    // return {domEventName, fullKey};\n    const result: {fullKey: string; domEventName: string} = {} as any;\n    result['domEventName'] = domEventName;\n    result['fullKey'] = fullKey;\n    return result;\n  }\n\n  /**\n   * Determines whether the actual keys pressed match the configured key code string.\n   * The `fullKeyCode` event is normalized in the `parseEventName` method when the\n   * event is attached to the DOM during the `addEventListener` call. This is unseen\n   * by the end user and is normalized for internal consistency and parsing.\n   *\n   * @param event The keyboard event.\n   * @param fullKeyCode The normalized user defined expected key event string\n   * @returns boolean.\n   */\n  static matchEventFullKeyCode(event: KeyboardEvent, fullKeyCode: string): boolean {\n    let keycode = _keyMap[event.key] || event.key;\n    let key = '';\n    if (fullKeyCode.indexOf('code.') > -1) {\n      keycode = event.code;\n      key = 'code.';\n    }\n    // the keycode could be unidentified so we have to check here\n    if (keycode == null || !keycode) return false;\n    keycode = keycode.toLowerCase();\n    if (keycode === ' ') {\n      keycode = 'space'; // for readability\n    } else if (keycode === '.') {\n      keycode = 'dot'; // because '.' is used as a separator in event names\n    }\n    MODIFIER_KEYS.forEach((modifierName) => {\n      if (modifierName !== keycode) {\n        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n        if (modifierGetter(event)) {\n          key += modifierName + '.';\n        }\n      }\n    });\n    key += keycode;\n    return key === fullKeyCode;\n  }\n\n  /**\n   * Configures a handler callback for a key event.\n   * @param fullKey The event name that combines all simultaneous keystrokes.\n   * @param handler The function that responds to the key event.\n   * @param zone The zone in which the event occurred.\n   * @returns A callback function.\n   */\n  static eventCallback(fullKey: string, handler: Function, zone: NgZone): Function {\n    return (event: KeyboardEvent) => {\n      if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {\n        zone.runGuarded(() => handler(event));\n      }\n    };\n  }\n\n  /** @internal */\n  static _normalizeKey(keyName: string): string {\n    return keyName === 'esc' ? 'escape' : keyName;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  CommonModule,\n  DOCUMENT,\n  XhrFactory,\n  ɵPLATFORM_BROWSER_ID as PLATFORM_BROWSER_ID,\n} from '@angular/common';\nimport {\n  ApplicationConfig as ApplicationConfigFromCore,\n  ApplicationModule,\n  ApplicationRef,\n  createPlatformFactory,\n  ErrorHandler,\n  InjectionToken,\n  NgModule,\n  NgZone,\n  PLATFORM_ID,\n  PLATFORM_INITIALIZER,\n  platformCore,\n  PlatformRef,\n  Provider,\n  RendererFactory2,\n  StaticProvider,\n  Testability,\n  TestabilityRegistry,\n  Type,\n  ɵINJECTOR_SCOPE as INJECTOR_SCOPE,\n  ɵinternalCreateApplication as internalCreateApplication,\n  ɵRuntimeError as RuntimeError,\n  ɵsetDocument,\n  ɵTESTABILITY as TESTABILITY,\n  ɵTESTABILITY_GETTER as TESTABILITY_GETTER,\n  inject,\n} from '@angular/core';\n\nimport {BrowserDomAdapter} from './browser/browser_adapter';\nimport {BrowserGetTestability} from './browser/testability';\nimport {BrowserXhr} from './browser/xhr';\nimport {DomRendererFactory2} from './dom/dom_renderer';\nimport {DomEventsPlugin} from './dom/events/dom_events';\nimport {EVENT_MANAGER_PLUGINS, EventManager} from './dom/events/event_manager';\nimport {KeyEventsPlugin} from './dom/events/key_events';\nimport {SharedStylesHost} from './dom/shared_styles_host';\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * Set of config options available during the application bootstrap operation.\n *\n * @publicApi\n *\n * @deprecated\n * `ApplicationConfig` has moved, please import `ApplicationConfig` from `@angular/core` instead.\n */\n// The below is a workaround to add a deprecated message.\ntype ApplicationConfig = ApplicationConfigFromCore;\nexport {ApplicationConfig};\n\n/**\n * Bootstraps an instance of an Angular application and renders a standalone component as the\n * application's root component. More information about standalone components can be found in [this\n * guide](guide/components/importing).\n *\n * @usageNotes\n * The root component passed into this function *must* be a standalone one (should have the\n * `standalone: true` flag in the `@Component` decorator config).\n *\n * ```angular-ts\n * @Component({\n *   standalone: true,\n *   template: 'Hello world!'\n * })\n * class RootComponent {}\n *\n * const appRef: ApplicationRef = await bootstrapApplication(RootComponent);\n * ```\n *\n * You can add the list of providers that should be available in the application injector by\n * specifying the `providers` field in an object passed as the second argument:\n *\n * ```ts\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     {provide: BACKEND_URL, useValue: 'https://yourdomain.com/api'}\n *   ]\n * });\n * ```\n *\n * The `importProvidersFrom` helper method can be used to collect all providers from any\n * existing NgModule (and transitively from all NgModules that it imports):\n *\n * ```ts\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(SomeNgModule)\n *   ]\n * });\n * ```\n *\n * Note: the `bootstrapApplication` method doesn't include [Testability](api/core/Testability) by\n * default. You can add [Testability](api/core/Testability) by getting the list of necessary\n * providers using `provideProtractorTestingSupport()` function and adding them into the `providers`\n * array, for example:\n *\n * ```ts\n * import {provideProtractorTestingSupport} from '@angular/platform-browser';\n *\n * await bootstrapApplication(RootComponent, {providers: [provideProtractorTestingSupport()]});\n * ```\n *\n * @param rootComponent A reference to a standalone component that should be rendered.\n * @param options Extra configuration for the bootstrap operation, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n */\nexport function bootstrapApplication(\n  rootComponent: Type<unknown>,\n  options?: ApplicationConfig,\n): Promise<ApplicationRef> {\n  return internalCreateApplication({rootComponent, ...createProvidersConfig(options)});\n}\n\n/**\n * Create an instance of an Angular application without bootstrapping any components. This is useful\n * for the situation where one wants to decouple application environment creation (a platform and\n * associated injectors) from rendering components on a screen. Components can be subsequently\n * bootstrapped on the returned `ApplicationRef`.\n *\n * @param options Extra configuration for the application environment, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n */\nexport function createApplication(options?: ApplicationConfig) {\n  return internalCreateApplication(createProvidersConfig(options));\n}\n\nfunction createProvidersConfig(options?: ApplicationConfig) {\n  return {\n    appProviders: [...BROWSER_MODULE_PROVIDERS, ...(options?.providers ?? [])],\n    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS,\n  };\n}\n\n/**\n * Returns a set of providers required to setup [Testability](api/core/Testability) for an\n * application bootstrapped using the `bootstrapApplication` function. The set of providers is\n * needed to support testing an application with Protractor (which relies on the Testability APIs\n * to be present).\n *\n * @returns An array of providers required to setup Testability for an application and make it\n *     available for testing using Protractor.\n *\n * @publicApi\n */\nexport function provideProtractorTestingSupport(): Provider[] {\n  // Return a copy to prevent changes to the original array in case any in-place\n  // alterations are performed to the `provideProtractorTestingSupport` call results in app\n  // code.\n  return [...TESTABILITY_PROVIDERS];\n}\n\nexport function initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n}\n\nexport function errorHandler(): ErrorHandler {\n  return new ErrorHandler();\n}\n\nexport function _document(): any {\n  // Tell ivy about the global document\n  ɵsetDocument(document);\n  return document;\n}\n\nconst INTERNAL_BROWSER_PLATFORM_PROVIDERS: StaticProvider[] = [\n  {provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID},\n  {provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true},\n  {provide: DOCUMENT, useFactory: _document},\n];\n\n/**\n * A factory function that returns a `PlatformRef` instance associated with browser service\n * providers.\n *\n * @publicApi\n */\nexport const platformBrowser: (extraProviders?: StaticProvider[]) => PlatformRef =\n  createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n\n/**\n * Internal marker to signal whether providers from the `BrowserModule` are already present in DI.\n * This is needed to avoid loading `BrowserModule` providers twice. We can't rely on the\n * `BrowserModule` presence itself, since the standalone-based bootstrap just imports\n * `BrowserModule` providers without referencing the module itself.\n */\nconst BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'BrowserModule Providers Marker' : '',\n);\n\nconst TESTABILITY_PROVIDERS = [\n  {\n    provide: TESTABILITY_GETTER,\n    useClass: BrowserGetTestability,\n  },\n  {\n    provide: TESTABILITY,\n    useClass: Testability,\n    deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER],\n  },\n  {\n    provide: Testability, // Also provide as `Testability` for backwards-compatibility.\n    useClass: Testability,\n    deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER],\n  },\n];\n\nconst BROWSER_MODULE_PROVIDERS: Provider[] = [\n  {provide: INJECTOR_SCOPE, useValue: 'root'},\n  {provide: ErrorHandler, useFactory: errorHandler},\n  {\n    provide: EVENT_MANAGER_PLUGINS,\n    useClass: DomEventsPlugin,\n    multi: true,\n    deps: [DOCUMENT],\n  },\n  {provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT]},\n  DomRendererFactory2,\n  SharedStylesHost,\n  EventManager,\n  {provide: RendererFactory2, useExisting: DomRendererFactory2},\n  {provide: XhrFactory, useClass: BrowserXhr},\n  typeof ngDevMode === 'undefined' || ngDevMode\n    ? {provide: BROWSER_MODULE_PROVIDERS_MARKER, useValue: true}\n    : [],\n];\n\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by default in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * @publicApi\n */\n@NgModule({\n  providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],\n  exports: [CommonModule, ApplicationModule],\n})\nexport class BrowserModule {\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const providersAlreadyPresent = inject(BROWSER_MODULE_PROVIDERS_MARKER, {\n        optional: true,\n        skipSelf: true,\n      });\n\n      if (providersAlreadyPresent) {\n        throw new RuntimeError(\n          RuntimeErrorCode.BROWSER_MODULE_ALREADY_LOADED,\n          `Providers from the \\`BrowserModule\\` have already been loaded. If you need access ` +\n            `to common directives such as NgIf and NgFor, import the \\`CommonModule\\` instead.`,\n        );\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n *\n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n *\n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n *\n * @publicApi\n */\nexport abstract class HttpHandler {\n  abstract handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n}\n\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n *\n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n *\n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n *\n * @publicApi\n */\nexport abstract class HttpBackend implements HttpHandler {\n  abstract handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\ninterface Update {\n  name: string;\n  value?: string | string[];\n  op: 'a' | 's' | 'd';\n}\n\n/**\n * Represents the header configuration options for an HTTP request.\n * Instances are immutable. Modifying methods return a cloned\n * instance with the change. The original object is never changed.\n *\n * @publicApi\n */\nexport class HttpHeaders {\n  /**\n   * Internal map of lowercase header names to values.\n   */\n  private headers!: Map<string, string[]>;\n\n  /**\n   * Internal map of lowercased header names to the normalized\n   * form of the name (the form seen first).\n   */\n  private normalizedNames: Map<string, string> = new Map();\n\n  /**\n   * Complete the lazy initialization of this object (needed before reading).\n   */\n  private lazyInit!: HttpHeaders | Function | null;\n\n  /**\n   * Queued updates to be materialized the next initialization.\n   */\n  private lazyUpdate: Update[] | null = null;\n\n  /**  Constructs a new HTTP header object with the given values.*/\n\n  constructor(\n    headers?: string | {[name: string]: string | number | (string | number)[]} | Headers,\n  ) {\n    if (!headers) {\n      this.headers = new Map<string, string[]>();\n    } else if (typeof headers === 'string') {\n      this.lazyInit = () => {\n        this.headers = new Map<string, string[]>();\n        headers.split('\\n').forEach((line) => {\n          const index = line.indexOf(':');\n          if (index > 0) {\n            const name = line.slice(0, index);\n            const value = line.slice(index + 1).trim();\n            this.addHeaderEntry(name, value);\n          }\n        });\n      };\n    } else if (typeof Headers !== 'undefined' && headers instanceof Headers) {\n      this.headers = new Map<string, string[]>();\n      headers.forEach((value: string, name: string) => {\n        this.addHeaderEntry(name, value);\n      });\n    } else {\n      this.lazyInit = () => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          assertValidHeaders(headers);\n        }\n        this.headers = new Map<string, string[]>();\n        Object.entries(headers).forEach(([name, values]) => {\n          this.setHeaderEntries(name, values);\n        });\n      };\n    }\n  }\n\n  /**\n   * Checks for existence of a given header.\n   *\n   * @param name The header name to check for existence.\n   *\n   * @returns True if the header exists, false otherwise.\n   */\n  has(name: string): boolean {\n    this.init();\n\n    return this.headers.has(name.toLowerCase());\n  }\n\n  /**\n   * Retrieves the first value of a given header.\n   *\n   * @param name The header name.\n   *\n   * @returns The value string if the header exists, null otherwise\n   */\n  get(name: string): string | null {\n    this.init();\n\n    const values = this.headers.get(name.toLowerCase());\n    return values && values.length > 0 ? values[0] : null;\n  }\n\n  /**\n   * Retrieves the names of the headers.\n   *\n   * @returns A list of header names.\n   */\n  keys(): string[] {\n    this.init();\n\n    return Array.from(this.normalizedNames.values());\n  }\n\n  /**\n   * Retrieves a list of values for a given header.\n   *\n   * @param name The header name from which to retrieve values.\n   *\n   * @returns A string of values if the header exists, null otherwise.\n   */\n  getAll(name: string): string[] | null {\n    this.init();\n\n    return this.headers.get(name.toLowerCase()) || null;\n  }\n\n  /**\n   * Appends a new value to the existing set of values for a header\n   * and returns them in a clone of the original instance.\n   *\n   * @param name The header name for which to append the values.\n   * @param value The value to append.\n   *\n   * @returns A clone of the HTTP headers object with the value appended to the given header.\n   */\n\n  append(name: string, value: string | string[]): HttpHeaders {\n    return this.clone({name, value, op: 'a'});\n  }\n  /**\n   * Sets or modifies a value for a given header in a clone of the original instance.\n   * If the header already exists, its value is replaced with the given value\n   * in the returned object.\n   *\n   * @param name The header name.\n   * @param value The value or values to set or override for the given header.\n   *\n   * @returns A clone of the HTTP headers object with the newly set header value.\n   */\n  set(name: string, value: string | string[]): HttpHeaders {\n    return this.clone({name, value, op: 's'});\n  }\n  /**\n   * Deletes values for a given header in a clone of the original instance.\n   *\n   * @param name The header name.\n   * @param value The value or values to delete for the given header.\n   *\n   * @returns A clone of the HTTP headers object with the given value deleted.\n   */\n  delete(name: string, value?: string | string[]): HttpHeaders {\n    return this.clone({name, value, op: 'd'});\n  }\n\n  private maybeSetNormalizedName(name: string, lcName: string): void {\n    if (!this.normalizedNames.has(lcName)) {\n      this.normalizedNames.set(lcName, name);\n    }\n  }\n\n  private init(): void {\n    if (!!this.lazyInit) {\n      if (this.lazyInit instanceof HttpHeaders) {\n        this.copyFrom(this.lazyInit);\n      } else {\n        this.lazyInit();\n      }\n      this.lazyInit = null;\n      if (!!this.lazyUpdate) {\n        this.lazyUpdate.forEach((update) => this.applyUpdate(update));\n        this.lazyUpdate = null;\n      }\n    }\n  }\n\n  private copyFrom(other: HttpHeaders) {\n    other.init();\n    Array.from(other.headers.keys()).forEach((key) => {\n      this.headers.set(key, other.headers.get(key)!);\n      this.normalizedNames.set(key, other.normalizedNames.get(key)!);\n    });\n  }\n\n  private clone(update: Update): HttpHeaders {\n    const clone = new HttpHeaders();\n    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;\n    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n    return clone;\n  }\n\n  private applyUpdate(update: Update): void {\n    const key = update.name.toLowerCase();\n    switch (update.op) {\n      case 'a':\n      case 's':\n        let value = update.value!;\n        if (typeof value === 'string') {\n          value = [value];\n        }\n        if (value.length === 0) {\n          return;\n        }\n        this.maybeSetNormalizedName(update.name, key);\n        const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n        base.push(...value);\n        this.headers.set(key, base);\n        break;\n      case 'd':\n        const toDelete = update.value as string | undefined;\n        if (!toDelete) {\n          this.headers.delete(key);\n          this.normalizedNames.delete(key);\n        } else {\n          let existing = this.headers.get(key);\n          if (!existing) {\n            return;\n          }\n          existing = existing.filter((value) => toDelete.indexOf(value) === -1);\n          if (existing.length === 0) {\n            this.headers.delete(key);\n            this.normalizedNames.delete(key);\n          } else {\n            this.headers.set(key, existing);\n          }\n        }\n        break;\n    }\n  }\n\n  private addHeaderEntry(name: string, value: string) {\n    const key = name.toLowerCase();\n    this.maybeSetNormalizedName(name, key);\n    if (this.headers.has(key)) {\n      this.headers.get(key)!.push(value);\n    } else {\n      this.headers.set(key, [value]);\n    }\n  }\n\n  private setHeaderEntries(name: string, values: any) {\n    const headerValues = (Array.isArray(values) ? values : [values]).map((value) =>\n      value.toString(),\n    );\n    const key = name.toLowerCase();\n    this.headers.set(key, headerValues);\n    this.maybeSetNormalizedName(name, key);\n  }\n\n  /**\n   * @internal\n   */\n  forEach(fn: (name: string, values: string[]) => void) {\n    this.init();\n    Array.from(this.normalizedNames.keys()).forEach((key) =>\n      fn(this.normalizedNames.get(key)!, this.headers.get(key)!),\n    );\n  }\n}\n\n/**\n * Verifies that the headers object has the right shape: the values\n * must be either strings, numbers or arrays. Throws an error if an invalid\n * header value is present.\n */\nfunction assertValidHeaders(\n  headers: Record<string, unknown> | Headers,\n): asserts headers is Record<string, string | string[] | number | number[]> {\n  for (const [key, value] of Object.entries(headers)) {\n    if (!(typeof value === 'string' || typeof value === 'number') && !Array.isArray(value)) {\n      throw new Error(\n        `Unexpected value of the \\`${key}\\` header provided. ` +\n          `Expecting either a string, a number or an array, but got: \\`${value}\\`.`,\n      );\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * A codec for encoding and decoding parameters in URLs.\n *\n * Used by `HttpParams`.\n *\n * @publicApi\n **/\nexport interface HttpParameterCodec {\n  encodeKey(key: string): string;\n  encodeValue(value: string): string;\n\n  decodeKey(key: string): string;\n  decodeValue(value: string): string;\n}\n\n/**\n * Provides encoding and decoding of URL parameter and query-string values.\n *\n * Serializes and parses URL parameter keys and values to encode and decode them.\n * If you pass URL query parameters without encoding,\n * the query parameters can be misinterpreted at the receiving end.\n *\n *\n * @publicApi\n */\nexport class HttpUrlEncodingCodec implements HttpParameterCodec {\n  /**\n   * Encodes a key name for a URL parameter or query-string.\n   * @param key The key name.\n   * @returns The encoded key name.\n   */\n  encodeKey(key: string): string {\n    return standardEncoding(key);\n  }\n\n  /**\n   * Encodes the value of a URL parameter or query-string.\n   * @param value The value.\n   * @returns The encoded value.\n   */\n  encodeValue(value: string): string {\n    return standardEncoding(value);\n  }\n\n  /**\n   * Decodes an encoded URL parameter or query-string key.\n   * @param key The encoded key name.\n   * @returns The decoded key name.\n   */\n  decodeKey(key: string): string {\n    return decodeURIComponent(key);\n  }\n\n  /**\n   * Decodes an encoded URL parameter or query-string value.\n   * @param value The encoded value.\n   * @returns The decoded value.\n   */\n  decodeValue(value: string) {\n    return decodeURIComponent(value);\n  }\n}\n\nfunction paramParser(rawParams: string, codec: HttpParameterCodec): Map<string, string[]> {\n  const map = new Map<string, string[]>();\n  if (rawParams.length > 0) {\n    // The `window.location.search` can be used while creating an instance of the `HttpParams` class\n    // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`\n    // may start with the `?` char, so we strip it if it's present.\n    const params: string[] = rawParams.replace(/^\\?/, '').split('&');\n    params.forEach((param: string) => {\n      const eqIdx = param.indexOf('=');\n      const [key, val]: string[] =\n        eqIdx == -1\n          ? [codec.decodeKey(param), '']\n          : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const list = map.get(key) || [];\n      list.push(val);\n      map.set(key, list);\n    });\n  }\n  return map;\n}\n\n/**\n * Encode input string with standard encodeURIComponent and then un-encode specific characters.\n */\nconst STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nconst STANDARD_ENCODING_REPLACEMENTS: {[x: string]: string} = {\n  '40': '@',\n  '3A': ':',\n  '24': '$',\n  '2C': ',',\n  '3B': ';',\n  '3D': '=',\n  '3F': '?',\n  '2F': '/',\n};\n\nfunction standardEncoding(v: string): string {\n  return encodeURIComponent(v).replace(\n    STANDARD_ENCODING_REGEX,\n    (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s,\n  );\n}\n\nfunction valueToString(value: string | number | boolean): string {\n  return `${value}`;\n}\n\ninterface Update {\n  param: string;\n  value?: string | number | boolean;\n  op: 'a' | 'd' | 's';\n}\n\n/**\n * Options used to construct an `HttpParams` instance.\n *\n * @publicApi\n */\nexport interface HttpParamsOptions {\n  /**\n   * String representation of the HTTP parameters in URL-query-string format.\n   * Mutually exclusive with `fromObject`.\n   */\n  fromString?: string;\n\n  /** Object map of the HTTP parameters. Mutually exclusive with `fromString`. */\n  fromObject?: {\n    [param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;\n  };\n\n  /** Encoding codec used to parse and serialize the parameters. */\n  encoder?: HttpParameterCodec;\n}\n\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable; all mutation operations return a new instance.\n *\n * @publicApi\n */\nexport class HttpParams {\n  private map: Map<string, string[]> | null;\n  private encoder: HttpParameterCodec;\n  private updates: Update[] | null = null;\n  private cloneFrom: HttpParams | null = null;\n\n  constructor(options: HttpParamsOptions = {} as HttpParamsOptions) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    if (options.fromString) {\n      if (options.fromObject) {\n        throw new RuntimeError(\n          RuntimeErrorCode.CANNOT_SPECIFY_BOTH_FROM_STRING_AND_FROM_OBJECT,\n          ngDevMode && 'Cannot specify both fromString and fromObject.',\n        );\n      }\n      this.map = paramParser(options.fromString, this.encoder);\n    } else if (!!options.fromObject) {\n      this.map = new Map<string, string[]>();\n      Object.keys(options.fromObject).forEach((key) => {\n        const value = (options.fromObject as any)[key];\n        // convert the values to strings\n        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n        this.map!.set(key, values);\n      });\n    } else {\n      this.map = null;\n    }\n  }\n\n  /**\n   * Reports whether the body includes one or more values for a given parameter.\n   * @param param The parameter name.\n   * @returns True if the parameter has one or more values,\n   * false if it has no value or is not present.\n   */\n  has(param: string): boolean {\n    this.init();\n    return this.map!.has(param);\n  }\n\n  /**\n   * Retrieves the first value for a parameter.\n   * @param param The parameter name.\n   * @returns The first value of the given parameter,\n   * or `null` if the parameter is not present.\n   */\n  get(param: string): string | null {\n    this.init();\n    const res = this.map!.get(param);\n    return !!res ? res[0] : null;\n  }\n\n  /**\n   * Retrieves all values for a  parameter.\n   * @param param The parameter name.\n   * @returns All values in a string array,\n   * or `null` if the parameter not present.\n   */\n  getAll(param: string): string[] | null {\n    this.init();\n    return this.map!.get(param) || null;\n  }\n\n  /**\n   * Retrieves all the parameters for this body.\n   * @returns The parameter names in a string array.\n   */\n  keys(): string[] {\n    this.init();\n    return Array.from(this.map!.keys());\n  }\n\n  /**\n   * Appends a new value to existing values for a parameter.\n   * @param param The parameter name.\n   * @param value The new value to add.\n   * @return A new body with the appended value.\n   */\n  append(param: string, value: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 'a'});\n  }\n\n  /**\n   * Constructs a new body with appended values for the given parameter name.\n   * @param params parameters and values\n   * @return A new body with the new value.\n   */\n  appendAll(params: {\n    [param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;\n  }): HttpParams {\n    const updates: Update[] = [];\n    Object.keys(params).forEach((param) => {\n      const value = params[param];\n      if (Array.isArray(value)) {\n        value.forEach((_value) => {\n          updates.push({param, value: _value, op: 'a'});\n        });\n      } else {\n        updates.push({param, value: value as string | number | boolean, op: 'a'});\n      }\n    });\n    return this.clone(updates);\n  }\n\n  /**\n   * Replaces the value for a parameter.\n   * @param param The parameter name.\n   * @param value The new value.\n   * @return A new body with the new value.\n   */\n  set(param: string, value: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 's'});\n  }\n\n  /**\n   * Removes a given value or all values from a parameter.\n   * @param param The parameter name.\n   * @param value The value to remove, if provided.\n   * @return A new body with the given value removed, or with all values\n   * removed if no value is specified.\n   */\n  delete(param: string, value?: string | number | boolean): HttpParams {\n    return this.clone({param, value, op: 'd'});\n  }\n\n  /**\n   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n   * separated by `&`s.\n   */\n  toString(): string {\n    this.init();\n    return (\n      this.keys()\n        .map((key) => {\n          const eKey = this.encoder.encodeKey(key);\n          // `a: ['1']` produces `'a=1'`\n          // `b: []` produces `''`\n          // `c: ['1', '2']` produces `'c=1&c=2'`\n          return this.map!.get(key)!\n            .map((value) => eKey + '=' + this.encoder.encodeValue(value))\n            .join('&');\n        })\n        // filter out empty values because `b: []` produces `''`\n        // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't\n        .filter((param) => param !== '')\n        .join('&')\n    );\n  }\n\n  private clone(update: Update | Update[]): HttpParams {\n    const clone = new HttpParams({encoder: this.encoder} as HttpParamsOptions);\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat(update);\n    return clone;\n  }\n\n  private init() {\n    if (this.map === null) {\n      this.map = new Map<string, string[]>();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach((key) => this.map!.set(key, this.cloneFrom!.map!.get(key)!));\n      this.updates!.forEach((update) => {\n        switch (update.op) {\n          case 'a':\n          case 's':\n            const base = (update.op === 'a' ? this.map!.get(update.param) : undefined) || [];\n            base.push(valueToString(update.value!));\n            this.map!.set(update.param, base);\n            break;\n          case 'd':\n            if (update.value !== undefined) {\n              let base = this.map!.get(update.param) || [];\n              const idx = base.indexOf(valueToString(update.value));\n              if (idx !== -1) {\n                base.splice(idx, 1);\n              }\n              if (base.length > 0) {\n                this.map!.set(update.param, base);\n              } else {\n                this.map!.delete(update.param);\n              }\n            } else {\n              this.map!.delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = this.updates = null;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A token used to manipulate and access values stored in `HttpContext`.\n *\n * @publicApi\n */\nexport class HttpContextToken<T> {\n  constructor(public readonly defaultValue: () => T) {}\n}\n\n/**\n * Http context stores arbitrary user defined values and ensures type safety without\n * actually knowing the types. It is backed by a `Map` and guarantees that keys do not clash.\n *\n * This context is mutable and is shared between cloned requests unless explicitly specified.\n *\n * @usageNotes\n *\n * ### Usage Example\n *\n * ```ts\n * // inside cache.interceptors.ts\n * export const IS_CACHE_ENABLED = new HttpContextToken<boolean>(() => false);\n *\n * export class CacheInterceptor implements HttpInterceptor {\n *\n *   intercept(req: HttpRequest<any>, delegate: HttpHandler): Observable<HttpEvent<any>> {\n *     if (req.context.get(IS_CACHE_ENABLED) === true) {\n *       return ...;\n *     }\n *     return delegate.handle(req);\n *   }\n * }\n *\n * // inside a service\n *\n * this.httpClient.get('/api/weather', {\n *   context: new HttpContext().set(IS_CACHE_ENABLED, true)\n * }).subscribe(...);\n * ```\n *\n * @publicApi\n */\nexport class HttpContext {\n  private readonly map = new Map<HttpContextToken<unknown>, unknown>();\n\n  /**\n   * Store a value in the context. If a value is already present it will be overwritten.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   * @param value The value to store.\n   *\n   * @returns A reference to itself for easy chaining.\n   */\n  set<T>(token: HttpContextToken<T>, value: T): HttpContext {\n    this.map.set(token, value);\n    return this;\n  }\n\n  /**\n   * Retrieve the value associated with the given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns The stored value or default if one is defined.\n   */\n  get<T>(token: HttpContextToken<T>): T {\n    if (!this.map.has(token)) {\n      this.map.set(token, token.defaultValue());\n    }\n    return this.map.get(token) as T;\n  }\n\n  /**\n   * Delete the value associated with the given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns A reference to itself for easy chaining.\n   */\n  delete(token: HttpContextToken<unknown>): HttpContext {\n    this.map.delete(token);\n    return this;\n  }\n\n  /**\n   * Checks for existence of a given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns True if the token exists, false otherwise.\n   */\n  has(token: HttpContextToken<unknown>): boolean {\n    return this.map.has(token);\n  }\n\n  /**\n   * @returns a list of tokens currently stored in the context.\n   */\n  keys(): IterableIterator<HttpContextToken<unknown>> {\n    return this.map.keys();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HttpContext} from './context';\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\n\n/**\n * Construction interface for `HttpRequest`s.\n *\n * All values are optional and will override default values if provided.\n */\ninterface HttpRequestInit {\n  headers?: HttpHeaders;\n  context?: HttpContext;\n  reportProgress?: boolean;\n  params?: HttpParams;\n  responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n  withCredentials?: boolean;\n  transferCache?: {includeHeaders?: string[]} | boolean;\n}\n\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method: string): boolean {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\n\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n\n/**\n * Safely assert whether the given value is a URLSearchParams instance.\n *\n * In some execution environments URLSearchParams is not defined.\n */\nfunction isUrlSearchParams(value: any): value is URLSearchParams {\n  return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;\n}\n\n/**\n * `Content-Type` is an HTTP header used to indicate the media type\n * (also known as MIME type) of the resource being sent to the client\n * or received from the server.\n */\nexport const CONTENT_TYPE_HEADER = 'Content-Type';\n\n/**\n * The `Accept` header is an HTTP request header that indicates the media types\n * (or content types) the client is willing to receive from the server.\n */\nexport const ACCEPT_HEADER = 'Accept';\n\n/**\n * `X-Request-URL` is a custom HTTP header used in older browser versions,\n * including Firefox (< 32), Chrome (< 37), Safari (< 8), and Internet Explorer,\n * to include the full URL of the request in cross-origin requests.\n */\nexport const X_REQUEST_URL_HEADER = 'X-Request-URL';\n\n/**\n * `text/plain` is a content type used to indicate that the content being\n * sent is plain text with no special formatting or structured data\n * like HTML, XML, or JSON.\n */\nexport const TEXT_CONTENT_TYPE = 'text/plain';\n\n/**\n * `application/json` is a content type used to indicate that the content\n * being sent is in the JSON format.\n */\nexport const JSON_CONTENT_TYPE = 'application/json';\n\n/**\n * `application/json, text/plain, *\\/*` is a content negotiation string often seen in the\n * Accept header of HTTP requests. It indicates the types of content the client is willing\n * to accept from the server, with a preference for `application/json` and `text/plain`,\n * but also accepting any other type (*\\/*).\n */\nexport const ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;\n\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n * @publicApi\n */\nexport class HttpRequest<T> {\n  /**\n   * The request body, or `null` if one isn't set.\n   *\n   * Bodies are not enforced to be immutable, as they can include a reference to any\n   * user-defined data type. However, interceptors should take care to preserve\n   * idempotence by treating them as such.\n   */\n  readonly body: T | null = null;\n\n  /**\n   * Outgoing headers for this request.\n   */\n  readonly headers!: HttpHeaders;\n\n  /**\n   * Shared and mutable context that can be used by interceptors\n   */\n  readonly context!: HttpContext;\n\n  /**\n   * Whether this request should be made in a way that exposes progress events.\n   *\n   * Progress events are expensive (change detection runs on each event) and so\n   * they should only be requested if the consumer intends to monitor them.\n   *\n   * Note: The `FetchBackend` doesn't support progress report on uploads.\n   */\n  readonly reportProgress: boolean = false;\n\n  /**\n   * Whether this request should be sent with outgoing credentials (cookies).\n   */\n  readonly withCredentials: boolean = false;\n\n  /**\n   * The expected response type of the server.\n   *\n   * This is used to parse the response appropriately before returning it to\n   * the requestee.\n   */\n  readonly responseType: 'arraybuffer' | 'blob' | 'json' | 'text' = 'json';\n\n  /**\n   * The outgoing HTTP request method.\n   */\n  readonly method: string;\n\n  /**\n   * Outgoing URL parameters.\n   *\n   * To pass a string representation of HTTP parameters in the URL-query-string format,\n   * the `HttpParamsOptions`' `fromString` may be used. For example:\n   *\n   * ```ts\n   * new HttpParams({fromString: 'angular=awesome'})\n   * ```\n   */\n  readonly params!: HttpParams;\n\n  /**\n   * The outgoing URL with all URL parameters set.\n   */\n  readonly urlWithParams: string;\n\n  /**\n   * The HttpTransferCache option for the request\n   */\n  readonly transferCache?: {includeHeaders?: string[]} | boolean;\n\n  constructor(\n    method: 'GET' | 'HEAD',\n    url: string,\n    init?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      /**\n       * This property accepts either a boolean to enable/disable transferring cache for eligible\n       * requests performed using `HttpClient`, or an object, which allows to configure cache\n       * parameters, such as which headers should be included (no headers are included by default).\n       *\n       * Setting this property will override the options passed to `provideClientHydration()` for this\n       * particular request\n       */\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  );\n  constructor(\n    method: 'DELETE' | 'JSONP' | 'OPTIONS',\n    url: string,\n    init?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n    },\n  );\n  constructor(\n    method: 'POST',\n    url: string,\n    body: T | null,\n    init?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      /**\n       * This property accepts either a boolean to enable/disable transferring cache for eligible\n       * requests performed using `HttpClient`, or an object, which allows to configure cache\n       * parameters, such as which headers should be included (no headers are included by default).\n       *\n       * Setting this property will override the options passed to `provideClientHydration()` for this\n       * particular request\n       */\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  );\n  constructor(\n    method: 'PUT' | 'PATCH',\n    url: string,\n    body: T | null,\n    init?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n    },\n  );\n  constructor(\n    method: string,\n    url: string,\n    body: T | null,\n    init?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      /**\n       * This property accepts either a boolean to enable/disable transferring cache for eligible\n       * requests performed using `HttpClient`, or an object, which allows to configure cache\n       * parameters, such as which headers should be included (no headers are included by default).\n       *\n       * Setting this property will override the options passed to `provideClientHydration()` for this\n       * particular request\n       */\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  );\n  constructor(\n    method: string,\n    readonly url: string,\n    third?:\n      | T\n      | {\n          headers?: HttpHeaders;\n          context?: HttpContext;\n          reportProgress?: boolean;\n          params?: HttpParams;\n          responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n          withCredentials?: boolean;\n          transferCache?: {includeHeaders?: string[]} | boolean;\n        }\n      | null,\n    fourth?: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ) {\n    this.method = method.toUpperCase();\n    // Next, need to figure out which argument holds the HttpRequestInit\n    // options, if any.\n    let options: HttpRequestInit | undefined;\n\n    // Check whether a body argument is expected. The only valid way to omit\n    // the body argument is to use a known no-body method like GET.\n    if (mightHaveBody(this.method) || !!fourth) {\n      // Body is the third argument, options are the fourth.\n      this.body = third !== undefined ? (third as T) : null;\n      options = fourth;\n    } else {\n      // No body required, options are the third argument. The body stays null.\n      options = third as HttpRequestInit;\n    }\n\n    // If options have been passed, interpret them.\n    if (options) {\n      // Normalize reportProgress and withCredentials.\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n\n      // Override default response type of 'json' if one is provided.\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n\n      // Override headers if they're provided.\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n\n      if (!!options.context) {\n        this.context = options.context;\n      }\n\n      if (!!options.params) {\n        this.params = options.params;\n      }\n\n      // We do want to assign transferCache even if it's falsy (false is valid value)\n      this.transferCache = options.transferCache;\n    }\n\n    // If no headers have been passed in, construct a new HttpHeaders instance.\n    this.headers ??= new HttpHeaders();\n\n    // If no context have been passed in, construct a new HttpContext instance.\n    this.context ??= new HttpContext();\n\n    // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      // Encode the parameters to a string in preparation for inclusion in the URL.\n      const params = this.params.toString();\n      if (params.length === 0) {\n        // No parameters, the visible URL is just the URL given at creation time.\n        this.urlWithParams = url;\n      } else {\n        // Does the URL already have query parameters? Look for '?'.\n        const qIdx = url.indexOf('?');\n        // There are 3 cases to handle:\n        // 1) No existing parameters -> append '?' followed by params.\n        // 2) '?' exists and is followed by existing query string ->\n        //    append '&' followed by params.\n        // 3) '?' exists at the end of the url -> append params directly.\n        // This basically amounts to determining the character, if any, with\n        // which to join the URL and parameters.\n        const sep: string = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n\n  /**\n   * Transform the free-form body into a serialized format suitable for\n   * transmission to the server.\n   */\n  serializeBody(): ArrayBuffer | Blob | FormData | URLSearchParams | string | null {\n    // If no body is present, no need to serialize it.\n    if (this.body === null) {\n      return null;\n    }\n    // Check whether the body is already in a serialized form. If so,\n    // it can just be returned directly.\n    if (\n      typeof this.body === 'string' ||\n      isArrayBuffer(this.body) ||\n      isBlob(this.body) ||\n      isFormData(this.body) ||\n      isUrlSearchParams(this.body)\n    ) {\n      return this.body;\n    }\n    // Check whether the body is an instance of HttpUrlEncodedParams.\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    // Check whether the body is an object or array, and serialize with JSON if so.\n    if (\n      typeof this.body === 'object' ||\n      typeof this.body === 'boolean' ||\n      Array.isArray(this.body)\n    ) {\n      return JSON.stringify(this.body);\n    }\n    // Fall back on toString() for everything else.\n    return (this.body as any).toString();\n  }\n\n  /**\n   * Examine the body and attempt to infer an appropriate MIME type\n   * for it.\n   *\n   * If no such type can be inferred, this method will return `null`.\n   */\n  detectContentTypeHeader(): string | null {\n    // An empty body has no content type.\n    if (this.body === null) {\n      return null;\n    }\n    // FormData bodies rely on the browser's content type assignment.\n    if (isFormData(this.body)) {\n      return null;\n    }\n    // Blobs usually have their own content type. If it doesn't, then\n    // no type can be inferred.\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    // Array buffers have unknown contents and thus no type can be inferred.\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    // Technically, strings could be a form of JSON data, but it's safe enough\n    // to assume they're plain strings.\n    if (typeof this.body === 'string') {\n      return TEXT_CONTENT_TYPE;\n    }\n    // `HttpUrlEncodedParams` has its own content-type.\n    if (this.body instanceof HttpParams) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    // Arrays, objects, boolean and numbers will be encoded as JSON.\n    if (\n      typeof this.body === 'object' ||\n      typeof this.body === 'number' ||\n      typeof this.body === 'boolean'\n    ) {\n      return JSON_CONTENT_TYPE;\n    }\n    // No type could be inferred.\n    return null;\n  }\n\n  clone(): HttpRequest<T>;\n  clone(update: {\n    headers?: HttpHeaders;\n    context?: HttpContext;\n    reportProgress?: boolean;\n    params?: HttpParams;\n    responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n    withCredentials?: boolean;\n    transferCache?: {includeHeaders?: string[]} | boolean;\n    body?: T | null;\n    method?: string;\n    url?: string;\n    setHeaders?: {[name: string]: string | string[]};\n    setParams?: {[param: string]: string};\n  }): HttpRequest<T>;\n  clone<V>(update: {\n    headers?: HttpHeaders;\n    context?: HttpContext;\n    reportProgress?: boolean;\n    params?: HttpParams;\n    responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n    withCredentials?: boolean;\n    transferCache?: {includeHeaders?: string[]} | boolean;\n    body?: V | null;\n    method?: string;\n    url?: string;\n    setHeaders?: {[name: string]: string | string[]};\n    setParams?: {[param: string]: string};\n  }): HttpRequest<V>;\n  clone(\n    update: {\n      headers?: HttpHeaders;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      params?: HttpParams;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n      body?: any | null;\n      method?: string;\n      url?: string;\n      setHeaders?: {[name: string]: string | string[]};\n      setParams?: {[param: string]: string};\n    } = {},\n  ): HttpRequest<any> {\n    // For method, url, and responseType, take the current value unless\n    // it is overridden in the update hash.\n    const method = update.method || this.method;\n    const url = update.url || this.url;\n    const responseType = update.responseType || this.responseType;\n\n    // Carefully handle the transferCache to differentiate between\n    // `false` and `undefined` in the update args.\n    const transferCache = update.transferCache ?? this.transferCache;\n\n    // The body is somewhat special - a `null` value in update.body means\n    // whatever current body is present is being overridden with an empty\n    // body, whereas an `undefined` value in update.body implies no\n    // override.\n    const body = update.body !== undefined ? update.body : this.body;\n\n    // Carefully handle the boolean options to differentiate between\n    // `false` and `undefined` in the update args.\n    const withCredentials = update.withCredentials ?? this.withCredentials;\n    const reportProgress = update.reportProgress ?? this.reportProgress;\n\n    // Headers and params may be appended to if `setHeaders` or\n    // `setParams` are used.\n    let headers = update.headers || this.headers;\n    let params = update.params || this.params;\n\n    // Pass on context if needed\n    const context = update.context ?? this.context;\n\n    // Check whether the caller has asked to add headers.\n    if (update.setHeaders !== undefined) {\n      // Set every requested header.\n      headers = Object.keys(update.setHeaders).reduce(\n        (headers, name) => headers.set(name, update.setHeaders![name]),\n        headers,\n      );\n    }\n\n    // Check whether the caller has asked to set params.\n    if (update.setParams) {\n      // Set every requested param.\n      params = Object.keys(update.setParams).reduce(\n        (params, param) => params.set(param, update.setParams![param]),\n        params,\n      );\n    }\n\n    // Finally, construct the new HttpRequest using the pieces from above.\n    return new HttpRequest(method, url, body, {\n      params,\n      headers,\n      context,\n      reportProgress,\n      responseType,\n      withCredentials,\n      transferCache,\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HttpHeaders} from './headers';\n\n/**\n * Type enumeration for the different kinds of `HttpEvent`.\n *\n * @publicApi\n */\nexport enum HttpEventType {\n  /**\n   * The request was sent out over the wire.\n   */\n  Sent,\n\n  /**\n   * An upload progress event was received.\n   *\n   * Note: The `FetchBackend` doesn't support progress report on uploads.\n   */\n  UploadProgress,\n\n  /**\n   * The response status code and headers were received.\n   */\n  ResponseHeader,\n\n  /**\n   * A download progress event was received.\n   */\n  DownloadProgress,\n\n  /**\n   * The full response including the body was received.\n   */\n  Response,\n\n  /**\n   * A custom event from an interceptor or a backend.\n   */\n  User,\n}\n\n/**\n * Base interface for progress events.\n *\n * @publicApi\n */\nexport interface HttpProgressEvent {\n  /**\n   * Progress event type is either upload or download.\n   */\n  type: HttpEventType.DownloadProgress | HttpEventType.UploadProgress;\n\n  /**\n   * Number of bytes uploaded or downloaded.\n   */\n  loaded: number;\n\n  /**\n   * Total number of bytes to upload or download. Depending on the request or\n   * response, this may not be computable and thus may not be present.\n   */\n  total?: number;\n}\n\n/**\n * A download progress event.\n *\n * @publicApi\n */\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.DownloadProgress;\n\n  /**\n   * The partial response body as downloaded so far.\n   *\n   * Only present if the responseType was `text`.\n   */\n  partialText?: string;\n}\n\n/**\n * An upload progress event.\n *\n * Note: The `FetchBackend` doesn't support progress report on uploads.\n *\n * @publicApi\n */\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.UploadProgress;\n}\n\n/**\n * An event indicating that the request was sent to the server. Useful\n * when a request may be retried multiple times, to distinguish between\n * retries on the final event stream.\n *\n * @publicApi\n */\nexport interface HttpSentEvent {\n  type: HttpEventType.Sent;\n}\n\n/**\n * A user-defined event.\n *\n * Grouping all custom events under this type ensures they will be handled\n * and forwarded by all implementations of interceptors.\n *\n * @publicApi\n */\nexport interface HttpUserEvent<T> {\n  type: HttpEventType.User;\n}\n\n/**\n * An error that represents a failed attempt to JSON.parse text coming back\n * from the server.\n *\n * It bundles the Error object with the actual response body that failed to parse.\n *\n *\n */\nexport interface HttpJsonParseError {\n  error: Error;\n  text: string;\n}\n\n/**\n * Union type for all possible events on the response stream.\n *\n * Typed according to the expected type of the response.\n *\n * @publicApi\n */\nexport type HttpEvent<T> =\n  | HttpSentEvent\n  | HttpHeaderResponse\n  | HttpResponse<T>\n  | HttpProgressEvent\n  | HttpUserEvent<T>;\n\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n * @publicApi\n */\nexport abstract class HttpResponseBase {\n  /**\n   * All response headers.\n   */\n  readonly headers: HttpHeaders;\n\n  /**\n   * Response status code.\n   */\n  readonly status: number;\n\n  /**\n   * Textual description of response status code, defaults to OK.\n   *\n   * Do not depend on this.\n   */\n  readonly statusText: string;\n\n  /**\n   * URL of the resource retrieved, or null if not available.\n   */\n  readonly url: string | null;\n\n  /**\n   * Whether the status code falls in the 2xx range.\n   */\n  readonly ok: boolean;\n\n  /**\n   * Type of the response, narrowed to either the full response or the header.\n   */\n  readonly type!: HttpEventType.Response | HttpEventType.ResponseHeader;\n\n  /**\n   * Super-constructor for all responses.\n   *\n   * The single parameter accepted is an initialization hash. Any properties\n   * of the response passed there will override the default values.\n   */\n  constructor(\n    init: {\n      headers?: HttpHeaders;\n      status?: number;\n      statusText?: string;\n      url?: string;\n    },\n    defaultStatus: number = 200,\n    defaultStatusText: string = 'OK',\n  ) {\n    // If the hash has values passed, use them to initialize the response.\n    // Otherwise use the default values.\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== undefined ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n\n    // Cache the ok value to avoid defining a getter.\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n}\n\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n * @publicApi\n */\nexport class HttpHeaderResponse extends HttpResponseBase {\n  /**\n   * Create a new `HttpHeaderResponse` with the given parameters.\n   */\n  constructor(\n    init: {\n      headers?: HttpHeaders;\n      status?: number;\n      statusText?: string;\n      url?: string;\n    } = {},\n  ) {\n    super(init);\n  }\n\n  override readonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\n\n  /**\n   * Copy this `HttpHeaderResponse`, overriding its contents with the\n   * given parameter hash.\n   */\n  clone(\n    update: {headers?: HttpHeaders; status?: number; statusText?: string; url?: string} = {},\n  ): HttpHeaderResponse {\n    // Perform a straightforward initialization of the new HttpHeaderResponse,\n    // overriding the current parameters with new ones if given.\n    return new HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n * @publicApi\n */\nexport class HttpResponse<T> extends HttpResponseBase {\n  /**\n   * The response body, or `null` if one was not returned.\n   */\n  readonly body: T | null;\n\n  /**\n   * Construct a new `HttpResponse`.\n   */\n  constructor(\n    init: {\n      body?: T | null;\n      headers?: HttpHeaders;\n      status?: number;\n      statusText?: string;\n      url?: string;\n    } = {},\n  ) {\n    super(init);\n    this.body = init.body !== undefined ? init.body : null;\n  }\n\n  override readonly type: HttpEventType.Response = HttpEventType.Response;\n\n  clone(): HttpResponse<T>;\n  clone(update: {\n    headers?: HttpHeaders;\n    status?: number;\n    statusText?: string;\n    url?: string;\n  }): HttpResponse<T>;\n  clone<V>(update: {\n    body?: V | null;\n    headers?: HttpHeaders;\n    status?: number;\n    statusText?: string;\n    url?: string;\n  }): HttpResponse<V>;\n  clone(\n    update: {\n      body?: any | null;\n      headers?: HttpHeaders;\n      status?: number;\n      statusText?: string;\n      url?: string;\n    } = {},\n  ): HttpResponse<any> {\n    return new HttpResponse<any>({\n      body: update.body !== undefined ? update.body : this.body,\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n * @publicApi\n */\nexport class HttpErrorResponse extends HttpResponseBase implements Error {\n  readonly name = 'HttpErrorResponse';\n  readonly message: string;\n  readonly error: any | null;\n\n  /**\n   * Errors are never okay, even when the status code is in the 2xx success range.\n   */\n  override readonly ok = false;\n\n  constructor(init: {\n    error?: any;\n    headers?: HttpHeaders;\n    status?: number;\n    statusText?: string;\n    url?: string;\n  }) {\n    // Initialize with a default status of 0 / Unknown Error.\n    super(init, 0, 'Unknown Error');\n\n    // If the response was successful, then this was a parse error. Otherwise, it was\n    // a protocol-level failure of some sort. Either the request failed in transit\n    // or the server returned an unsuccessful status code.\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n    } else {\n      this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${\n        init.statusText\n      }`;\n    }\n    this.error = init.error || null;\n  }\n}\n\n/**\n * We use these constant to prevent pulling the whole HttpStatusCode enum\n * Those are the only ones referenced directly by the framework\n */\nexport const HTTP_STATUS_CODE_OK = 200;\nexport const HTTP_STATUS_CODE_NO_CONTENT = 204;\n\n/**\n * Http status codes.\n * As per https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n * @publicApi\n */\nexport enum HttpStatusCode {\n  Continue = 100,\n  SwitchingProtocols = 101,\n  Processing = 102,\n  EarlyHints = 103,\n\n  Ok = HTTP_STATUS_CODE_OK,\n  Created = 201,\n  Accepted = 202,\n  NonAuthoritativeInformation = 203,\n  NoContent = HTTP_STATUS_CODE_NO_CONTENT,\n  ResetContent = 205,\n  PartialContent = 206,\n  MultiStatus = 207,\n  AlreadyReported = 208,\n  ImUsed = 226,\n\n  MultipleChoices = 300,\n  MovedPermanently = 301,\n  Found = 302,\n  SeeOther = 303,\n  NotModified = 304,\n  UseProxy = 305,\n  Unused = 306,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n\n  BadRequest = 400,\n  Unauthorized = 401,\n  PaymentRequired = 402,\n  Forbidden = 403,\n  NotFound = 404,\n  MethodNotAllowed = 405,\n  NotAcceptable = 406,\n  ProxyAuthenticationRequired = 407,\n  RequestTimeout = 408,\n  Conflict = 409,\n  Gone = 410,\n  LengthRequired = 411,\n  PreconditionFailed = 412,\n  PayloadTooLarge = 413,\n  UriTooLong = 414,\n  UnsupportedMediaType = 415,\n  RangeNotSatisfiable = 416,\n  ExpectationFailed = 417,\n  ImATeapot = 418,\n  MisdirectedRequest = 421,\n  UnprocessableEntity = 422,\n  Locked = 423,\n  FailedDependency = 424,\n  TooEarly = 425,\n  UpgradeRequired = 426,\n  PreconditionRequired = 428,\n  TooManyRequests = 429,\n  RequestHeaderFieldsTooLarge = 431,\n  UnavailableForLegalReasons = 451,\n\n  InternalServerError = 500,\n  NotImplemented = 501,\n  BadGateway = 502,\n  ServiceUnavailable = 503,\n  GatewayTimeout = 504,\n  HttpVersionNotSupported = 505,\n  VariantAlsoNegotiates = 506,\n  InsufficientStorage = 507,\n  LoopDetected = 508,\n  NotExtended = 510,\n  NetworkAuthenticationRequired = 511,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {concatMap, filter, map} from 'rxjs/operators';\n\nimport {HttpHandler} from './backend';\nimport {HttpContext} from './context';\nimport {HttpHeaders} from './headers';\nimport {HttpParams, HttpParamsOptions} from './params';\nimport {HttpRequest} from './request';\nimport {HttpEvent, HttpResponse} from './response';\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. This function clones the object and adds the body.\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n */\nfunction addBody<T>(\n  options: {\n    headers?: HttpHeaders | Record<string, string | string[]>;\n    context?: HttpContext;\n    observe?: 'body' | 'events' | 'response';\n    params?:\n      | HttpParams\n      | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n    reportProgress?: boolean;\n    responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n    withCredentials?: boolean;\n    transferCache?: {includeHeaders?: string[]} | boolean;\n  },\n  body: T | null,\n): any {\n  return {\n    body,\n    headers: options.headers,\n    context: options.context,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n    transferCache: options.transferCache,\n  };\n}\n\n/**\n * Performs HTTP requests.\n * This service is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies based on\n * the signature that is called (mainly the values of `observe` and `responseType`).\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n * @usageNotes\n *\n * ### HTTP Request Example\n *\n * ```ts\n *  // GET heroes whose name contains search term\n * searchHeroes(term: string): observable<Hero[]>{\n *\n *  const params = new HttpParams({fromString: 'name=term'});\n *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});\n * }\n * ```\n *\n * Alternatively, the parameter string can be used without invoking HttpParams\n * by directly joining to the URL.\n * ```ts\n * this.httpClient.request('GET', this.heroesUrl + '?' + 'name=term', {responseType:'json'});\n * ```\n *\n *\n * ### JSONP Example\n * ```ts\n * requestJsonp(url, callback = 'callback') {\n *  return this.httpClient.jsonp(this.heroesURL, callback);\n * }\n * ```\n *\n * ### PATCH Example\n * ```ts\n * // PATCH one of the heroes' name\n * patchHero (id: number, heroName: string): Observable<{}> {\n * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42\n *  return this.httpClient.patch(url, {name: heroName}, httpOptions)\n *    .pipe(catchError(this.handleError('patchHero')));\n * }\n * ```\n *\n * @see [HTTP Guide](guide/http)\n * @see [HTTP Request](api/common/http/HttpRequest)\n *\n * @publicApi\n */\n@Injectable()\nexport class HttpClient {\n  constructor(private handler: HttpHandler) {}\n\n  /**\n   * Sends an `HttpRequest` and returns a stream of `HttpEvent`s.\n   *\n   * @return An `Observable` of the response, with the response body as a stream of `HttpEvent`s.\n   */\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n\n  /**\n   * Constructs a request that interprets the body as an `ArrayBuffer` and returns the response in\n   * an `ArrayBuffer`.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a request that interprets the body as a blob and returns\n   * the response as a blob.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type `Blob`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a request that interprets the body as a text string and\n   * returns a string value.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a request that interprets the body as an `ArrayBuffer` and returns the\n   * the full event stream.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as an array of `HttpEvent`s for\n   * the request.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      observe: 'events';\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a request that interprets the body as a `Blob` and returns\n   * the full event stream.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body of type `Blob`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a request which interprets the body as a text string and returns the full event\n   * stream.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body of type string.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object and returns the full\n   * event stream.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the  request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body of type `Object`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      observe: 'events';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<any>>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object and returns the full\n   * event stream.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body of type `R`.\n   */\n  request<R>(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      observe: 'events';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<R>>;\n\n  /**\n   * Constructs a request which interprets the body as an `ArrayBuffer`\n   * and returns the full `HttpResponse`.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body as an `ArrayBuffer`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a request which interprets the body as a `Blob` and returns the full `HttpResponse`.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of type `Blob`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a request which interprets the body as a text stream and returns the full\n   * `HttpResponse`.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the HTTP response, with the response body of type string.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object and returns the full\n   * `HttpResponse`.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the full `HttpResponse`,\n   * with the response body of type `Object`.\n   */\n  request(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      observe: 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object and returns\n   * the full `HttpResponse` with the response body in the requested type.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return  An `Observable` of the full `HttpResponse`, with the response body of type `R`.\n   */\n  request<R>(\n    method: string,\n    url: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      reportProgress?: boolean;\n      observe: 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<R>>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object and returns the full\n   * `HttpResponse` as a JavaScript object.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of type `Object`.\n   */\n  request(\n    method: string,\n    url: string,\n    options?: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      reportProgress?: boolean;\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a request which interprets the body as a JavaScript object\n   * with the response body of the requested type.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of type `R`.\n   */\n  request<R>(\n    method: string,\n    url: string,\n    options?: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      responseType?: 'json';\n      reportProgress?: boolean;\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<R>;\n\n  /**\n   * Constructs a request where response type and requested observable are not known statically.\n   *\n   * @param method  The HTTP method.\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the requested response, with body of type `any`.\n   */\n  request(\n    method: string,\n    url: string,\n    options?: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      observe?: 'body' | 'events' | 'response';\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<any>;\n\n  /**\n   * Constructs an observable for a generic HTTP request that, when subscribed,\n   * fires the request through the chain of registered interceptors and on to the\n   * server.\n   *\n   * You can pass an `HttpRequest` directly as the only parameter. In this case,\n   * the call returns an observable of the raw `HttpEvent` stream.\n   *\n   * Alternatively you can pass an HTTP method as the first parameter,\n   * a URL string as the second, and an options hash containing the request body as the third.\n   * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the\n   * type of returned observable.\n   *   * The `responseType` value determines how a successful response body is parsed.\n   *   * If `responseType` is the default `json`, you can pass a type interface for the resulting\n   * object as a type parameter to the call.\n   *\n   * The `observe` value determines the return type, according to what you are interested in\n   * observing.\n   *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including\n   * progress events by default.\n   *   * An `observe` value of response returns an observable of `HttpResponse<T>`,\n   * where the `T` parameter depends on the `responseType` and any optionally provided type\n   * parameter.\n   *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.\n   *\n   */\n  request(\n    first: string | HttpRequest<any>,\n    url?: string,\n    options: {\n      body?: any;\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    } = {},\n  ): Observable<any> {\n    let req: HttpRequest<any>;\n    // First, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = first;\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming `GET` unless a method is\n      // provided.\n\n      // Figure out the headers.\n      let headers: HttpHeaders | undefined = undefined;\n      if (options.headers instanceof HttpHeaders) {\n        headers = options.headers;\n      } else {\n        headers = new HttpHeaders(options.headers);\n      }\n\n      // Sort out parameters.\n      let params: HttpParams | undefined = undefined;\n      if (!!options.params) {\n        if (options.params instanceof HttpParams) {\n          params = options.params;\n        } else {\n          params = new HttpParams({fromObject: options.params} as HttpParamsOptions);\n        }\n      }\n\n      // Construct the request.\n      req = new HttpRequest(first, url!, options.body !== undefined ? options.body : null, {\n        headers,\n        context: options.context,\n        params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n        transferCache: options.transferCache,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const events$: Observable<HttpEvent<any>> = of(req).pipe(\n      concatMap((req: HttpRequest<any>) => this.handler.handle(req)),\n    );\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const res$: Observable<HttpResponse<any>> = <Observable<HttpResponse<any>>>(\n      events$.pipe(filter((event: HttpEvent<any>) => event instanceof HttpResponse))\n    );\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return res$.pipe(\n              map((res: HttpResponse<any>) => {\n                // Validate that the body is an ArrayBuffer.\n                if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                  throw new RuntimeError(\n                    RuntimeErrorCode.RESPONSE_IS_NOT_AN_ARRAY_BUFFER,\n                    ngDevMode && 'Response is not an ArrayBuffer.',\n                  );\n                }\n                return res.body;\n              }),\n            );\n          case 'blob':\n            return res$.pipe(\n              map((res: HttpResponse<any>) => {\n                // Validate that the body is a Blob.\n                if (res.body !== null && !(res.body instanceof Blob)) {\n                  throw new RuntimeError(\n                    RuntimeErrorCode.RESPONSE_IS_NOT_A_BLOB,\n                    ngDevMode && 'Response is not a Blob.',\n                  );\n                }\n                return res.body;\n              }),\n            );\n          case 'text':\n            return res$.pipe(\n              map((res: HttpResponse<any>) => {\n                // Validate that the body is a string.\n                if (res.body !== null && typeof res.body !== 'string') {\n                  throw new RuntimeError(\n                    RuntimeErrorCode.RESPONSE_IS_NOT_A_STRING,\n                    ngDevMode && 'Response is not a string.',\n                  );\n                }\n                return res.body;\n              }),\n            );\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return res$.pipe(map((res: HttpResponse<any>) => res.body));\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new RuntimeError(\n          RuntimeErrorCode.UNHANDLED_OBSERVE_TYPE,\n          ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`,\n        );\n    }\n  }\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as an `ArrayBuffer`\n   *  and returns the response as an `ArrayBuffer`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return  An `Observable` of the response body as an `ArrayBuffer`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a `Blob` and returns\n   * the response as a `Blob`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response body as a `Blob`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a text string and returns\n   * a string.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as an `ArrayBuffer`\n   *  and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with response body as an `ArrayBuffer`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a `Blob`\n   *  and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request, with the response body as a\n   * `Blob`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a text string\n   * and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with the response\n   * body of type string.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with response body of\n   * type `Object`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a `DELETE`request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request, with a response\n   * body in the requested type.\n   */\n  delete<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | (string | number | boolean)[]>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as an `ArrayBuffer` and returns\n   *  the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the full `HttpResponse`, with the response body as an `ArrayBuffer`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a `Blob` and returns the full\n   * `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of type `Blob`.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as a text stream and\n   *  returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the full `HttpResponse`, with the response body of type string.\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `DELETE` request the interprets the body as a JavaScript object and returns\n   * the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of type `Object`.\n   *\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with the response body of the requested type.\n   */\n  delete<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n   * Constructs a `DELETE` request that interprets the body as JSON and\n   * returns the response body as an object parsed from JSON.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type `Object`.\n   */\n  delete(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a DELETE request that interprets the body as JSON and returns\n   * the response in a given type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with response body in the requested type.\n   */\n  delete<T>(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      body?: any | null;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `DELETE` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   */\n  delete(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      body?: any | null;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('DELETE', url, options as any);\n  }\n\n  /**\n   * Constructs a `GET` request that interprets the body as an `ArrayBuffer` and returns the\n   * response in an `ArrayBuffer`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a `Blob`\n   * and returns the response as a `Blob`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a text string\n   * and returns the response as a string value.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as an `ArrayBuffer` and returns\n   *  the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with the response\n   * body as an `ArrayBuffer`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a `Blob` and\n   * returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a text string and returns\n   * the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type `Object`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON and returns the full\n   * event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with a response body in the requested type.\n   */\n  get<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as an `ArrayBuffer` and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a `Blob` and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a `Blob`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as a text stream and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body of type string.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the full `HttpResponse`,\n   * with the response body of type `Object`.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the full `HttpResponse` for the request,\n   * with a response body in the requested type.\n   */\n  get<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON and\n   * returns the response body as an object parsed from JSON.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   *\n   * @return An `Observable` of the response body as a JavaScript object.\n   */\n  get(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a `GET` request that interprets the body as JSON and returns\n   * the response body in a given type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse`, with a response body in the requested type.\n   */\n  get<T>(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `GET` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   */\n  get(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('GET', url, options as any);\n  }\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as an `ArrayBuffer` and\n   * returns the response as an `ArrayBuffer`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as a `Blob` and returns\n   * the response as a `Blob`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return  An `Observable` of the response, with the response body as a `Blob`.\n   */\n\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as a text string and returns the response\n   * as a string value.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as an  `ArrayBuffer`\n   *  and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as a `Blob` and\n   * returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as a `Blob`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as a text string\n   * and returns the full event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with the response body of type\n   * string.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as JSON\n   * and returns the full HTTP event stream.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with a response body of\n   * type `Object`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as JSON and\n   * returns the full event stream.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with a response body in the requested type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   */\n  head<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as an `ArrayBuffer`\n   *  and returns the full HTTP response.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as a `Blob` and returns\n   * the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a blob.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as text stream\n   * and returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body of type string.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as JSON and\n   * returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body of type `Object`.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body of the requested type.\n   */\n  head<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n\n   * Constructs a `HEAD` request that interprets the body as JSON and\n   * returns the response body as an object parsed from JSON.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the response, with the response body as an object parsed from JSON.\n   */\n  head(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a `HEAD` request that interprets the body as JSON and returns\n   * the response in a given type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body of the given type.\n   */\n  head<T>(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `HEAD` request to execute on the server. The `HEAD` method returns\n   * meta information about the resource without transferring the\n   * resource itself. See the individual overloads for\n   * details on the return type.\n   */\n  head(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('HEAD', url, options as any);\n  }\n\n  /**\n   * Constructs a `JSONP` request for the given URL and name of the callback parameter.\n   *\n   * @param url The resource URL.\n   * @param callbackParam The callback function name.\n   *\n   * @return An `Observable` of the response object, with response body as an object.\n   */\n  jsonp(url: string, callbackParam: string): Observable<Object>;\n\n  /**\n   * Constructs a `JSONP` request for the given URL and name of the callback parameter.\n   *\n   * @param url The resource URL.\n   * @param callbackParam The callback function name.\n   *\n   * You must install a suitable interceptor, such as one provided by `HttpClientJsonpModule`.\n   * If no such interceptor is reached,\n   * then the `JSONP` request can be rejected by the configured backend.\n   *\n   * @return An `Observable` of the response object, with response body in the requested type.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T>;\n\n  /**\n   * Constructs an `Observable` that, when subscribed, causes a request with the special method\n   * `JSONP` to be dispatched via the interceptor pipeline.\n   * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain\n   * API endpoints that don't support newer,\n   * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.\n   * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the\n   * requests even if the API endpoint is not located on the same domain (origin) as the client-side\n   * application making the request.\n   * The endpoint API must support JSONP callback for JSONP requests to work.\n   * The resource API returns the JSON response wrapped in a callback function.\n   * You can pass the callback function name as one of the query parameters.\n   * Note that JSONP requests can only be used with `GET` requests.\n   *\n   * @param url The resource URL.\n   * @param callbackParam The callback function name.\n   *\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T> {\n    return this.request<any>('JSONP', url, {\n      params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as an\n   * `ArrayBuffer` and returns the response as an `ArrayBuffer`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as a `Blob` and returns\n   * the response as a `Blob`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as a text string and\n   * returns a string value.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body of type string.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as an `ArrayBuffer`\n   *  and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return  An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as a `Blob` and\n   * returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as a `Blob`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as a text string\n   * and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with the response body of type string.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request with the response\n   * body of type `Object`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as JSON and\n   * returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with a response body in the requested type.\n   */\n  options<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as an `ArrayBuffer`\n   *  and returns the full HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as a `Blob`\n   *  and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a `Blob`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as text stream\n   * and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body of type string.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body of type `Object`.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as JSON and\n   * returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body in the requested type.\n   */\n  options<T>(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n\n   * Constructs an `OPTIONS` request that interprets the body as JSON and returns the\n   * response body as an object parsed from JSON.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as an object parsed from JSON.\n   */\n  options(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs an `OPTIONS` request that interprets the body as JSON and returns the\n   * response in a given type.\n   *\n   * @param url The endpoint URL.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse`, with a response body of the given type.\n   */\n  options<T>(\n    url: string,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an `Observable` that, when subscribed, causes the configured\n   * `OPTIONS` request to execute on the server. This method allows the client\n   * to determine the supported HTTP methods and other capabilities of an endpoint,\n   * without implying a resource action. See the individual overloads for\n   * details on the return type.\n   */\n  options(\n    url: string,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('OPTIONS', url, options as any);\n  }\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as an `ArrayBuffer` and returns\n   * the response as an `ArrayBuffer`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a `Blob` and returns the response\n   * as a `Blob`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a text string and\n   * returns the response as a string value.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with a response body of type string.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as an `ArrayBuffer` and\n   *  returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a `Blob`\n   *  and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request, with the\n   * response body as `Blob`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a text string and\n   * returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request, with a\n   * response body of type string.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with a response body of type `Object`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as JSON\n   * and returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of all the `HttpEvent`s for the request,\n   * with a response body in the requested type.\n   */\n  patch<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as an `ArrayBuffer`\n   *  and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a `Blob` and returns the full\n   * `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a `Blob`.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as a text stream and returns the\n   * full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request,\n   * with a response body of type string.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body in the requested type.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body in the given type.\n   */\n  patch<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n\n   * Constructs a `PATCH` request that interprets the body as JSON and\n   * returns the response body as an object parsed from JSON.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as an object parsed from JSON.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a `PATCH` request that interprets the body as JSON\n   * and returns the response in a given type.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to edit.\n   * @param options HTTP options.\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request,\n   * with a response body in the given type.\n   */\n  patch<T>(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `PATCH` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   */\n  patch(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('PATCH', url, addBody(options, body));\n  }\n\n  /**\n   * Constructs a `POST` request that interprets the body as an `ArrayBuffer` and returns\n   * an `ArrayBuffer`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options.\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a `Blob` and returns the\n   * response as a `Blob`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a text string and\n   * returns the response as a string value.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with a response body of type string.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as an `ArrayBuffer` and\n   * returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a `Blob`\n   * and returns the response in an observable of the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with the response body as `Blob`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a text string and returns the full\n   * event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return  An `Observable` of all `HttpEvent`s for the request,\n   * with a response body of type string.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a POST request that interprets the body as JSON and returns the full\n   * event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return  An `Observable` of all `HttpEvent`s for the request,\n   * with a response body of type `Object`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a POST request that interprets the body as JSON and returns the full\n   * event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with a response body in the requested type.\n   */\n  post<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a POST request that interprets the body as an `ArrayBuffer`\n   *  and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request, with the response body as an\n   * `ArrayBuffer`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a `Blob` and returns the full\n   * `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a `Blob`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as a text stream and returns\n   * the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request,\n   * with a response body of type string.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as JSON\n   * and returns the full `HttpResponse`.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request, with a response body of type\n   * `Object`.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as JSON and returns the\n   * full `HttpResponse`.\n   *\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request, with a response body in the\n   * requested type.\n   */\n  post<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as JSON\n   * and returns the response body as an object parsed from JSON.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with the response body as an object parsed from JSON.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a `POST` request that interprets the body as JSON\n   * and returns an observable of the response.\n   *\n   * @param url The endpoint URL.\n   * @param body The content to replace with.\n   * @param options HTTP options\n   *\n   * @return  An `Observable` of the `HttpResponse` for the request, with a response body in the\n   * requested type.\n   */\n  post<T>(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `POST` request to execute on the server. The server responds with the location of\n   * the replaced resource. See the individual overloads for\n   * details on the return type.\n   */\n  post(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n      transferCache?: {includeHeaders?: string[]} | boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('POST', url, addBody(options, body));\n  }\n\n  /**\n   * Constructs a `PUT` request that interprets the body as an `ArrayBuffer` and returns the\n   * response as an `ArrayBuffer`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with the response body as an `ArrayBuffer`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<ArrayBuffer>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a `Blob` and returns\n   * the response as a `Blob`.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with the response body as a `Blob`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<Blob>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a text string and\n   * returns the response as a string value.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response, with a response body of type string.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<string>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as an `ArrayBuffer` and\n   * returns the full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as an `ArrayBuffer`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a `Blob` and returns the full event\n   * stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with the response body as a `Blob`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a text string and returns the full event\n   * stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with a response body\n   * of type string.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<string>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as JSON and returns the full\n   * event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request, with a response body of\n   * type `Object`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<Object>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as JSON and returns the\n   * full event stream.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of all `HttpEvent`s for the request,\n   * with a response body in the requested type.\n   */\n  put<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'events';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpEvent<T>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as an\n   * `ArrayBuffer` and returns an observable of the full HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request, with the response body as an\n   * `ArrayBuffer`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'arraybuffer';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a `Blob` and returns the\n   * full HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with the response body as a `Blob`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'blob';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as a text stream and returns the\n   * full HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request, with a response body of type\n   * string.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType: 'text';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<string>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as JSON and returns the full\n   * HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request, with a response body\n   * of type 'Object`.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<Object>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as an instance of the requested type and\n   * returns the full HTTP response.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the `HttpResponse` for the request,\n   * with a response body in the requested type.\n   */\n  put<T>(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      observe: 'response';\n      context?: HttpContext;\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<HttpResponse<T>>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as JSON\n   * and returns an observable of JavaScript object.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the response as a JavaScript object.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<Object>;\n\n  /**\n   * Constructs a `PUT` request that interprets the body as an instance of the requested type\n   * and returns an observable of the requested type.\n   *\n   * @param url The endpoint URL.\n   * @param body The resources to add/update.\n   * @param options HTTP options\n   *\n   * @return An `Observable` of the requested type.\n   */\n  put<T>(\n    url: string,\n    body: any | null,\n    options?: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'json';\n      withCredentials?: boolean;\n    },\n  ): Observable<T>;\n\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `PUT` request to execute on the server. The `PUT` method replaces an existing resource\n   * with a new set of values.\n   * See the individual overloads for details on the return type.\n   */\n  put(\n    url: string,\n    body: any | null,\n    options: {\n      headers?: HttpHeaders | Record<string, string | string[]>;\n      context?: HttpContext;\n      observe?: 'body' | 'events' | 'response';\n      params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n      reportProgress?: boolean;\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\n      withCredentials?: boolean;\n    } = {},\n  ): Observable<any> {\n    return this.request<any>('PUT', url, addBody(options, body));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable, InjectionToken, NgZone} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {\n  ACCEPT_HEADER,\n  ACCEPT_HEADER_VALUE,\n  CONTENT_TYPE_HEADER,\n  HttpRequest,\n  X_REQUEST_URL_HEADER,\n} from './request';\nimport {\n  HTTP_STATUS_CODE_OK,\n  HttpDownloadProgressEvent,\n  HttpErrorResponse,\n  HttpEvent,\n  HttpEventType,\n  HttpHeaderResponse,\n  HttpResponse,\n} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\n/**\n * Determine an appropriate URL for the response, by checking either\n * response url or the X-Request-URL header.\n */\nfunction getResponseUrl(response: Response): string | null {\n  if (response.url) {\n    return response.url;\n  }\n  // stored as lowercase in the map\n  const xRequestUrl = X_REQUEST_URL_HEADER.toLocaleLowerCase();\n  return response.headers.get(xRequestUrl);\n}\n\n/**\n * An internal injection token to reference `FetchBackend` implementation\n * in a tree-shakable way.\n */\nexport const FETCH_BACKEND = new InjectionToken<FetchBackend>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'FETCH_BACKEND' : '',\n);\n\n/**\n * Uses `fetch` to send requests to a backend server.\n *\n * This `FetchBackend` requires the support of the\n * [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) which is available on all\n * supported browsers and on Node.js v18 or later.\n *\n * @see {@link HttpHandler}\n *\n * @publicApi\n */\n@Injectable()\nexport class FetchBackend implements HttpBackend {\n  // We use an arrow function to always reference the current global implementation of `fetch`.\n  // This is helpful for cases when the global `fetch` implementation is modified by external code,\n  // see https://github.com/angular/angular/issues/57527.\n  private readonly fetchImpl =\n    inject(FetchFactory, {optional: true})?.fetch ?? ((...args) => globalThis.fetch(...args));\n  private readonly ngZone = inject(NgZone);\n\n  handle(request: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return new Observable((observer) => {\n      const aborter = new AbortController();\n      this.doRequest(request, aborter.signal, observer).then(noop, (error) =>\n        observer.error(new HttpErrorResponse({error})),\n      );\n      return () => aborter.abort();\n    });\n  }\n\n  private async doRequest(\n    request: HttpRequest<any>,\n    signal: AbortSignal,\n    observer: Observer<HttpEvent<any>>,\n  ): Promise<void> {\n    const init = this.createRequestInit(request);\n    let response;\n\n    try {\n      // Run fetch outside of Angular zone.\n      // This is due to Node.js fetch implementation (Undici) which uses a number of setTimeouts to check if\n      // the response should eventually timeout which causes extra CD cycles every 500ms\n      const fetchPromise = this.ngZone.runOutsideAngular(() =>\n        this.fetchImpl(request.urlWithParams, {signal, ...init}),\n      );\n\n      // Make sure Zone.js doesn't trigger false-positive unhandled promise\n      // error in case the Promise is rejected synchronously. See function\n      // description for additional information.\n      silenceSuperfluousUnhandledPromiseRejection(fetchPromise);\n\n      // Send the `Sent` event before awaiting the response.\n      observer.next({type: HttpEventType.Sent});\n\n      response = await fetchPromise;\n    } catch (error: any) {\n      observer.error(\n        new HttpErrorResponse({\n          error,\n          status: error.status ?? 0,\n          statusText: error.statusText,\n          url: request.urlWithParams,\n          headers: error.headers,\n        }),\n      );\n      return;\n    }\n\n    const headers = new HttpHeaders(response.headers);\n    const statusText = response.statusText;\n    const url = getResponseUrl(response) ?? request.urlWithParams;\n\n    let status = response.status;\n    let body: string | ArrayBuffer | Blob | object | null = null;\n\n    if (request.reportProgress) {\n      observer.next(new HttpHeaderResponse({headers, status, statusText, url}));\n    }\n\n    if (response.body) {\n      // Read Progress\n      const contentLength = response.headers.get('content-length');\n      const chunks: Uint8Array[] = [];\n      const reader = response.body.getReader();\n      let receivedLength = 0;\n\n      let decoder: TextDecoder;\n      let partialText: string | undefined;\n\n      // We have to check whether the Zone is defined in the global scope because this may be called\n      // when the zone is nooped.\n      const reqZone = typeof Zone !== 'undefined' && Zone.current;\n\n      // Perform response processing outside of Angular zone to\n      // ensure no excessive change detection runs are executed\n      // Here calling the async ReadableStreamDefaultReader.read() is responsible for triggering CD\n      await this.ngZone.runOutsideAngular(async () => {\n        while (true) {\n          const {done, value} = await reader.read();\n\n          if (done) {\n            break;\n          }\n\n          chunks.push(value);\n          receivedLength += value.length;\n\n          if (request.reportProgress) {\n            partialText =\n              request.responseType === 'text'\n                ? (partialText ?? '') +\n                  (decoder ??= new TextDecoder()).decode(value, {stream: true})\n                : undefined;\n\n            const reportProgress = () =>\n              observer.next({\n                type: HttpEventType.DownloadProgress,\n                total: contentLength ? +contentLength : undefined,\n                loaded: receivedLength,\n                partialText,\n              } as HttpDownloadProgressEvent);\n            reqZone ? reqZone.run(reportProgress) : reportProgress();\n          }\n        }\n      });\n\n      // Combine all chunks.\n      const chunksAll = this.concatChunks(chunks, receivedLength);\n      try {\n        const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? '';\n        body = this.parseBody(request, chunksAll, contentType);\n      } catch (error) {\n        // Body loading or parsing failed\n        observer.error(\n          new HttpErrorResponse({\n            error,\n            headers: new HttpHeaders(response.headers),\n            status: response.status,\n            statusText: response.statusText,\n            url: getResponseUrl(response) ?? request.urlWithParams,\n          }),\n        );\n        return;\n      }\n    }\n\n    // Same behavior as the XhrBackend\n    if (status === 0) {\n      status = body ? HTTP_STATUS_CODE_OK : 0;\n    }\n\n    // ok determines whether the response will be transmitted on the event or\n    // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n    // but a successful status code can still result in an error if the user\n    // asked for JSON data and the body cannot be parsed as such.\n    const ok = status >= 200 && status < 300;\n\n    if (ok) {\n      observer.next(\n        new HttpResponse({\n          body,\n          headers,\n          status,\n          statusText,\n          url,\n        }),\n      );\n\n      // The full body has been received and delivered, no further events\n      // are possible. This request is complete.\n      observer.complete();\n    } else {\n      observer.error(\n        new HttpErrorResponse({\n          error: body,\n          headers,\n          status,\n          statusText,\n          url,\n        }),\n      );\n    }\n  }\n\n  private parseBody(\n    request: HttpRequest<any>,\n    binContent: Uint8Array,\n    contentType: string,\n  ): string | ArrayBuffer | Blob | object | null {\n    switch (request.responseType) {\n      case 'json':\n        // stripping the XSSI when present\n        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX, '');\n        return text === '' ? null : (JSON.parse(text) as object);\n      case 'text':\n        return new TextDecoder().decode(binContent);\n      case 'blob':\n        return new Blob([binContent], {type: contentType});\n      case 'arraybuffer':\n        return binContent.buffer;\n    }\n  }\n\n  private createRequestInit(req: HttpRequest<any>): RequestInit {\n    // We could share some of this logic with the XhrBackend\n\n    const headers: Record<string, string> = {};\n    const credentials: RequestCredentials | undefined = req.withCredentials ? 'include' : undefined;\n\n    // Setting all the requested headers.\n    req.headers.forEach((name, values) => (headers[name] = values.join(',')));\n\n    // Add an Accept header if one isn't present already.\n    if (!req.headers.has(ACCEPT_HEADER)) {\n      headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;\n    }\n\n    // Auto-detect the Content-Type header if one isn't present already.\n    if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n      const detectedType = req.detectContentTypeHeader();\n      // Sometimes Content-Type detection fails.\n      if (detectedType !== null) {\n        headers[CONTENT_TYPE_HEADER] = detectedType;\n      }\n    }\n\n    return {\n      body: req.serializeBody(),\n      method: req.method,\n      headers,\n      credentials,\n    };\n  }\n\n  private concatChunks(chunks: Uint8Array[], totalLength: number): Uint8Array {\n    const chunksAll = new Uint8Array(totalLength);\n    let position = 0;\n    for (const chunk of chunks) {\n      chunksAll.set(chunk, position);\n      position += chunk.length;\n    }\n\n    return chunksAll;\n  }\n}\n\n/**\n * Abstract class to provide a mocked implementation of `fetch()`\n */\nexport abstract class FetchFactory {\n  abstract fetch: typeof fetch;\n}\n\nfunction noop(): void {}\n\n/**\n * Zone.js treats a rejected promise that has not yet been awaited\n * as an unhandled error. This function adds a noop `.then` to make\n * sure that Zone.js doesn't throw an error if the Promise is rejected\n * synchronously.\n */\nfunction silenceSuperfluousUnhandledPromiseRejection(promise: Promise<unknown>) {\n  promise.then(noop, noop);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {isPlatformServer} from '../../index';\nimport {\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  PLATFORM_ID,\n  runInInjectionContext,\n  ɵConsole as Console,\n  ɵformatRuntimeError as formatRuntimeError,\n  ɵPendingTasksInternal as PendingTasks,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {finalize} from 'rxjs/operators';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {RuntimeErrorCode} from './errors';\nimport {FetchBackend} from './fetch';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\n/**\n * Intercepts and handles an `HttpRequest` or `HttpResponse`.\n *\n * Most interceptors transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n * An interceptor may transform the\n * response event stream as well, by applying additional RxJS operators on the stream\n * returned by `next.handle()`.\n *\n * More rarely, an interceptor may handle the request entirely,\n * and compose a new event stream instead of invoking `next.handle()`. This is an\n * acceptable behavior, but keep in mind that further interceptors will be skipped entirely.\n *\n * It is also rare but valid for an interceptor to return multiple responses on the\n * event stream for a single request.\n *\n * @publicApi\n *\n * @see [HTTP Guide](guide/http/interceptors)\n * @see {@link HttpInterceptorFn}\n *\n * @usageNotes\n *\n * To use the same instance of `HttpInterceptors` for the entire app, import the `HttpClientModule`\n * only in your `AppModule`, and add the interceptors to the root application injector.\n * If you import `HttpClientModule` multiple times across different modules (for example, in lazy\n * loading modules), each import creates a new copy of the `HttpClientModule`, which overwrites the\n * interceptors provided in the root module.\n */\nexport interface HttpInterceptor {\n  /**\n   * Identifies and handles a given HTTP request.\n   * @param req The outgoing request object to handle.\n   * @param next The next interceptor in the chain, or the backend\n   * if no interceptors remain in the chain.\n   * @returns An observable of the event stream.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n\n/**\n * Represents the next interceptor in an interceptor chain, or the real backend if there are no\n * further interceptors.\n *\n * Most interceptors will delegate to this function, and either modify the outgoing request or the\n * response when it arrives. Within the scope of the current request, however, this function may be\n * called any number of times, for any number of downstream requests. Such downstream requests need\n * not be to the same URL or even the same origin as the current request. It is also valid to not\n * call the downstream handler at all, and process the current request entirely within the\n * interceptor.\n *\n * This function should only be called within the scope of the request that's currently being\n * intercepted. Once that request is complete, this downstream handler function should not be\n * called.\n *\n * @publicApi\n *\n * @see [HTTP Guide](guide/http/interceptors)\n */\nexport type HttpHandlerFn = (req: HttpRequest<unknown>) => Observable<HttpEvent<unknown>>;\n\n/**\n * An interceptor for HTTP requests made via `HttpClient`.\n *\n * `HttpInterceptorFn`s are middleware functions which `HttpClient` calls when a request is made.\n * These functions have the opportunity to modify the outgoing request or any response that comes\n * back, as well as block, redirect, or otherwise change the request or response semantics.\n *\n * An `HttpHandlerFn` representing the next interceptor (or the backend which will make a real HTTP\n * request) is provided. Most interceptors will delegate to this function, but that is not required\n * (see `HttpHandlerFn` for more details).\n *\n * `HttpInterceptorFn`s are executed in an [injection context](guide/di/dependency-injection-context).\n * They have access to `inject()` via the `EnvironmentInjector` from which they were configured.\n *\n * @see [HTTP Guide](guide/http/interceptors)\n * @see {@link withInterceptors}\n *\n * @usageNotes\n * Here is a noop interceptor that passes the request through without modifying it:\n * ```ts\n * export const noopInterceptor: HttpInterceptorFn = (req: HttpRequest<unknown>, next:\n * HttpHandlerFn) => {\n *   return next(modifiedReq);\n * };\n * ```\n *\n * If you want to alter a request, clone it first and modify the clone before passing it to the\n * `next()` handler function.\n *\n * Here is a basic interceptor that adds a bearer token to the headers\n * ```ts\n * export const authenticationInterceptor: HttpInterceptorFn = (req: HttpRequest<unknown>, next:\n * HttpHandlerFn) => {\n *    const userToken = 'MY_TOKEN'; const modifiedReq = req.clone({\n *      headers: req.headers.set('Authorization', `Bearer ${userToken}`),\n *    });\n *\n *    return next(modifiedReq);\n * };\n * ```\n */\nexport type HttpInterceptorFn = (\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n) => Observable<HttpEvent<unknown>>;\n\n/**\n * Function which invokes an HTTP interceptor chain.\n *\n * Each interceptor in the interceptor chain is turned into a `ChainedInterceptorFn` which closes\n * over the rest of the chain (represented by another `ChainedInterceptorFn`). The last such\n * function in the chain will instead delegate to the `finalHandlerFn`, which is passed down when\n * the chain is invoked.\n *\n * This pattern allows for a chain of many interceptors to be composed and wrapped in a single\n * `HttpInterceptorFn`, which is a useful abstraction for including different kinds of interceptors\n * (e.g. legacy class-based interceptors) in the same chain.\n */\ntype ChainedInterceptorFn<RequestT> = (\n  req: HttpRequest<RequestT>,\n  finalHandlerFn: HttpHandlerFn,\n) => Observable<HttpEvent<RequestT>>;\n\nfunction interceptorChainEndFn(\n  req: HttpRequest<any>,\n  finalHandlerFn: HttpHandlerFn,\n): Observable<HttpEvent<any>> {\n  return finalHandlerFn(req);\n}\n\n/**\n * Constructs a `ChainedInterceptorFn` which adapts a legacy `HttpInterceptor` to the\n * `ChainedInterceptorFn` interface.\n */\nfunction adaptLegacyInterceptorToChain(\n  chainTailFn: ChainedInterceptorFn<any>,\n  interceptor: HttpInterceptor,\n): ChainedInterceptorFn<any> {\n  return (initialRequest, finalHandlerFn) =>\n    interceptor.intercept(initialRequest, {\n      handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn),\n    });\n}\n\n/**\n * Constructs a `ChainedInterceptorFn` which wraps and invokes a functional interceptor in the given\n * injector.\n */\nfunction chainedInterceptorFn(\n  chainTailFn: ChainedInterceptorFn<unknown>,\n  interceptorFn: HttpInterceptorFn,\n  injector: EnvironmentInjector,\n): ChainedInterceptorFn<unknown> {\n  return (initialRequest, finalHandlerFn) =>\n    runInInjectionContext(injector, () =>\n      interceptorFn(initialRequest, (downstreamRequest) =>\n        chainTailFn(downstreamRequest, finalHandlerFn),\n      ),\n    );\n}\n\n/**\n * A multi-provider token that represents the array of registered\n * `HttpInterceptor` objects.\n *\n * @publicApi\n */\nexport const HTTP_INTERCEPTORS = new InjectionToken<readonly HttpInterceptor[]>(\n  ngDevMode ? 'HTTP_INTERCEPTORS' : '',\n);\n\n/**\n * A multi-provided token of `HttpInterceptorFn`s.\n */\nexport const HTTP_INTERCEPTOR_FNS = new InjectionToken<readonly HttpInterceptorFn[]>(\n  ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '',\n);\n\n/**\n * A multi-provided token of `HttpInterceptorFn`s that are only set in root.\n */\nexport const HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken<readonly HttpInterceptorFn[]>(\n  ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '',\n);\n\n// TODO(atscott): We need a larger discussion about stability and what should contribute to stability.\n// Should the whole interceptor chain contribute to stability or just the backend request #55075?\n// Should HttpClient contribute to stability automatically at all?\nexport const REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken<boolean>(\n  ngDevMode ? 'REQUESTS_CONTRIBUTE_TO_STABILITY' : '',\n  {providedIn: 'root', factory: () => true},\n);\n\n/**\n * Creates an `HttpInterceptorFn` which lazily initializes an interceptor chain from the legacy\n * class-based interceptors and runs the request through it.\n */\nexport function legacyInterceptorFnFactory(): HttpInterceptorFn {\n  let chain: ChainedInterceptorFn<any> | null = null;\n\n  return (req, handler) => {\n    if (chain === null) {\n      const interceptors = inject(HTTP_INTERCEPTORS, {optional: true}) ?? [];\n      // Note: interceptors are wrapped right-to-left so that final execution order is\n      // left-to-right. That is, if `interceptors` is the array `[a, b, c]`, we want to\n      // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n      // out.\n      chain = interceptors.reduceRight(\n        adaptLegacyInterceptorToChain,\n        interceptorChainEndFn as ChainedInterceptorFn<any>,\n      );\n    }\n\n    const pendingTasks = inject(PendingTasks);\n    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    if (contributeToStability) {\n      const taskId = pendingTasks.add();\n      return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));\n    } else {\n      return chain(req, handler);\n    }\n  };\n}\n\nlet fetchBackendWarningDisplayed = false;\n\n/** Internal function to reset the flag in tests */\nexport function resetFetchBackendWarningFlag() {\n  fetchBackendWarningDisplayed = false;\n}\n\n@Injectable()\nexport class HttpInterceptorHandler extends HttpHandler {\n  private chain: ChainedInterceptorFn<unknown> | null = null;\n  private readonly pendingTasks = inject(PendingTasks);\n  private readonly contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n\n  constructor(\n    private backend: HttpBackend,\n    private injector: EnvironmentInjector,\n  ) {\n    super();\n\n    // We strongly recommend using fetch backend for HTTP calls when SSR is used\n    // for an application. The logic below checks if that's the case and produces\n    // a warning otherwise.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !fetchBackendWarningDisplayed) {\n      const isServer = isPlatformServer(injector.get(PLATFORM_ID));\n\n      // This flag is necessary because provideHttpClientTesting() overrides the backend\n      // even if `withFetch()` is used within the test. When the testing HTTP backend is provided,\n      // no HTTP calls are actually performed during the test, so producing a warning would be\n      // misleading.\n      const isTestingBackend = (this.backend as any).isTestingBackend;\n\n      if (isServer && !(this.backend instanceof FetchBackend) && !isTestingBackend) {\n        fetchBackendWarningDisplayed = true;\n        injector\n          .get(Console)\n          .warn(\n            formatRuntimeError(\n              RuntimeErrorCode.NOT_USING_FETCH_BACKEND_IN_SSR,\n              'Angular detected that `HttpClient` is not configured ' +\n                \"to use `fetch` APIs. It's strongly recommended to \" +\n                'enable `fetch` for applications that use Server-Side Rendering ' +\n                'for better performance and compatibility. ' +\n                'To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` ' +\n                'call at the root of the application.',\n            ),\n          );\n      }\n    }\n  }\n\n  override handle(initialRequest: HttpRequest<any>): Observable<HttpEvent<any>> {\n    if (this.chain === null) {\n      const dedupedInterceptorFns = Array.from(\n        new Set([\n          ...this.injector.get(HTTP_INTERCEPTOR_FNS),\n          ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, []),\n        ]),\n      );\n\n      // Note: interceptors are wrapped right-to-left so that final execution order is\n      // left-to-right. That is, if `dedupedInterceptorFns` is the array `[a, b, c]`, we want to\n      // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n      // out.\n      this.chain = dedupedInterceptorFns.reduceRight(\n        (nextSequencedFn, interceptorFn) =>\n          chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector),\n        interceptorChainEndFn as ChainedInterceptorFn<unknown>,\n      );\n    }\n\n    if (this.contributeToStability) {\n      const taskId = this.pendingTasks.add();\n      return this.chain(initialRequest, (downstreamRequest) =>\n        this.backend.handle(downstreamRequest),\n      ).pipe(finalize(() => this.pendingTasks.remove(taskId)));\n    } else {\n      return this.chain(initialRequest, (downstreamRequest) =>\n        this.backend.handle(downstreamRequest),\n      );\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '../../index';\nimport {\n  EnvironmentInjector,\n  Inject,\n  inject,\n  Injectable,\n  runInInjectionContext,\n} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpHandlerFn} from './interceptor';\nimport {HttpRequest} from './request';\nimport {\n  HTTP_STATUS_CODE_OK,\n  HttpErrorResponse,\n  HttpEvent,\n  HttpEventType,\n  HttpResponse,\n} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId: number = 0;\n\n/**\n * When a pending <script> is unsubscribed we'll move it to this document, so it won't be\n * executed.\n */\nlet foreignDocument: Document | undefined;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n\n// Error text given when a request is passed to the JsonpClientBackend that has\n// headers set\nexport const JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';\n\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nexport abstract class JsonpCallbackContext {\n  [key: string]: (data: any) => void;\n}\n\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n */\nexport function jsonpCallbackContext(): Object {\n  if (typeof window === 'object') {\n    return window;\n  }\n  return {};\n}\n\n/**\n * Processes an `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * @see {@link HttpHandler}\n * @see {@link HttpXhrBackend}\n *\n * @publicApi\n */\n@Injectable()\nexport class JsonpClientBackend implements HttpBackend {\n  /**\n   * A resolved promise that can be used to schedule microtasks in the event handlers.\n   */\n  private readonly resolvedPromise = Promise.resolve();\n\n  constructor(\n    private callbackMap: JsonpCallbackContext,\n    @Inject(DOCUMENT) private document: any,\n  ) {}\n\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  private nextCallback(): string {\n    return `ng_jsonp_callback_${nextRequestId++}`;\n  }\n\n  /**\n   * Processes a JSONP request and returns an event stream of the results.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   *\n   */\n  handle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Check the request headers. JSONP doesn't support headers and\n    // cannot set any that were supplied.\n    if (req.headers.keys().length > 0) {\n      throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let body: any | null = null;\n\n      // Whether the response callback has been called.\n      let finished: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const cleanup = () => {\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // Remove the <script> tag if it's still on the page.\n        node.remove();\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const onLoad = (event: Event) => {\n        // We wrap it in an extra Promise, to ensure the microtask\n        // is scheduled after the loaded endpoint has executed any potential microtask itself,\n        // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496\n        this.resolvedPromise.then(() => {\n          // Cleanup the page.\n          cleanup();\n\n          // Check whether the response callback has run.\n          if (!finished) {\n            // It hasn't, something went wrong with the request. Return an error via\n            // the Observable error path. All JSONP errors have status 0.\n            observer.error(\n              new HttpErrorResponse({\n                url,\n                status: 0,\n                statusText: 'JSONP Error',\n                error: new Error(JSONP_ERR_NO_CALLBACK),\n              }),\n            );\n            return;\n          }\n\n          // Success. body either contains the response body or null if none was\n          // returned.\n          observer.next(\n            new HttpResponse({\n              body,\n              status: HTTP_STATUS_CODE_OK,\n              statusText: 'OK',\n              url,\n            }),\n          );\n\n          // Complete the stream, the response is over.\n          observer.complete();\n        });\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const onError: any = (error: Error) => {\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(\n          new HttpErrorResponse({\n            error,\n            status: 0,\n            statusText: 'JSONP Error',\n            url,\n          }),\n        );\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        if (!finished) {\n          this.removeListeners(node);\n        }\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\n\n  private removeListeners(script: HTMLScriptElement): void {\n    // Issue #34818\n    // Changing <script>'s ownerDocument will prevent it from execution.\n    // https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-block\n    foreignDocument ??= (this.document.implementation as DOMImplementation).createHTMLDocument();\n\n    foreignDocument.adoptNode(script);\n  }\n}\n\n/**\n * Identifies requests with the method JSONP and shifts them to the `JsonpClientBackend`.\n */\nexport function jsonpInterceptorFn(\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n): Observable<HttpEvent<unknown>> {\n  if (req.method === 'JSONP') {\n    return inject(JsonpClientBackend).handle(req as HttpRequest<never>);\n  }\n\n  // Fall through for normal HTTP requests.\n  return next(req);\n}\n\n/**\n * Identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n * @see {@link HttpInterceptor}\n *\n * @publicApi\n */\n@Injectable()\nexport class JsonpInterceptor {\n  constructor(private injector: EnvironmentInjector) {}\n\n  /**\n   * Identifies and handles a given JSONP request.\n   * @param initialRequest The outgoing request object to handle.\n   * @param next The next interceptor in the chain, or the backend\n   * if no interceptors remain in the chain.\n   * @returns An observable of the event stream.\n   */\n  intercept(initialRequest: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return runInInjectionContext(this.injector, () =>\n      jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)),\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {XhrFactory} from '../../index';\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, Observer, of} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {HttpBackend} from './backend';\nimport {RuntimeErrorCode} from './errors';\nimport {HttpHeaders} from './headers';\nimport {\n  ACCEPT_HEADER,\n  ACCEPT_HEADER_VALUE,\n  CONTENT_TYPE_HEADER,\n  HttpRequest,\n  X_REQUEST_URL_HEADER,\n} from './request';\nimport {\n  HTTP_STATUS_CODE_NO_CONTENT,\n  HTTP_STATUS_CODE_OK,\n  HttpDownloadProgressEvent,\n  HttpErrorResponse,\n  HttpEvent,\n  HttpEventType,\n  HttpHeaderResponse,\n  HttpJsonParseError,\n  HttpResponse,\n  HttpUploadProgressEvent,\n} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\nconst X_REQUEST_URL_REGEXP = RegExp(`^${X_REQUEST_URL_HEADER}:`, 'm');\n\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr: any): string | null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (X_REQUEST_URL_REGEXP.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader(X_REQUEST_URL_HEADER);\n  }\n  return null;\n}\n\n/**\n * Uses `XMLHttpRequest` to send requests to a backend server.\n * @see {@link HttpHandler}\n * @see {@link JsonpClientBackend}\n *\n * @publicApi\n */\n@Injectable()\nexport class HttpXhrBackend implements HttpBackend {\n  constructor(private xhrFactory: XhrFactory) {}\n\n  /**\n   * Processes a request and returns a stream of response events.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the HttpClientJsonpModule\n    if (req.method === 'JSONP') {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_JSONP_MODULE,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`,\n      );\n    }\n\n    // Check whether this factory has a special function to load an XHR implementation\n    // for various non-browser environments. We currently limit it to only `ServerXhr`\n    // class, which needs to load an XHR implementation.\n    const xhrFactory: XhrFactory & {ɵloadImpl?: () => Promise<void>} = this.xhrFactory;\n    const source: Observable<void | null> = xhrFactory.ɵloadImpl\n      ? from(xhrFactory.ɵloadImpl())\n      : of(null);\n\n    return source.pipe(\n      switchMap(() => {\n        // Everything happens on Observable subscription.\n        return new Observable((observer: Observer<HttpEvent<any>>) => {\n          // Start by setting up the XHR object with request method, URL, and withCredentials\n          // flag.\n          const xhr = xhrFactory.build();\n          xhr.open(req.method, req.urlWithParams);\n          if (req.withCredentials) {\n            xhr.withCredentials = true;\n          }\n\n          // Add all the requested headers.\n          req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n          // Add an Accept header if one isn't present already.\n          if (!req.headers.has(ACCEPT_HEADER)) {\n            xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);\n          }\n\n          // Auto-detect the Content-Type header if one isn't present already.\n          if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n            const detectedType = req.detectContentTypeHeader();\n            // Sometimes Content-Type detection fails.\n            if (detectedType !== null) {\n              xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);\n            }\n          }\n\n          // Set the responseType if one was requested.\n          if (req.responseType) {\n            const responseType = req.responseType.toLowerCase();\n\n            // JSON responses need to be processed as text. This is because if the server\n            // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n            // xhr.response will be null, and xhr.responseText cannot be accessed to\n            // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n            // is parsed by first requesting text and then applying JSON.parse.\n            xhr.responseType = (responseType !== 'json' ? responseType : 'text') as any;\n          }\n\n          // Serialize the request body if one is present. If not, this will be set to null.\n          const reqBody = req.serializeBody();\n\n          // If progress events are enabled, response headers will be delivered\n          // in two events - the HttpHeaderResponse event and the full HttpResponse\n          // event. However, since response headers don't change in between these\n          // two events, it doesn't make sense to parse them twice. So headerResponse\n          // caches the data extracted from the response whenever it's first parsed,\n          // to ensure parsing isn't duplicated.\n          let headerResponse: HttpHeaderResponse | null = null;\n\n          // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n          // state, and memoizes it into headerResponse.\n          const partialFromXhr = (): HttpHeaderResponse => {\n            if (headerResponse !== null) {\n              return headerResponse;\n            }\n\n            const statusText = xhr.statusText || 'OK';\n\n            // Parse headers from XMLHttpRequest - this step is lazy.\n            const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n            // Read the response URL from the XMLHttpResponse instance and fall back on the\n            // request URL.\n            const url = getResponseUrl(xhr) || req.url;\n\n            // Construct the HttpHeaderResponse and memoize it.\n            headerResponse = new HttpHeaderResponse({headers, status: xhr.status, statusText, url});\n            return headerResponse;\n          };\n\n          // Next, a few closures are defined for the various events which XMLHttpRequest can\n          // emit. This allows them to be unregistered as event listeners later.\n\n          // First up is the load event, which represents a response being fully available.\n          const onLoad = () => {\n            // Read response state from the memoized partial data.\n            let {headers, status, statusText, url} = partialFromXhr();\n\n            // The body will be read out if present.\n            let body: any | null = null;\n\n            if (status !== HTTP_STATUS_CODE_NO_CONTENT) {\n              // Use XMLHttpRequest.response if set, responseText otherwise.\n              body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;\n            }\n\n            // Normalize another potential bug (this one comes from CORS).\n            if (status === 0) {\n              status = !!body ? HTTP_STATUS_CODE_OK : 0;\n            }\n\n            // ok determines whether the response will be transmitted on the event or\n            // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n            // but a successful status code can still result in an error if the user\n            // asked for JSON data and the body cannot be parsed as such.\n            let ok = status >= 200 && status < 300;\n\n            // Check whether the body needs to be parsed as JSON (in many cases the browser\n            // will have done that already).\n            if (req.responseType === 'json' && typeof body === 'string') {\n              // Save the original body, before attempting XSSI prefix stripping.\n              const originalBody = body;\n              body = body.replace(XSSI_PREFIX, '');\n              try {\n                // Attempt the parse. If it fails, a parse error should be delivered to the\n                // user.\n                body = body !== '' ? JSON.parse(body) : null;\n              } catch (error) {\n                // Since the JSON.parse failed, it's reasonable to assume this might not have\n                // been a JSON response. Restore the original body (including any XSSI prefix)\n                // to deliver a better error response.\n                body = originalBody;\n\n                // If this was an error request to begin with, leave it as a string, it\n                // probably just isn't JSON. Otherwise, deliver the parsing error to the user.\n                if (ok) {\n                  // Even though the response status was 2xx, this is still an error.\n                  ok = false;\n                  // The parse error contains the text of the body that failed to parse.\n                  body = {error, text: body} as HttpJsonParseError;\n                }\n              }\n            }\n\n            if (ok) {\n              // A successful response is delivered on the event stream.\n              observer.next(\n                new HttpResponse({\n                  body,\n                  headers,\n                  status,\n                  statusText,\n                  url: url || undefined,\n                }),\n              );\n              // The full body has been received and delivered, no further events\n              // are possible. This request is complete.\n              observer.complete();\n            } else {\n              // An unsuccessful request is delivered on the error channel.\n              observer.error(\n                new HttpErrorResponse({\n                  // The error in this case is the response body (error from the server).\n                  error: body,\n                  headers,\n                  status,\n                  statusText,\n                  url: url || undefined,\n                }),\n              );\n            }\n          };\n\n          // The onError callback is called when something goes wrong at the network level.\n          // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n          // transmitted on the error channel.\n          const onError = (error: ProgressEvent) => {\n            const {url} = partialFromXhr();\n            const res = new HttpErrorResponse({\n              error,\n              status: xhr.status || 0,\n              statusText: xhr.statusText || 'Unknown Error',\n              url: url || undefined,\n            });\n            observer.error(res);\n          };\n\n          // The sentHeaders flag tracks whether the HttpResponseHeaders event\n          // has been sent on the stream. This is necessary to track if progress\n          // is enabled since the event will be sent on only the first download\n          // progress event.\n          let sentHeaders = false;\n\n          // The download progress event handler, which is only registered if\n          // progress events are enabled.\n          const onDownProgress = (event: ProgressEvent) => {\n            // Send the HttpResponseHeaders event if it hasn't been sent already.\n            if (!sentHeaders) {\n              observer.next(partialFromXhr());\n              sentHeaders = true;\n            }\n\n            // Start building the download progress event to deliver on the response\n            // event stream.\n            let progressEvent: HttpDownloadProgressEvent = {\n              type: HttpEventType.DownloadProgress,\n              loaded: event.loaded,\n            };\n\n            // Set the total number of bytes in the event if it's available.\n            if (event.lengthComputable) {\n              progressEvent.total = event.total;\n            }\n\n            // If the request was for text content and a partial response is\n            // available on XMLHttpRequest, include it in the progress event\n            // to allow for streaming reads.\n            if (req.responseType === 'text' && !!xhr.responseText) {\n              progressEvent.partialText = xhr.responseText;\n            }\n\n            // Finally, fire the event.\n            observer.next(progressEvent);\n          };\n\n          // The upload progress event handler, which is only registered if\n          // progress events are enabled.\n          const onUpProgress = (event: ProgressEvent) => {\n            // Upload progress events are simpler. Begin building the progress\n            // event.\n            let progress: HttpUploadProgressEvent = {\n              type: HttpEventType.UploadProgress,\n              loaded: event.loaded,\n            };\n\n            // If the total number of bytes being uploaded is available, include\n            // it.\n            if (event.lengthComputable) {\n              progress.total = event.total;\n            }\n\n            // Send the event.\n            observer.next(progress);\n          };\n\n          // By default, register for load and error events.\n          xhr.addEventListener('load', onLoad);\n          xhr.addEventListener('error', onError);\n          xhr.addEventListener('timeout', onError);\n          xhr.addEventListener('abort', onError);\n\n          // Progress events are only enabled if requested.\n          if (req.reportProgress) {\n            // Download progress is always enabled if requested.\n            xhr.addEventListener('progress', onDownProgress);\n\n            // Upload progress depends on whether there is a body to upload.\n            if (reqBody !== null && xhr.upload) {\n              xhr.upload.addEventListener('progress', onUpProgress);\n            }\n          }\n\n          // Fire the request, and notify the event stream that it was fired.\n          xhr.send(reqBody!);\n          observer.next({type: HttpEventType.Sent});\n          // This is the return from the Observable function, which is the\n          // request cancellation handler.\n          return () => {\n            // On a cancellation, remove all registered event listeners.\n            xhr.removeEventListener('error', onError);\n            xhr.removeEventListener('abort', onError);\n            xhr.removeEventListener('load', onLoad);\n            xhr.removeEventListener('timeout', onError);\n\n            if (req.reportProgress) {\n              xhr.removeEventListener('progress', onDownProgress);\n              if (reqBody !== null && xhr.upload) {\n                xhr.upload.removeEventListener('progress', onUpProgress);\n              }\n            }\n\n            // Finally, abort the in-flight request.\n            if (xhr.readyState !== xhr.DONE) {\n              xhr.abort();\n            }\n          };\n        });\n      }),\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ɵparseCookieValue as parseCookieValue} from '../../index';\nimport {\n  EnvironmentInjector,\n  Inject,\n  inject,\n  Injectable,\n  InjectionToken,\n  runInInjectionContext,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {HttpHandler} from './backend';\nimport {HttpHandlerFn, HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const XSRF_ENABLED = new InjectionToken<boolean>(ngDevMode ? 'XSRF_ENABLED' : '');\n\nexport const XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';\nexport const XSRF_COOKIE_NAME = new InjectionToken<string>(ngDevMode ? 'XSRF_COOKIE_NAME' : '', {\n  providedIn: 'root',\n  factory: () => XSRF_DEFAULT_COOKIE_NAME,\n});\n\nexport const XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';\nexport const XSRF_HEADER_NAME = new InjectionToken<string>(ngDevMode ? 'XSRF_HEADER_NAME' : '', {\n  providedIn: 'root',\n  factory: () => XSRF_DEFAULT_HEADER_NAME,\n});\n\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string | null;\n}\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\n@Injectable()\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\n  private lastCookieString: string = '';\n  private lastToken: string | null = null;\n\n  /**\n   * @internal for testing\n   */\n  parseCount: number = 0;\n\n  constructor(\n    @Inject(DOCUMENT) private doc: any,\n    @Inject(XSRF_COOKIE_NAME) private cookieName: string,\n  ) {}\n\n  getToken(): string | null {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      return null;\n    }\n    const cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\n}\n\nexport function xsrfInterceptorFn(\n  req: HttpRequest<unknown>,\n  next: HttpHandlerFn,\n): Observable<HttpEvent<unknown>> {\n  const lcUrl = req.url.toLowerCase();\n  // Skip both non-mutating requests and absolute URLs.\n  // Non-mutating requests don't require a token, and absolute URLs require special handling\n  // anyway as the cookie set\n  // on our origin is not the same as the token expected by another origin.\n  if (\n    !inject(XSRF_ENABLED) ||\n    req.method === 'GET' ||\n    req.method === 'HEAD' ||\n    lcUrl.startsWith('http://') ||\n    lcUrl.startsWith('https://')\n  ) {\n    return next(req);\n  }\n\n  const token = inject(HttpXsrfTokenExtractor).getToken();\n  const headerName = inject(XSRF_HEADER_NAME);\n\n  // Be careful not to overwrite an existing header of the same name.\n  if (token != null && !req.headers.has(headerName)) {\n    req = req.clone({headers: req.headers.set(headerName, token)});\n  }\n  return next(req);\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\n@Injectable()\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n  constructor(private injector: EnvironmentInjector) {}\n\n  intercept(initialRequest: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return runInInjectionContext(this.injector, () =>\n      xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)),\n    );\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentProviders,\n  inject,\n  InjectionToken,\n  makeEnvironmentProviders,\n  Provider,\n} from '@angular/core';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpClient} from './client';\nimport {FETCH_BACKEND, FetchBackend} from './fetch';\nimport {\n  HTTP_INTERCEPTOR_FNS,\n  HttpInterceptorFn,\n  HttpInterceptorHandler,\n  legacyInterceptorFnFactory,\n} from './interceptor';\nimport {\n  jsonpCallbackContext,\n  JsonpCallbackContext,\n  JsonpClientBackend,\n  jsonpInterceptorFn,\n} from './jsonp';\nimport {HttpXhrBackend} from './xhr';\nimport {\n  HttpXsrfCookieExtractor,\n  HttpXsrfTokenExtractor,\n  XSRF_COOKIE_NAME,\n  XSRF_ENABLED,\n  XSRF_HEADER_NAME,\n  xsrfInterceptorFn,\n} from './xsrf';\n\n/**\n * Identifies a particular kind of `HttpFeature`.\n *\n * @publicApi\n */\nexport enum HttpFeatureKind {\n  Interceptors,\n  LegacyInterceptors,\n  CustomXsrfConfiguration,\n  NoXsrfProtection,\n  JsonpSupport,\n  RequestsMadeViaParent,\n  Fetch,\n}\n\n/**\n * A feature for use when configuring `provideHttpClient`.\n *\n * @publicApi\n */\nexport interface HttpFeature<KindT extends HttpFeatureKind> {\n  ɵkind: KindT;\n  ɵproviders: Provider[];\n}\n\nfunction makeHttpFeature<KindT extends HttpFeatureKind>(\n  kind: KindT,\n  providers: Provider[],\n): HttpFeature<KindT> {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers,\n  };\n}\n\n/**\n * Configures Angular's `HttpClient` service to be available for injection.\n *\n * By default, `HttpClient` will be configured for injection with its default options for XSRF\n * protection of outgoing requests. Additional configuration options can be provided by passing\n * feature functions to `provideHttpClient`. For example, HTTP interceptors can be added using the\n * `withInterceptors(...)` feature.\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n * It's strongly recommended to enable\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for applications that use\n * Server-Side Rendering for better performance and compatibility. To enable `fetch`, add\n * `withFetch()` feature to the `provideHttpClient()` call at the root of the application:\n *\n * ```ts\n * provideHttpClient(withFetch());\n * ```\n *\n * </div>\n *\n * @see {@link withInterceptors}\n * @see {@link withInterceptorsFromDi}\n * @see {@link withXsrfConfiguration}\n * @see {@link withNoXsrfProtection}\n * @see {@link withJsonpSupport}\n * @see {@link withRequestsMadeViaParent}\n * @see {@link withFetch}\n */\nexport function provideHttpClient(\n  ...features: HttpFeature<HttpFeatureKind>[]\n): EnvironmentProviders {\n  if (ngDevMode) {\n    const featureKinds = new Set(features.map((f) => f.ɵkind));\n    if (\n      featureKinds.has(HttpFeatureKind.NoXsrfProtection) &&\n      featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)\n    ) {\n      throw new Error(\n        ngDevMode\n          ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.`\n          : '',\n      );\n    }\n  }\n\n  const providers: Provider[] = [\n    HttpClient,\n    HttpXhrBackend,\n    HttpInterceptorHandler,\n    {provide: HttpHandler, useExisting: HttpInterceptorHandler},\n    {\n      provide: HttpBackend,\n      useFactory: () => {\n        return inject(FETCH_BACKEND, {optional: true}) ?? inject(HttpXhrBackend);\n      },\n    },\n    {\n      provide: HTTP_INTERCEPTOR_FNS,\n      useValue: xsrfInterceptorFn,\n      multi: true,\n    },\n    {provide: XSRF_ENABLED, useValue: true},\n    {provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor},\n  ];\n\n  for (const feature of features) {\n    providers.push(...feature.ɵproviders);\n  }\n\n  return makeEnvironmentProviders(providers);\n}\n\n/**\n * Adds one or more functional-style HTTP interceptors to the configuration of the `HttpClient`\n * instance.\n *\n * @see {@link HttpInterceptorFn}\n * @see {@link provideHttpClient}\n * @publicApi\n */\nexport function withInterceptors(\n  interceptorFns: HttpInterceptorFn[],\n): HttpFeature<HttpFeatureKind.Interceptors> {\n  return makeHttpFeature(\n    HttpFeatureKind.Interceptors,\n    interceptorFns.map((interceptorFn) => {\n      return {\n        provide: HTTP_INTERCEPTOR_FNS,\n        useValue: interceptorFn,\n        multi: true,\n      };\n    }),\n  );\n}\n\nconst LEGACY_INTERCEPTOR_FN = new InjectionToken<HttpInterceptorFn>(\n  ngDevMode ? 'LEGACY_INTERCEPTOR_FN' : '',\n);\n\n/**\n * Includes class-based interceptors configured using a multi-provider in the current injector into\n * the configured `HttpClient` instance.\n *\n * Prefer `withInterceptors` and functional interceptors instead, as support for DI-provided\n * interceptors may be phased out in a later release.\n *\n * @see {@link HttpInterceptor}\n * @see {@link HTTP_INTERCEPTORS}\n * @see {@link provideHttpClient}\n */\nexport function withInterceptorsFromDi(): HttpFeature<HttpFeatureKind.LegacyInterceptors> {\n  // Note: the legacy interceptor function is provided here via an intermediate token\n  // (`LEGACY_INTERCEPTOR_FN`), using a pattern which guarantees that if these providers are\n  // included multiple times, all of the multi-provider entries will have the same instance of the\n  // interceptor function. That way, the `HttpINterceptorHandler` will dedup them and legacy\n  // interceptors will not run multiple times.\n  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [\n    {\n      provide: LEGACY_INTERCEPTOR_FN,\n      useFactory: legacyInterceptorFnFactory,\n    },\n    {\n      provide: HTTP_INTERCEPTOR_FNS,\n      useExisting: LEGACY_INTERCEPTOR_FN,\n      multi: true,\n    },\n  ]);\n}\n\n/**\n * Customizes the XSRF protection for the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withNoXsrfProtection` feature.\n *\n * @see {@link provideHttpClient}\n */\nexport function withXsrfConfiguration({\n  cookieName,\n  headerName,\n}: {\n  cookieName?: string;\n  headerName?: string;\n}): HttpFeature<HttpFeatureKind.CustomXsrfConfiguration> {\n  const providers: Provider[] = [];\n  if (cookieName !== undefined) {\n    providers.push({provide: XSRF_COOKIE_NAME, useValue: cookieName});\n  }\n  if (headerName !== undefined) {\n    providers.push({provide: XSRF_HEADER_NAME, useValue: headerName});\n  }\n\n  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);\n}\n\n/**\n * Disables XSRF protection in the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withXsrfConfiguration` feature.\n *\n * @see {@link provideHttpClient}\n */\nexport function withNoXsrfProtection(): HttpFeature<HttpFeatureKind.NoXsrfProtection> {\n  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [\n    {\n      provide: XSRF_ENABLED,\n      useValue: false,\n    },\n  ]);\n}\n\n/**\n * Add JSONP support to the configuration of the current `HttpClient` instance.\n *\n * @see {@link provideHttpClient}\n */\nexport function withJsonpSupport(): HttpFeature<HttpFeatureKind.JsonpSupport> {\n  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [\n    JsonpClientBackend,\n    {provide: JsonpCallbackContext, useFactory: jsonpCallbackContext},\n    {provide: HTTP_INTERCEPTOR_FNS, useValue: jsonpInterceptorFn, multi: true},\n  ]);\n}\n\n/**\n * Configures the current `HttpClient` instance to make requests via the parent injector's\n * `HttpClient` instead of directly.\n *\n * By default, `provideHttpClient` configures `HttpClient` in its injector to be an independent\n * instance. For example, even if `HttpClient` is configured in the parent injector with\n * one or more interceptors, they will not intercept requests made via this instance.\n *\n * With this option enabled, once the request has passed through the current injector's\n * interceptors, it will be delegated to the parent injector's `HttpClient` chain instead of\n * dispatched directly, and interceptors in the parent configuration will be applied to the request.\n *\n * If there are several `HttpClient` instances in the injector hierarchy, it's possible for\n * `withRequestsMadeViaParent` to be used at multiple levels, which will cause the request to\n * \"bubble up\" until either reaching the root level or an `HttpClient` which was not configured with\n * this option.\n *\n * @see {@link provideHttpClient}\n * @publicApi\n */\nexport function withRequestsMadeViaParent(): HttpFeature<HttpFeatureKind.RequestsMadeViaParent> {\n  return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [\n    {\n      provide: HttpBackend,\n      useFactory: () => {\n        const handlerFromParent = inject(HttpHandler, {skipSelf: true, optional: true});\n        if (ngDevMode && handlerFromParent === null) {\n          throw new Error(\n            'withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient',\n          );\n        }\n        return handlerFromParent;\n      },\n    },\n  ]);\n}\n\n/**\n * Configures the current `HttpClient` instance to make requests using the fetch API.\n *\n * Note: The Fetch API doesn't support progress report on uploads.\n *\n * @publicApi\n */\nexport function withFetch(): HttpFeature<HttpFeatureKind.Fetch> {\n  return makeHttpFeature(HttpFeatureKind.Fetch, [\n    FetchBackend,\n    {provide: FETCH_BACKEND, useExisting: FetchBackend},\n    {provide: HttpBackend, useExisting: FetchBackend},\n  ]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {HTTP_INTERCEPTORS} from './interceptor';\nimport {\n  provideHttpClient,\n  withInterceptorsFromDi,\n  withJsonpSupport,\n  withNoXsrfProtection,\n  withXsrfConfiguration,\n} from './provider';\nimport {\n  HttpXsrfCookieExtractor,\n  HttpXsrfInterceptor,\n  HttpXsrfTokenExtractor,\n  XSRF_DEFAULT_COOKIE_NAME,\n  XSRF_DEFAULT_HEADER_NAME,\n  XSRF_ENABLED,\n} from './xsrf';\n\n/**\n * Configures XSRF protection support for outgoing requests.\n *\n * For a server that supports a cookie-based XSRF protection system,\n * use directly to configure XSRF protection with the correct\n * cookie and header names.\n *\n * If no names are supplied, the default cookie name is `XSRF-TOKEN`\n * and the default header name is `X-XSRF-TOKEN`.\n *\n * @publicApi\n * @deprecated Use withXsrfConfiguration({cookieName: 'XSRF-TOKEN', headerName: 'X-XSRF-TOKEN'}) as\n *     providers instead or `withNoXsrfProtection` if you want to disabled XSRF protection.\n */\n@NgModule({\n  providers: [\n    HttpXsrfInterceptor,\n    {provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true},\n    {provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor},\n    withXsrfConfiguration({\n      cookieName: XSRF_DEFAULT_COOKIE_NAME,\n      headerName: XSRF_DEFAULT_HEADER_NAME,\n    }).ɵproviders,\n    {provide: XSRF_ENABLED, useValue: true},\n  ],\n})\nexport class HttpClientXsrfModule {\n  /**\n   * Disable the default XSRF protection.\n   */\n  static disable(): ModuleWithProviders<HttpClientXsrfModule> {\n    return {\n      ngModule: HttpClientXsrfModule,\n      providers: [withNoXsrfProtection().ɵproviders],\n    };\n  }\n\n  /**\n   * Configure XSRF protection.\n   * @param options An object that can specify either or both\n   * cookie name or header name.\n   * - Cookie name default is `XSRF-TOKEN`.\n   * - Header name default is `X-XSRF-TOKEN`.\n   *\n   */\n  static withOptions(\n    options: {\n      cookieName?: string;\n      headerName?: string;\n    } = {},\n  ): ModuleWithProviders<HttpClientXsrfModule> {\n    return {\n      ngModule: HttpClientXsrfModule,\n      providers: withXsrfConfiguration(options).ɵproviders,\n    };\n  }\n}\n\n/**\n * Configures the dependency injector for `HttpClient`\n * with supporting services for XSRF. Automatically imported by `HttpClientModule`.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in DI token `HTTP_INTERCEPTORS`.\n *\n * @publicApi\n * @deprecated use `provideHttpClient(withInterceptorsFromDi())` as providers instead\n */\n@NgModule({\n  /**\n   * Configures the dependency injector where it is imported\n   * with supporting services for HTTP communications.\n   */\n  providers: [provideHttpClient(withInterceptorsFromDi())],\n})\nexport class HttpClientModule {}\n\n/**\n * Configures the dependency injector for `HttpClient`\n * with supporting services for JSONP.\n * Without this module, Jsonp requests reach the backend\n * with method JSONP, where they are rejected.\n *\n * @publicApi\n * @deprecated `withJsonpSupport()` as providers instead\n */\n@NgModule({\n  providers: [withJsonpSupport().ɵproviders],\n})\nexport class HttpClientJsonpModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ɵDomAdapter as DomAdapter, ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\n/**\n * Represents the attributes of an HTML `<meta>` element. The element itself is\n * represented by the internal `HTMLMetaElement`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see {@link Meta}\n *\n * @publicApi\n */\nexport type MetaDefinition = {\n  charset?: string;\n  content?: string;\n  httpEquiv?: string;\n  id?: string;\n  itemprop?: string;\n  name?: string;\n  property?: string;\n  scheme?: string;\n  url?: string;\n} & {\n  // TODO(IgorMinar): this type looks wrong\n  [prop: string]: string;\n};\n\n/**\n * A service for managing HTML `<meta>` tags.\n *\n * Properties of the `MetaDefinition` object match the attributes of the\n * HTML `<meta>` tag. These tags define document metadata that is important for\n * things like configuring a Content Security Policy, defining browser compatibility\n * and security settings, setting HTTP Headers, defining rich content for social sharing,\n * and Search Engine Optimization (SEO).\n *\n * To identify specific `<meta>` tags in a document, use an attribute selection\n * string in the format `\"tag_attribute='value string'\"`.\n * For example, an `attrSelector` value of `\"name='description'\"` matches a tag\n * whose `name` attribute has the value `\"description\"`.\n * Selectors are used with the `querySelector()` Document method,\n * in the format `meta[{attrSelector}]`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)\n *\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Meta {\n  private _dom: DomAdapter;\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    this._dom = getDOM();\n  }\n  /**\n   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * If an existing element is found, it is returned and is not modified in any way.\n   * @param tag The definition of a `<meta>` element to match or create.\n   * @param forceCreation True to create a new element without checking whether one already exists.\n   * @returns The existing element with the same attributes and values if found,\n   * the new element if no match is found, or `null` if the tag parameter is not defined.\n   */\n  addTag(tag: MetaDefinition, forceCreation: boolean = false): HTMLMetaElement | null {\n    if (!tag) return null;\n    return this._getOrCreateElement(tag, forceCreation);\n  }\n\n  /**\n   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * @param tags An array of tag definitions to match or create.\n   * @param forceCreation True to create new elements without checking whether they already exist.\n   * @returns The matching elements if found, or the new elements.\n   */\n  addTags(tags: MetaDefinition[], forceCreation: boolean = false): HTMLMetaElement[] {\n    if (!tags) return [];\n    return tags.reduce((result: HTMLMetaElement[], tag: MetaDefinition) => {\n      if (tag) {\n        result.push(this._getOrCreateElement(tag, forceCreation));\n      }\n      return result;\n    }, []);\n  }\n\n  /**\n   * Retrieves a `<meta>` tag element in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching element, if any.\n   */\n  getTag(attrSelector: string): HTMLMetaElement | null {\n    if (!attrSelector) return null;\n    return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n  }\n\n  /**\n   * Retrieves a set of `<meta>` tag elements in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching elements, if any.\n   */\n  getTags(attrSelector: string): HTMLMetaElement[] {\n    if (!attrSelector) return [];\n    const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n    return list ? [].slice.call(list) : [];\n  }\n\n  /**\n   * Modifies an existing `<meta>` tag element in the current HTML document.\n   * @param tag The tag description with which to replace the existing tag content.\n   * @param selector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n   * replacement tag.\n   * @return The modified element.\n   */\n  updateTag(tag: MetaDefinition, selector?: string): HTMLMetaElement | null {\n    if (!tag) return null;\n    selector = selector || this._parseSelector(tag);\n    const meta: HTMLMetaElement = this.getTag(selector)!;\n    if (meta) {\n      return this._setMetaElementAttributes(tag, meta);\n    }\n    return this._getOrCreateElement(tag, true);\n  }\n\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param attrSelector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   */\n  removeTag(attrSelector: string): void {\n    this.removeTagElement(this.getTag(attrSelector)!);\n  }\n\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param meta The tag definition to match against to identify an existing tag.\n   */\n  removeTagElement(meta: HTMLMetaElement): void {\n    if (meta) {\n      this._dom.remove(meta);\n    }\n  }\n\n  private _getOrCreateElement(\n    meta: MetaDefinition,\n    forceCreation: boolean = false,\n  ): HTMLMetaElement {\n    if (!forceCreation) {\n      const selector: string = this._parseSelector(meta);\n      // It's allowed to have multiple elements with the same name so it's not enough to\n      // just check that element with the same name already present on the page. We also need to\n      // check if element has tag attributes\n      const elem = this.getTags(selector).filter((elem) => this._containsAttributes(meta, elem))[0];\n      if (elem !== undefined) return elem;\n    }\n    const element: HTMLMetaElement = this._dom.createElement('meta') as HTMLMetaElement;\n    this._setMetaElementAttributes(meta, element);\n    const head = this._doc.getElementsByTagName('head')[0];\n    head.appendChild(element);\n    return element;\n  }\n\n  private _setMetaElementAttributes(tag: MetaDefinition, el: HTMLMetaElement): HTMLMetaElement {\n    Object.keys(tag).forEach((prop: string) =>\n      el.setAttribute(this._getMetaKeyMap(prop), tag[prop]),\n    );\n    return el;\n  }\n\n  private _parseSelector(tag: MetaDefinition): string {\n    const attr: string = tag.name ? 'name' : 'property';\n    return `${attr}=\"${tag[attr]}\"`;\n  }\n\n  private _containsAttributes(tag: MetaDefinition, elem: HTMLMetaElement): boolean {\n    return Object.keys(tag).every(\n      (key: string) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key],\n    );\n  }\n\n  private _getMetaKeyMap(prop: string): string {\n    return META_KEYS_MAP[prop] || prop;\n  }\n}\n\n/**\n * Mapping for MetaDefinition properties with their correct meta attribute names\n */\nconst META_KEYS_MAP: {[prop: string]: string} = {\n  httpEquiv: 'http-equiv',\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Title {\n  constructor(@Inject(DOCUMENT) private _doc: any) {}\n  /**\n   * Get the title of the current HTML document.\n   */\n  getTitle(): string {\n    return this._doc.title;\n  }\n\n  /**\n   * Set the title of the current HTML document.\n   * @param newTitle\n   */\n  setTitle(newTitle: string) {\n    this._doc.title = newTitle || '';\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵglobal as global} from '@angular/core';\n\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param value The value to export.\n */\nexport function exportNgVar(name: string, value: any): void {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    // Note: we can't export `ng` when using closure enhanced optimization as:\n    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n    // - we can't declare a closure extern as the namespace `ng` is already used within Google\n    //   for typings for angularJS (via `goog.provide('ng....')`).\n    const ng = (global['ng'] = (global['ng'] as {[key: string]: any} | undefined) || {});\n    ng[name] = value;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ApplicationRef, ComponentRef} from '@angular/core';\n\nexport class ChangeDetectionPerfRecord {\n  constructor(\n    public msPerTick: number,\n    public numTicks: number,\n  ) {}\n}\n\n/**\n * Entry point for all Angular profiling-related debug tools. This object\n * corresponds to the `ng.profiler` in the dev console.\n */\nexport class AngularProfiler {\n  appRef: ApplicationRef;\n\n  constructor(ref: ComponentRef<any>) {\n    this.appRef = ref.injector.get(ApplicationRef);\n  }\n\n  // tslint:disable:no-console\n  /**\n   * Exercises change detection in a loop and then prints the average amount of\n   * time in milliseconds how long a single round of change detection takes for\n   * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n   * of 500 milliseconds.\n   *\n   * Optionally, a user may pass a `config` parameter containing a map of\n   * options. Supported options are:\n   *\n   * `record` (boolean) - causes the profiler to record a CPU profile while\n   * it exercises the change detector. Example:\n   *\n   * ```ts\n   * ng.profiler.timeChangeDetection({record: true})\n   * ```\n   */\n  timeChangeDetection(config: any): ChangeDetectionPerfRecord {\n    const record = config && config['record'];\n    const profileName = 'Change Detection';\n    // Profiler is not available in Android browsers without dev tools opened\n    if (record && 'profile' in console && typeof console.profile === 'function') {\n      console.profile(profileName);\n    }\n    const start = performance.now();\n    let numTicks = 0;\n    while (numTicks < 5 || performance.now() - start < 500) {\n      this.appRef.tick();\n      numTicks++;\n    }\n    const end = performance.now();\n    if (record && 'profileEnd' in console && typeof console.profileEnd === 'function') {\n      console.profileEnd(profileName);\n    }\n    const msPerTick = (end - start) / numTicks;\n    console.log(`ran ${numTicks} change detection cycles`);\n    console.log(`${msPerTick.toFixed(2)} ms per check`);\n\n    return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef} from '@angular/core';\n\nimport {exportNgVar} from '../../dom/util';\n\nimport {AngularProfiler} from './common_tools';\n\nconst PROFILER_GLOBAL_NAME = 'profiler';\n\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * @publicApi\n */\nexport function enableDebugTools<T>(ref: ComponentRef<T>): ComponentRef<T> {\n  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n  return ref;\n}\n\n/**\n * Disables Angular tools.\n *\n * @publicApi\n */\nexport function disableDebugTools(): void {\n  exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {DebugElement, DebugNode, Predicate, Type} from '@angular/core';\n\n/**\n * Predicates for use with {@link DebugElement}'s query functions.\n *\n * @publicApi\n */\nexport class By {\n  /**\n   * Match all nodes.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n   */\n  static all(): Predicate<DebugNode> {\n    return () => true;\n  }\n\n  /**\n   * Match elements by the given CSS selector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n   */\n  static css(selector: string): Predicate<DebugElement> {\n    return (debugElement) => {\n      return debugElement.nativeElement != null\n        ? elementMatches(debugElement.nativeElement, selector)\n        : false;\n    };\n  }\n\n  /**\n   * Match nodes that have the given directive present.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n   */\n  static directive(type: Type<any>): Predicate<DebugNode> {\n    return (debugNode) => debugNode.providerTokens!.indexOf(type) !== -1;\n  }\n}\n\nfunction elementMatches(n: any, selector: string): boolean {\n  if (getDOM().isElementNode(n)) {\n    return (\n      (n.matches && n.matches(selector)) ||\n      (n.msMatchesSelector && n.msMatchesSelector(selector)) ||\n      (n.webkitMatchesSelector && n.webkitMatchesSelector(selector))\n    );\n  }\n\n  return false;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  Inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgModule,\n  Optional,\n  ɵConsole as Console,\n} from '@angular/core';\n\nimport {EVENT_MANAGER_PLUGINS, EventManagerPlugin} from './event_manager';\n\n/**\n * Supported HammerJS recognizer event names.\n */\nconst EVENT_NAMES = {\n  // pan\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  // pinch\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  // press\n  'press': true,\n  'pressup': true,\n  // rotate\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  // swipe\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  // tap\n  'tap': true,\n  'doubletap': true,\n};\n\n/**\n * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.\n * @see {@link HammerGestureConfig}\n *\n * @ngModule HammerModule\n * @publicApi\n */\nexport const HAMMER_GESTURE_CONFIG = new InjectionToken<HammerGestureConfig>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerGestureConfig' : '',\n);\n\n/**\n * Function that loads HammerJS, returning a promise that is resolved once HammerJs is loaded.\n *\n * @publicApi\n */\nexport type HammerLoader = () => Promise<void>;\n\n/**\n * Injection token used to provide a HammerLoader to Angular.\n *\n * @see {@link HammerLoader}\n *\n * @publicApi\n */\nexport const HAMMER_LOADER = new InjectionToken<HammerLoader>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerLoader' : '',\n);\n\nexport interface HammerInstance {\n  on(eventName: string, callback?: Function): void;\n  off(eventName: string, callback?: Function): void;\n  destroy?(): void;\n}\n\n/**\n * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n */\n@Injectable()\nexport class HammerGestureConfig {\n  /**\n   * A set of supported event names for gestures to be used in Angular.\n   * Angular supports all built-in recognizers, as listed in\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  events: string[] = [];\n\n  /**\n   * Maps gesture event names to a set of configuration options\n   * that specify overrides to the default values for specific properties.\n   *\n   * The key is a supported event name to be configured,\n   * and the options object contains a set of properties, with override values\n   * to be applied to the named recognizer event.\n   * For example, to disable recognition of the rotate event, specify\n   *  `{\"rotate\": {\"enable\": false}}`.\n   *\n   * Properties that are not present take the HammerJS default values.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   *\n   */\n  overrides: {[key: string]: Object} = {};\n\n  /**\n   * Properties whose default values can be overridden for a given event.\n   * Different sets of properties apply to different events.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  options?: {\n    cssProps?: any;\n    domEvents?: boolean;\n    enable?: boolean | ((manager: any) => boolean);\n    preset?: any[];\n    touchAction?: string;\n    recognizers?: any[];\n    inputClass?: any;\n    inputTarget?: EventTarget;\n  };\n\n  /**\n   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n   * and attaches it to a given HTML element.\n   * @param element The element that will recognize gestures.\n   * @returns A HammerJS event-manager object.\n   */\n  buildHammer(element: HTMLElement): HammerInstance {\n    const mc = new Hammer!(element, this.options);\n\n    mc.get('pinch').set({enable: true});\n    mc.get('rotate').set({enable: true});\n\n    for (const eventName in this.overrides) {\n      mc.get(eventName).set(this.overrides[eventName]);\n    }\n\n    return mc;\n  }\n}\n\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * @ngModule HammerModule\n */\n@Injectable()\nexport class HammerGesturesPlugin extends EventManagerPlugin {\n  private _loaderPromise: Promise<void> | null = null;\n\n  constructor(\n    @Inject(DOCUMENT) doc: any,\n    @Inject(HAMMER_GESTURE_CONFIG) private _config: HammerGestureConfig,\n    private _injector: Injector,\n    @Optional() @Inject(HAMMER_LOADER) private loader?: HammerLoader | null,\n  ) {\n    super(doc);\n  }\n\n  override supports(eventName: string): boolean {\n    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n      return false;\n    }\n\n    if (!(window as any).Hammer && !this.loader) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Get a `Console` through an injector to tree-shake the\n        // class when it is unused in production.\n        const _console = this._injector.get(Console);\n        _console.warn(\n          `The \"${eventName}\" event cannot be bound because Hammer.JS is not ` +\n            `loaded and no custom loader has been specified.`,\n        );\n      }\n      return false;\n    }\n\n    return true;\n  }\n\n  override addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const zone = this.manager.getZone();\n    eventName = eventName.toLowerCase();\n\n    // If Hammer is not present but a loader is specified, we defer adding the event listener\n    // until Hammer is loaded.\n    if (!(window as any).Hammer && this.loader) {\n      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader!());\n      // This `addEventListener` method returns a function to remove the added listener.\n      // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n      // than remove anything.\n      let cancelRegistration = false;\n      let deregister: Function = () => {\n        cancelRegistration = true;\n      };\n\n      zone.runOutsideAngular(() =>\n        this._loaderPromise!.then(() => {\n          // If Hammer isn't actually loaded when the custom loader resolves, give up.\n          if (!(window as any).Hammer) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              const _console = this._injector.get(Console);\n              _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n            }\n            deregister = () => {};\n            return;\n          }\n\n          if (!cancelRegistration) {\n            // Now that Hammer is loaded and the listener is being loaded for real,\n            // the deregistration function changes from canceling registration to\n            // removal.\n            deregister = this.addEventListener(element, eventName, handler);\n          }\n        }).catch(() => {\n          if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const _console = this._injector.get(Console);\n            _console.warn(\n              `The \"${eventName}\" event cannot be bound because the custom ` +\n                `Hammer.JS loader failed.`,\n            );\n          }\n          deregister = () => {};\n        }),\n      );\n\n      // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n      // can change the behavior of `deregister` once the listener is added. Using a closure in\n      // this way allows us to avoid any additional data structures to track listener removal.\n      return () => {\n        deregister();\n      };\n    }\n\n    return zone.runOutsideAngular(() => {\n      // Creating the manager bind events, must be done outside of angular\n      const mc = this._config.buildHammer(element);\n      const callback = function (eventObj: HammerInput) {\n        zone.runGuarded(function () {\n          handler(eventObj);\n        });\n      };\n      mc.on(eventName, callback);\n      return () => {\n        mc.off(eventName, callback);\n        // destroy mc to prevent memory leak\n        if (typeof mc.destroy === 'function') {\n          mc.destroy();\n        }\n      };\n    });\n  }\n\n  isCustomEvent(eventName: string): boolean {\n    return this._config.events.indexOf(eventName) > -1;\n  }\n}\n\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's `EventManager`.\n *\n * @publicApi\n */\n@NgModule({\n  providers: [\n    {\n      provide: EVENT_MANAGER_PLUGINS,\n      useClass: HammerGesturesPlugin,\n      multi: true,\n      deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]],\n    },\n    {provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig},\n  ],\n})\nexport class HammerModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  forwardRef,\n  Inject,\n  Injectable,\n  Sanitizer,\n  SecurityContext,\n  ɵ_sanitizeHtml as _sanitizeHtml,\n  ɵ_sanitizeUrl as _sanitizeUrl,\n  ɵallowSanitizationBypassAndThrow as allowSanitizationBypassOrThrow,\n  ɵbypassSanitizationTrustHtml as bypassSanitizationTrustHtml,\n  ɵbypassSanitizationTrustResourceUrl as bypassSanitizationTrustResourceUrl,\n  ɵbypassSanitizationTrustScript as bypassSanitizationTrustScript,\n  ɵbypassSanitizationTrustStyle as bypassSanitizationTrustStyle,\n  ɵbypassSanitizationTrustUrl as bypassSanitizationTrustUrl,\n  ɵBypassType as BypassType,\n  ɵRuntimeError as RuntimeError,\n  ɵunwrapSafeValue as unwrapSafeValue,\n  ɵXSS_SECURITY_URL as XSS_SECURITY_URL,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nexport {SecurityContext};\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport interface SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport interface SafeHtml extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport interface SafeStyle extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport interface SafeScript extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport interface SafeUrl extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport interface SafeResourceUrl extends SafeValue {}\n\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useExisting: forwardRef(() => DomSanitizerImpl)})\nexport abstract class DomSanitizer implements Sanitizer {\n  /**\n   * Gets a safe value from either a known safe value or a value with unknown safety.\n   *\n   * If the given value is already a `SafeValue`, this method returns the unwrapped value.\n   * If the security context is HTML and the given value is a plain string, this method\n   * sanitizes the string, removing any potentially unsafe content.\n   * For any other security context, this method throws an error if provided\n   * with a plain string.\n   */\n  abstract sanitize(context: SecurityContext, value: SafeValue | string | null): string | null;\n\n  /**\n   * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML\n   * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will\n   * leave safe HTML intact, so in most situations this method should not be used.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   */\n  abstract bypassSecurityTrustHtml(value: string): SafeHtml;\n\n  /**\n   * Bypass security and trust the given value to be safe style value (CSS).\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   */\n  abstract bypassSecurityTrustStyle(value: string): SafeStyle;\n\n  /**\n   * Bypass security and trust the given value to be safe JavaScript.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   */\n  abstract bypassSecurityTrustScript(value: string): SafeScript;\n\n  /**\n   * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used\n   * in hyperlinks or `<img src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   */\n  abstract bypassSecurityTrustUrl(value: string): SafeUrl;\n\n  /**\n   * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may\n   * be used to load executable code from, like `<script src>`, or `<iframe src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   */\n  abstract bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;\n}\n\n@Injectable({providedIn: 'root'})\nexport class DomSanitizerImpl extends DomSanitizer {\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    super();\n  }\n\n  override sanitize(ctx: SecurityContext, value: SafeValue | string | null): string | null {\n    if (value == null) return null;\n    switch (ctx) {\n      case SecurityContext.NONE:\n        return value as string;\n      case SecurityContext.HTML:\n        if (allowSanitizationBypassOrThrow(value, BypassType.Html)) {\n          return unwrapSafeValue(value);\n        }\n        return _sanitizeHtml(this._doc, String(value)).toString();\n      case SecurityContext.STYLE:\n        if (allowSanitizationBypassOrThrow(value, BypassType.Style)) {\n          return unwrapSafeValue(value);\n        }\n        return value as string;\n      case SecurityContext.SCRIPT:\n        if (allowSanitizationBypassOrThrow(value, BypassType.Script)) {\n          return unwrapSafeValue(value);\n        }\n        throw new RuntimeError(\n          RuntimeErrorCode.SANITIZATION_UNSAFE_SCRIPT,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            'unsafe value used in a script context',\n        );\n      case SecurityContext.URL:\n        if (allowSanitizationBypassOrThrow(value, BypassType.Url)) {\n          return unwrapSafeValue(value);\n        }\n        return _sanitizeUrl(String(value));\n      case SecurityContext.RESOURCE_URL:\n        if (allowSanitizationBypassOrThrow(value, BypassType.ResourceUrl)) {\n          return unwrapSafeValue(value);\n        }\n        throw new RuntimeError(\n          RuntimeErrorCode.SANITIZATION_UNSAFE_RESOURCE_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`,\n        );\n      default:\n        throw new RuntimeError(\n          RuntimeErrorCode.SANITIZATION_UNEXPECTED_CTX,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`,\n        );\n    }\n  }\n\n  override bypassSecurityTrustHtml(value: string): SafeHtml {\n    return bypassSanitizationTrustHtml(value);\n  }\n  override bypassSecurityTrustStyle(value: string): SafeStyle {\n    return bypassSanitizationTrustStyle(value);\n  }\n  override bypassSecurityTrustScript(value: string): SafeScript {\n    return bypassSanitizationTrustScript(value);\n  }\n  override bypassSecurityTrustUrl(value: string): SafeUrl {\n    return bypassSanitizationTrustUrl(value);\n  }\n  override bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl {\n    return bypassSanitizationTrustResourceUrl(value);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HttpTransferCacheOptions, ɵwithHttpTransferCache} from '@angular/common/http';\nimport {\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  makeEnvironmentProviders,\n  NgZone,\n  Provider,\n  ɵConsole as Console,\n  ɵformatRuntimeError as formatRuntimeError,\n  ɵwithDomHydration as withDomHydration,\n  ɵwithEventReplay,\n  ɵwithI18nSupport,\n  ɵZONELESS_ENABLED as ZONELESS_ENABLED,\n  ɵwithIncrementalHydration,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\n\n/**\n * The list of features as an enum to uniquely type each `HydrationFeature`.\n * @see {@link HydrationFeature}\n *\n * @publicApi\n */\nexport enum HydrationFeatureKind {\n  NoHttpTransferCache,\n  HttpTransferCacheOptions,\n  I18nSupport,\n  EventReplay,\n  IncrementalHydration,\n}\n\n/**\n * Helper type to represent a Hydration feature.\n *\n * @publicApi\n */\nexport interface HydrationFeature<FeatureKind extends HydrationFeatureKind> {\n  ɵkind: FeatureKind;\n  ɵproviders: Provider[];\n}\n\n/**\n * Helper function to create an object that represents a Hydration feature.\n */\nfunction hydrationFeature<FeatureKind extends HydrationFeatureKind>(\n  ɵkind: FeatureKind,\n  ɵproviders: Provider[] = [],\n  ɵoptions: unknown = {},\n): HydrationFeature<FeatureKind> {\n  return {ɵkind, ɵproviders};\n}\n\n/**\n * Disables HTTP transfer cache. Effectively causes HTTP requests to be performed twice: once on the\n * server and other one on the browser.\n *\n * @publicApi\n */\nexport function withNoHttpTransferCache(): HydrationFeature<HydrationFeatureKind.NoHttpTransferCache> {\n  // This feature has no providers and acts as a flag that turns off\n  // HTTP transfer cache (which otherwise is turned on by default).\n  return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);\n}\n\n/**\n * The function accepts an object, which allows to configure cache parameters,\n * such as which headers should be included (no headers are included by default),\n * whether POST requests should be cached or a callback function to determine if a\n * particular request should be cached.\n *\n * @publicApi\n */\nexport function withHttpTransferCacheOptions(\n  options: HttpTransferCacheOptions,\n): HydrationFeature<HydrationFeatureKind.HttpTransferCacheOptions> {\n  // This feature has no providers and acts as a flag to pass options to the HTTP transfer cache.\n  return hydrationFeature(\n    HydrationFeatureKind.HttpTransferCacheOptions,\n    ɵwithHttpTransferCache(options),\n  );\n}\n\n/**\n * Enables support for hydrating i18n blocks.\n *\n * @developerPreview\n * @publicApi\n */\nexport function withI18nSupport(): HydrationFeature<HydrationFeatureKind.I18nSupport> {\n  return hydrationFeature(HydrationFeatureKind.I18nSupport, ɵwithI18nSupport());\n}\n\n/**\n * Enables support for replaying user events (e.g. `click`s) that happened on a page\n * before hydration logic has completed. Once an application is hydrated, all captured\n * events are replayed and relevant event listeners are executed.\n *\n * @usageNotes\n *\n * Basic example of how you can enable event replay in your application when\n * `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration(withEventReplay())]\n * });\n * ```\n * @publicApi\n * @see {@link provideClientHydration}\n */\nexport function withEventReplay(): HydrationFeature<HydrationFeatureKind.EventReplay> {\n  return hydrationFeature(HydrationFeatureKind.EventReplay, ɵwithEventReplay());\n}\n\n/**\n * Enables support for incremental hydration using the `hydrate` trigger syntax.\n *\n * @usageNotes\n *\n * Basic example of how you can enable incremental hydration in your application when\n * the `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration(withIncrementalHydration())]\n * });\n * ```\n * @experimental\n * @publicApi\n * @see {@link provideClientHydration}\n */\nexport function withIncrementalHydration(): HydrationFeature<HydrationFeatureKind.IncrementalHydration> {\n  return hydrationFeature(HydrationFeatureKind.IncrementalHydration, ɵwithIncrementalHydration());\n}\n\n/**\n * Returns an `ENVIRONMENT_INITIALIZER` token setup with a function\n * that verifies whether compatible ZoneJS was used in an application\n * and logs a warning in a console if it's not the case.\n */\nfunction provideZoneJsCompatibilityDetector(): Provider[] {\n  return [\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      useValue: () => {\n        const ngZone = inject(NgZone);\n        const isZoneless = inject(ZONELESS_ENABLED);\n        // Checking `ngZone instanceof NgZone` would be insufficient here,\n        // because custom implementations might use NgZone as a base class.\n        if (!isZoneless && ngZone.constructor !== NgZone) {\n          const console = inject(Console);\n          const message = formatRuntimeError(\n            RuntimeErrorCode.UNSUPPORTED_ZONEJS_INSTANCE,\n            'Angular detected that hydration was enabled for an application ' +\n              'that uses a custom or a noop Zone.js implementation. ' +\n              'This is not yet a fully supported configuration.',\n          );\n          console.warn(message);\n        }\n      },\n      multi: true,\n    },\n  ];\n}\n\n/**\n * Sets up providers necessary to enable hydration functionality for the application.\n *\n * By default, the function enables the recommended set of features for the optimal\n * performance for most of the applications. It includes the following features:\n *\n * * Reconciling DOM hydration. Learn more about it [here](guide/hydration).\n * * [`HttpClient`](api/common/http/HttpClient) response caching while running on the server and\n * transferring this cache to the client to avoid extra HTTP requests. Learn more about data caching\n * [here](guide/ssr#caching-data-when-using-httpclient).\n *\n * These functions allow you to disable some of the default features or enable new ones:\n *\n * * {@link withNoHttpTransferCache} to disable HTTP transfer cache\n * * {@link withHttpTransferCacheOptions} to configure some HTTP transfer cache options\n * * {@link withI18nSupport} to enable hydration support for i18n blocks\n * * {@link withEventReplay} to enable support for replaying user events\n *\n * @usageNotes\n *\n * Basic example of how you can enable hydration in your application when\n * `bootstrapApplication` function is used:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideClientHydration()]\n * });\n * ```\n *\n * Alternatively if you are using NgModules, you would add `provideClientHydration`\n * to your root app module's provider list.\n * ```ts\n * @NgModule({\n *   declarations: [RootCmp],\n *   bootstrap: [RootCmp],\n *   providers: [provideClientHydration()],\n * })\n * export class AppModule {}\n * ```\n *\n * @see {@link withNoHttpTransferCache}\n * @see {@link withHttpTransferCacheOptions}\n * @see {@link withI18nSupport}\n * @see {@link withEventReplay}\n *\n * @param features Optional features to configure additional hydration behaviors.\n * @returns A set of providers to enable hydration.\n *\n * @publicApi\n */\nexport function provideClientHydration(\n  ...features: HydrationFeature<HydrationFeatureKind>[]\n): EnvironmentProviders {\n  const providers: Provider[] = [];\n  const featuresKind = new Set<HydrationFeatureKind>();\n\n  for (const {ɵproviders, ɵkind} of features) {\n    featuresKind.add(ɵkind);\n\n    if (ɵproviders.length) {\n      providers.push(ɵproviders);\n    }\n  }\n\n  const hasHttpTransferCacheOptions = featuresKind.has(\n    HydrationFeatureKind.HttpTransferCacheOptions,\n  );\n\n  if (\n    typeof ngDevMode !== 'undefined' &&\n    ngDevMode &&\n    featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) &&\n    hasHttpTransferCacheOptions\n  ) {\n    // TODO: Make this a runtime error\n    throw new Error(\n      'Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.',\n    );\n  }\n\n  return makeEnvironmentProviders([\n    typeof ngDevMode !== 'undefined' && ngDevMode ? provideZoneJsCompatibilityDetector() : [],\n    withDomHydration(),\n    featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions\n      ? []\n      : ɵwithHttpTransferCache({}),\n    providers,\n  ]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('19.2.10');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Route, UrlMatchResult} from './models';\nimport type {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nexport const RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\n\n/**\n * A collection of matrix and query URL parameters.\n * @see {@link convertToParamMap}\n * @see {@link ParamMap}\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string | null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string | null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nexport function defaultUrlMatcher(\n  segments: UrlSegment[],\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n): UrlMatchResult | null {\n  const parts = route.path!.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (\n    route.pathMatch === 'full' &&\n    (segmentGroup.hasChildren() || parts.length < segments.length)\n  ) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵisPromise as isPromise} from '@angular/core';\nimport {from, isObservable, Observable, of} from 'rxjs';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(\n  a: {[key: string | symbol]: any},\n  b: {[key: string | symbol]: any},\n): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string | symbol;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nexport function getDataKeys(obj: Object): Array<string | symbol> {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(a: string | string[], b: string | string[]) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T | null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\nexport function wrapIntoObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, shallowEqual} from './utils/collection';\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see {@link Router#isActive}\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact' | 'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact' | 'ignored';\n}\n\ntype ParamMatchOptions = 'exact' | 'subset' | 'ignored';\n\ntype PathCompareFn = (\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n) => boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n  container: UrlTree,\n  containee: UrlTree,\n  options: IsActiveMatchOptions,\n): boolean {\n  return (\n    pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n    paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n    !(options.fragment === 'exact' && container.fragment !== containee.fragment)\n  );\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return (\n    Object.keys(containee).length <= Object.keys(container).length &&\n    Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]))\n  );\n}\n\nfunction containsSegmentGroup(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  containeePaths: UrlSegment[],\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n      container.children[PRIMARY_OUTLET],\n      containee,\n      next,\n      matrixParams,\n    );\n  }\n}\n\nfunction matrixParamsMatch(\n  containerPaths: UrlSegment[],\n  containeePaths: UrlSegment[],\n  options: ParamMatchOptions,\n) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  constructor(\n    /** The root segment group of the URL tree */\n    public root: UrlSegmentGroup = new UrlSegmentGroup([], {}),\n    /** The query params of the URL */\n    public queryParams: Params = {},\n    /** The fragment of the URL */\n    public fragment: string | null = null,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT,\n          'The root `UrlSegmentGroup` should not contain `segments`. ' +\n            'Instead, these segments belong in the `children` so they can be associated with a named outlet.',\n        );\n      }\n    }\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup | null = null;\n\n  constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    public segments: UrlSegment[],\n    /** The list of children of this group */\n    public children: {[key: string]: UrlSegmentGroup},\n  ) {\n    Object.values(children).forEach((v) => (v.parent = this));\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  _parameterMap?: ParamMap;\n\n  constructor(\n    /** The path part of a URL segment */\n    public path: string,\n\n    /** The matrix parameters associated with a segment */\n    public parameters: {[name: string]: string},\n  ) {}\n\n  get parameterMap(): ParamMap {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n  segment: UrlSegmentGroup,\n  fn: (v: UrlSegmentGroup, k: string) => T[],\n): T[] {\n  let res: T[] = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => new DefaultUrlSerializer()})\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n      typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map((p) => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET]\n      ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n      : '';\n    const children: string[] = [];\n\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.entries(params)\n    .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n    .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] = Object.entries(params)\n    .map(([name, value]) => {\n      return Array.isArray(value)\n        ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n        : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n    .filter((s) => s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str: string): string {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string | null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n        RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Empty path url segment cannot have parameters: '${this.remaining}'.`,\n      );\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n          RuntimeErrorCode.UNPARSABLE_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`,\n        );\n      }\n\n      let outletName: string = undefined!;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] =\n        Object.keys(children).length === 1\n          ? children[PRIMARY_OUTLET]\n          : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`,\n      );\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup) {\n  return rootCandidate.segments.length > 0\n    ? new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate})\n    : rootCandidate;\n}\n\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren: Record<string, UrlSegmentGroup> = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (\n      childOutlet === PRIMARY_OUTLET &&\n      childCandidate.segments.length === 0 &&\n      childCandidate.hasChildren()\n    ) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {last, shallowEqual} from './utils/collection';\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n  relativeTo: ActivatedRouteSnapshot,\n  commands: any[],\n  queryParams: Params | null = null,\n  fragment: string | null = null,\n): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nexport function createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup | undefined;\n\n  function createSegmentGroupFromRouteRecursive(\n    currentRoute: ActivatedRouteSnapshot,\n  ): UrlSegmentGroup {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n  relativeTo: UrlSegmentGroup,\n  commands: any[],\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren\n    ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n    : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(\n  oldRoot: UrlSegmentGroup,\n  oldSegmentGroup: UrlSegmentGroup,\n  newSegmentGroup: UrlSegmentGroup,\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n  current: UrlSegmentGroup,\n  oldSegment: UrlSegmentGroup,\n  newSegment: UrlSegmentGroup,\n): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n    public isAbsolute: boolean,\n    public numberOfDoubleDots: number,\n    public commands: any[],\n  ) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Root segment cannot have matrix parameters',\n      );\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          '{outlets:{}} has to be the last command',\n      );\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: any[]): Navigation {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n    public segmentGroup: UrlSegmentGroup,\n    public processChildren: boolean,\n    public index: number,\n  ) {}\n}\n\nfunction findStartingPositionForTargetGroup(\n  nav: Navigation,\n  root: UrlSegmentGroup,\n  target: UrlSegmentGroup,\n): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n  group: UrlSegmentGroup,\n  index: number,\n  numberOfDoubleDots: number,\n): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DOUBLE_DOTS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\",\n      );\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: unknown[]): {[k: string]: unknown[] | string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n  segmentGroup: UrlSegmentGroup | undefined,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(\n      segmentGroup.segments.slice(m.pathIndex),\n      segmentGroup.children,\n    );\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (\n      Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n      segmentGroup.children[PRIMARY_OUTLET] &&\n      segmentGroup.numberOfChildren === 1 &&\n      segmentGroup.children[PRIMARY_OUTLET].segments.length === 0\n    ) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(\n        segmentGroup.children[PRIMARY_OUTLET],\n        startIndex,\n        commands,\n      );\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n      currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: unknown[] | string}): {\n  [outlet: string]: UrlSegmentGroup;\n} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationBehaviorOptions, Route} from './models';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {UrlTree} from './url_tree';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\nexport const IMPERATIVE_NAVIGATION = 'imperative';\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport enum EventType {\n  NavigationStart,\n  NavigationEnd,\n  NavigationCancel,\n  NavigationError,\n  RoutesRecognized,\n  ResolveStart,\n  ResolveEnd,\n  GuardsCheckStart,\n  GuardsCheckEnd,\n  RouteConfigLoadStart,\n  RouteConfigLoadEnd,\n  ChildActivationStart,\n  ChildActivationEnd,\n  ActivationStart,\n  ActivationEnd,\n  Scroll,\n  NavigationSkipped,\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/routing/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    public id: number,\n    /** The URL that is the destination for this navigation. */\n    public url: string,\n  ) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  readonly type = EventType.NavigationStart;\n\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see {@link NavigationEnd}\n   * @see {@link NavigationCancel}\n   * @see {@link NavigationError}\n   */\n  navigationTrigger?: NavigationTrigger;\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any; navigationId: number} | null;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    navigationTrigger: NavigationTrigger = 'imperative',\n    /** @docsNotRequired */\n    restoredState: {[k: string]: any; navigationId: number} | null = null,\n  ) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  readonly type = EventType.NavigationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport enum NavigationCancellationCode {\n  /**\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\n   */\n  Redirect,\n  /**\n   * A navigation failed because a more recent navigation started.\n   */\n  SupersededByNewNavigation,\n  /**\n   * A navigation failed because one of the resolvers completed without emitting a value.\n   */\n  NoDataFromResolver,\n  /**\n   * A navigation failed because a guard returned `false`.\n   */\n  GuardRejected,\n}\n\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nexport enum NavigationSkippedCode {\n  /**\n   * A navigation was skipped because the navigation URL was the same as the current Router URL.\n   */\n  IgnoredSameUrlNavigation,\n  /**\n   * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n   * the current Router URL and the target of the navigation.\n   *\n   * @see {@link UrlHandlingStrategy}\n   */\n  IgnoredByUrlHandlingStrategy,\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  readonly type = EventType.NavigationCancel;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationCancellationCode,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nexport class NavigationSkipped extends RouterEvent {\n  readonly type = EventType.NavigationSkipped;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\n     * instead for a stable skipped reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was skipped. This code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationSkippedCode,\n  ) {\n    super(id, url);\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  readonly type = EventType.NavigationError;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public error: any,\n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    readonly target?: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  readonly type = EventType.RoutesRecognized;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  readonly type = EventType.GuardsCheckStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  readonly type = EventType.GuardsCheckEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n    /** @docsNotRequired */\n    public shouldActivate: boolean,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  readonly type = EventType.ResolveStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  readonly type = EventType.ResolveEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  readonly type = EventType.RouteConfigLoadStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  readonly type = EventType.RouteConfigLoadEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  readonly type = EventType.ChildActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nexport class ChildActivationEnd {\n  readonly type = EventType.ChildActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationStart {\n  readonly type = EventType.ActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  readonly type = EventType.ActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  readonly type = EventType.Scroll;\n\n  constructor(\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd | NavigationSkipped,\n\n    /** @docsNotRequired */\n    readonly position: [number, number] | null,\n\n    /** @docsNotRequired */\n    readonly anchor: string | null,\n  ) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\nexport class BeforeActivateRoutes {}\nexport class RedirectRequest {\n  constructor(\n    readonly url: UrlTree,\n    readonly navigationBehaviorOptions: NavigationBehaviorOptions | undefined,\n  ) {}\n}\nexport type PrivateRouterEvents = BeforeActivateRoutes | RedirectRequest;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](guide/routing/common-router-tasks#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event =\n  | NavigationStart\n  | NavigationEnd\n  | NavigationCancel\n  | NavigationError\n  | RoutesRecognized\n  | GuardsCheckStart\n  | GuardsCheckEnd\n  | RouteConfigLoadStart\n  | RouteConfigLoadEnd\n  | ChildActivationStart\n  | ChildActivationEnd\n  | ActivationStart\n  | ActivationEnd\n  | Scroll\n  | ResolveStart\n  | ResolveEnd\n  | NavigationSkipped;\n\nexport function stringifyEvent(routerEvent: Event): string {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position\n        ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\n        : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  createEnvironmentInjector,\n  EnvironmentInjector,\n  isStandalone,\n  Type,\n  ɵisNgModule as isNgModule,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Route, Routes} from '../models';\nimport {ActivatedRouteSnapshot} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nexport function getOrCreateRouteInjectorIfNeeded(\n  route: Route,\n  currentInjector: EnvironmentInjector,\n) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(\n      route.providers,\n      currentInjector,\n      `Route: ${route.path}`,\n    );\n  }\n  return route._injector ?? currentInjector;\n}\n\nexport function getLoadedRoutes(route: Route): Route[] | undefined {\n  return route._loadedRoutes;\n}\n\nexport function getLoadedInjector(route: Route): EnvironmentInjector | undefined {\n  return route._loadedInjector;\n}\nexport function getLoadedComponent(route: Route): Type<unknown> | undefined {\n  return route._loadedComponent;\n}\n\nexport function getProvidersInjector(route: Route): EnvironmentInjector | undefined {\n  return route._injector;\n}\n\nexport function validateConfig(\n  config: Routes,\n  parentPath: string = '',\n  requireStandaloneComponents = false,\n): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nexport function assertStandalone(fullPath: string, component: Type<unknown> | undefined) {\n  if (component && isNgModule(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\n        `but it must be used with standalone components. Use 'loadChildren' instead.`,\n    );\n  } else if (component && !isStandalone(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. The component must be standalone.`,\n    );\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string, requireStandaloneComponents: boolean): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `,\n      );\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': Array cannot be specified`,\n      );\n    }\n    if (\n      !route.redirectTo &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren &&\n      route.outlet &&\n      route.outlet !== PRIMARY_OUTLET\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`,\n      );\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`,\n      );\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`,\n      );\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`,\n      );\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`,\n      );\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`,\n      );\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` +\n          `so canActivate will never be executed.`,\n      );\n    }\n    if (route.path && route.matcher) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`,\n      );\n    }\n    if (\n      route.redirectTo === void 0 &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`,\n      );\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`,\n      );\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path cannot start with a slash`,\n      );\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`,\n      );\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nexport function getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nexport function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n  const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nexport function getClosestRouteInjector(\n  snapshot: ActivatedRouteSnapshot | undefined,\n): EnvironmentInjector | null {\n  if (!snapshot) return null;\n\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n\n  return null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, EnvironmentInjector, Injectable} from '@angular/core';\n\nimport type {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\nimport {getClosestRouteInjector} from './utils/config';\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract | null = null;\n  route: ActivatedRoute | null = null;\n  children: ChildrenOutletContexts;\n  attachRef: ComponentRef<any> | null = null;\n  get injector(): EnvironmentInjector {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n\n  constructor(private readonly rootInjector: EnvironmentInjector) {\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** @nodoc */\n  constructor(private rootInjector: EnvironmentInjector) {}\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext | null {\n    return this.contexts.get(childName) || null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) {\n    this._root = root;\n  }\n\n  get root(): T {\n    return this._root.value;\n  }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T | null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map((t) => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T | null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map((c) => c.value);\n    return c.filter((cc) => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] {\n    return findPath(t, this._root).map((s) => s.value);\n  }\n}\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T> | null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(\n    public value: T,\n    public children: TreeNode<T>[],\n  ) {}\n\n  toString(): string {\n    return `TreeNode(${this.value})`;\n  }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends {outlet: string}>(node: TreeNode<T> | null) {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach((child) => (map[child.value.outlet] = child));\n  }\n\n  return map;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './models';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET, RouteTitleKey} from './shared';\nimport {equalSegments, UrlSegment} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n    root: TreeNode<ActivatedRoute>,\n    /** The current snapshot of the router state */\n    public snapshot: RouterStateSnapshot,\n  ) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  override toString(): string {\n    return this.snapshot.toString();\n  }\n}\n\nexport function createEmptyState(rootComponent: Type<any> | null): RouterState {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject<string | null>('');\n  const activated = new ActivatedRoute(\n    emptyUrl,\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    snapshot.root,\n  );\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(rootComponent: Type<any> | null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n    [],\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    null,\n    {},\n  );\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot!: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState!: RouterState;\n  /** @internal */\n  _paramMap?: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap?: Observable<ParamMap>;\n\n  /** An Observable of the resolved route title */\n  readonly title: Observable<string | undefined>;\n\n  /** An observable of the URL segments matched by this route. */\n  public url: Observable<UrlSegment[]>;\n  /** An observable of the matrix parameters scoped to this route. */\n  public params: Observable<Params>;\n  /** An observable of the query parameters shared by all the routes. */\n  public queryParams: Observable<Params>;\n  /** An observable of the URL fragment shared by all the routes. */\n  public fragment: Observable<string | null>;\n  /** An observable of the static and resolved data of this route. */\n  public data: Observable<Data>;\n\n  /** @internal */\n  constructor(\n    /** @internal */\n    public urlSubject: BehaviorSubject<UrlSegment[]>,\n    /** @internal */\n    public paramsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public queryParamsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public fragmentSubject: BehaviorSubject<string | null>,\n    /** @internal */\n    public dataSubject: BehaviorSubject<Data>,\n    /** The outlet name of the route, a constant. */\n    public outlet: string,\n    /** The component of the route, a constant. */\n    public component: Type<any> | null,\n    futureSnapshot: ActivatedRouteSnapshot,\n  ) {\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map((d: Data) => d[RouteTitleKey])) ?? of(undefined);\n    // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route | null {\n    return this._futureSnapshot.routeConfig;\n  }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap(): Observable<ParamMap> {\n    this._paramMap ??= this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    this._queryParamMap ??= this.queryParams.pipe(\n      map((p: Params): ParamMap => convertToParamMap(p)),\n    );\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly' | 'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params;\n  data: Data;\n  resolve: Data;\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nexport function getInherited(\n  route: ActivatedRouteSnapshot,\n  parent: ActivatedRouteSnapshot | null,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n): Inherited {\n  let inherited: Inherited;\n  const {routeConfig} = route;\n  if (\n    parent !== null &&\n    (paramsInheritanceStrategy === 'always' ||\n      // inherit parent data if route is empty path\n      routeConfig?.path === '' ||\n      // inherit parent data if parent was componentless\n      (!parent.component && !parent.routeConfig?.loadComponent))\n  ) {\n    inherited = {\n      params: {...parent.params, ...route.params},\n      data: {...parent.data, ...route.data},\n      resolve: {\n        // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n        // change data because it's not frozen...\n        // This first line could be deleted chose to break/disallow mutating the `data` object in\n        // guards.\n        // Note that data from parents still override this mutated data so anyone relying on this\n        // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n        ...route.data,\n        // Ensure inherited resolved data overrides inherited static data\n        ...parent.data,\n        // static data from the current route overrides any inherited data\n        ...routeConfig?.data,\n        // resolved data from current route overrides everything\n        ...route._resolvedData,\n      },\n    };\n  } else {\n    inherited = {\n      params: {...route.params},\n      data: {...route.data},\n      resolve: {...route.data, ...(route._resolvedData ?? {})},\n    };\n  }\n\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class ActivatedRouteSnapshot {\n  /** The configuration used to match this route **/\n  public readonly routeConfig: Route | null;\n  /** @internal */\n  _resolve: ResolveData;\n  /** @internal */\n  _resolvedData?: Data;\n  /** @internal */\n  _routerState!: RouterStateSnapshot;\n  /** @internal */\n  _paramMap?: ParamMap;\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  /** The resolved route title */\n  get title(): string | undefined {\n    // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n    // available at the time of class instantiation.\n    return this.data?.[RouteTitleKey];\n  }\n\n  /** @internal */\n  constructor(\n    /** The URL segments matched by this route */\n    public url: UrlSegment[],\n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```ts\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    public params: Params,\n    /** The query parameters shared by all the routes */\n    public queryParams: Params,\n    /** The URL fragment shared by all the routes */\n    public fragment: string | null,\n    /** The static and resolved data of this route */\n    public data: Data,\n    /** The outlet name of the route */\n    public outlet: string,\n    /** The component of the route */\n    public component: Type<any> | null,\n    routeConfig: Route | null,\n    resolve: ResolveData,\n  ) {\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n\n  /** The root of the router state */\n  get root(): ActivatedRouteSnapshot {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree */\n  get parent(): ActivatedRouteSnapshot | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree */\n  get firstChild(): ActivatedRouteSnapshot | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree */\n  get children(): ActivatedRouteSnapshot[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot(): ActivatedRouteSnapshot[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  get paramMap(): ParamMap {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map((segment) => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n    /** The url from which this snapshot was created */\n    public url: string,\n    root: TreeNode<ActivatedRouteSnapshot>,\n  ) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  override toString(): string {\n    return serializeNode(this._root);\n  }\n}\n\nfunction setRouterState<U, T extends {_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach((c) => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\n\nexport function equalParamsAndUrlSegments(\n  a: ActivatedRouteSnapshot,\n  b: ActivatedRouteSnapshot,\n): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return (\n    equalUrlParams &&\n    !parentsMismatch &&\n    (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent!))\n  );\n}\n\nexport function hasStaticTitle(config: Route) {\n  return typeof config.title === 'string' || config.title === null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ComponentRef,\n  Directive,\n  EnvironmentInjector,\n  EventEmitter,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  reflectComponentType,\n  SimpleChanges,\n  ViewContainerRef,\n  ɵRuntimeError as RuntimeError,\n  Signal,\n  input,\n} from '@angular/core';\nimport {combineLatest, of, Subscription} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n */\nexport const ROUTER_OUTLET_DATA = new InjectionToken<Signal<unknown | undefined>>(\n  ngDevMode ? 'RouterOutlet data' : '',\n);\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see {@link ChildrenOutletContexts}\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object | null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute | null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Used to indicate that the outlet is able to bind data from the `Router` to the outlet\n   * component's inputs.\n   *\n   * When this is `undefined` or `false` and the developer has opted in to the\n   * feature using `withComponentInputBinding`, a warning will be logged in dev mode if this outlet\n   * is used in the application.\n   */\n  readonly supportsBindingToComponentInputs?: true;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: 'router-outlet',\n  exportAs: 'outlet',\n})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any> | null = null;\n  /** @internal */\n  get activatedComponentRef(): ComponentRef<any> | null {\n    return this.activated;\n  }\n  private _activatedRoute: ActivatedRoute | null = null;\n  /**\n   * The name of the outlet\n   *\n   */\n  @Input() name = PRIMARY_OUTLET;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  /**\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n   *\n   * When unset, the value of the token is `undefined` by default.\n   */\n  readonly routerOutletData = input<unknown>(undefined);\n\n  private parentContexts = inject(ChildrenOutletContexts);\n  private location = inject(ViewContainerRef);\n  private changeDetector = inject(ChangeDetectorRef);\n  private inputBinder = inject(INPUT_BINDER, {optional: true});\n  /** @nodoc */\n  readonly supportsBindingToComponentInputs = true;\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['name']) {\n      const {firstChange, previousValue} = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n\n  private isTrackedInParentContexts(outletName: string) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this.initializeOutletWithName();\n  }\n\n  private initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector) {\n    if (this.isActivated) {\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Cannot activate an already activated outlet',\n      );\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(\n      activatedRoute,\n      childContexts,\n      location.injector,\n      this.routerOutletData,\n    );\n\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector,\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n    private route: ActivatedRoute,\n    private childContexts: ChildrenOutletContexts,\n    private parent: Injector,\n    private outletData: Signal<unknown>,\n  ) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nexport const INPUT_BINDER = new InjectionToken<RoutedComponentInputBinder>('');\n\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n@Injectable()\nexport class RoutedComponentInputBinder {\n  private outletDataSubscriptions = new Map<RouterOutlet, Subscription>();\n\n  bindActivatedRouteToOutletComponent(outlet: RouterOutlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n\n  unsubscribeFromRouteData(outlet: RouterOutlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n\n  private subscribeToRouteData(outlet: RouterOutlet) {\n    const {activatedRoute} = outlet;\n    const dataSubscription = combineLatest([\n      activatedRoute.queryParams,\n      activatedRoute.params,\n      activatedRoute.data,\n    ])\n      .pipe(\n        switchMap(([queryParams, params, data], index) => {\n          data = {...queryParams, ...params, ...data};\n          // Get the first result from the data subscription synchronously so it's available to\n          // the component as soon as possible (and doesn't require a second change detection).\n          if (index === 0) {\n            return of(data);\n          }\n          // Promise.resolve is used to avoid synchronously writing the wrong data when\n          // two of the Observables in the `combineLatest` stream emit one after\n          // another.\n          return Promise.resolve(data);\n        }),\n      )\n      .subscribe((data) => {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (\n          !outlet.isActivated ||\n          !outlet.activatedComponentRef ||\n          outlet.activatedRoute !== activatedRoute ||\n          activatedRoute.component === null\n        ) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        for (const {templateName} of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: RouterStateSnapshot,\n  prevState: RouterState,\n): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState?: TreeNode<ActivatedRoute>,\n): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = (detachedRouteHandle as DetachedRouteHandleInternal).route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n    return new TreeNode<ActivatedRoute>(value, children);\n  }\n}\n\nfunction createOrReuseChildren(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState: TreeNode<ActivatedRoute>,\n) {\n  return curr.children.map((child) => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n    new BehaviorSubject(c.url),\n    new BehaviorSubject(c.params),\n    new BehaviorSubject(c.queryParams),\n    new BehaviorSubject(c.fragment),\n    new BehaviorSubject(c.data),\n    c.outlet,\n    c.component,\n    c,\n  );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentInjector,\n  EnvironmentProviders,\n  NgModuleFactory,\n  Provider,\n  ProviderToken,\n  Type,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport type {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport type {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n\n/**\n * How to handle a navigation request to the current URL. One of:\n *\n * - `'ignore'` : The router ignores the request if it is the same as the current state.\n * - `'reload'` : The router processes the URL even if it is not different from the current state.\n * One example of when you might want to use this option is if a `canMatch` guard depends on the\n * application state and initially rejects navigation to a route. After fixing the state, you want\n * to re-navigate to the same URL so that the route with the `canMatch` guard can activate.\n *\n * Note that this only configures whether or not the Route reprocesses the URL and triggers related\n * actions and events like redirects, guards, and resolvers. By default, the router re-uses a\n * component instance when it re-navigates to the same component type without visiting a different\n * component first. This behavior is configured by the `RouteReuseStrategy`. In order to reload\n * routed components on same url navigation, you need to set `onSameUrlNavigation` to `'reload'`\n * _and_ provide a `RouteReuseStrategy` which returns `false` for `shouldReuseRoute`. Additionally,\n * resolvers and most guards for routes do not run unless the path or path params have changed\n * (configured by `runGuardsAndResolvers`).\n *\n * @publicApi\n * @see {@link RouteReuseStrategy}\n * @see {@link RunGuardsAndResolvers}\n * @see {@link NavigationBehaviorOptions}\n * @see {@link RouterConfigOptions}\n */\nexport type OnSameUrlNavigation = 'reload' | 'ignore';\n\n/**\n * The `InjectionToken` and `@Injectable` classes for guards and resolvers are deprecated in favor\n * of plain JavaScript functions instead. Dependency injection can still be achieved using the\n * [`inject`](api/core/inject) function from `@angular/core` and an injectable class can be used as\n * a functional guard using [`inject`](api/core/inject): `canActivate: [() =>\n * inject(myGuard).canActivate()]`.\n *\n * @deprecated\n * @see {@link CanMatchFn}\n * @see {@link CanLoadFn}\n * @see {@link CanActivateFn}\n * @see {@link CanActivateChildFn}\n * @see {@link CanDeactivateFn}\n * @see {@link ResolveFn}\n * @see {@link /api/core/inject inject}\n * @publicApi\n */\nexport type DeprecatedGuard = ProviderToken<any> | any;\n\n/**\n * The supported types that can be returned from a `Router` guard.\n *\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n * @publicApi\n */\nexport type GuardResult = boolean | UrlTree | RedirectCommand;\n\n/**\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\n * about _how_ to perform the navigation.\n *\n * ```ts\n * const route: Route = {\n *   path: \"user/:userId\",\n *   component: User,\n *   canActivate: [\n *     () => {\n *       const router = inject(Router);\n *       const authService = inject(AuthenticationService);\n *\n *       if (!authService.isLoggedIn()) {\n *         const loginPath = router.parseUrl(\"/login\");\n *         return new RedirectCommand(loginPath, {\n *           skipLocationChange: \"true\",\n *         });\n *       }\n *\n *       return true;\n *     },\n *   ],\n * };\n * ```\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n *\n * @publicApi\n */\nexport class RedirectCommand {\n  constructor(\n    readonly redirectTo: UrlTree,\n    readonly navigationBehaviorOptions?: NavigationBehaviorOptions,\n  ) {}\n}\n\n/**\n * Type used to represent a value which may be synchronous or async.\n *\n * @publicApi\n */\nexport type MaybeAsync<T> = T | Observable<T> | Promise<T>;\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see {@link Route}\n * @see {@link Router}\n * @see [Router configuration guide](guide/routing/router-reference#configuration)\n * @publicApi\n */\nexport type Routes = Route[];\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see {@link UrlMatcher}\n * @publicApi\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[];\n  posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * The function takes the following arguments and returns a `UrlMatchResult` object.\n * * *segments* : An array of URL segments.\n * * *group* : A segment group.\n * * *route* : The route to match against.\n *\n * The following example implementation matches HTML files.\n *\n * ```ts\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport type UrlMatcher = (\n  segments: UrlSegment[],\n  group: UrlSegmentGroup,\n  route: Route,\n) => UrlMatchResult | null;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see {@link Route#data}\n *\n * @publicApi\n */\nexport type Data = {\n  [key: string | symbol]: any;\n};\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * Returning a `RedirectCommand` directs the router to cancel the current navigation and redirect to\n * the location provided in the `RedirectCommand`. Note that there are no ordering guarantees when\n * resolvers execute. If multiple resolvers would return a `RedirectCommand`, only the first one\n * returned will be used.\n *\n * @see {@link Route#resolve}\n *\n * @publicApi\n */\nexport type ResolveData = {\n  [key: string | symbol]: ResolveFn<unknown> | DeprecatedGuard;\n};\n\n/**\n * An ES Module object with a default export of the given type.\n *\n * @see {@link Route#loadComponent}\n * @see {@link LoadChildrenCallback}\n *\n * @publicApi\n */\nexport interface DefaultExport<T> {\n  /**\n   * Default exports are bound under the name `\"default\"`, per the ES Module spec:\n   * https://tc39.es/ecma262/#table-export-forms-mapping-to-exportentry-records\n   */\n  default: T;\n}\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n * Must be an arrow function of the following form:\n * `() => import('...').then(mod => mod.MODULE)`\n * or\n * `() => import('...').then(mod => mod.ROUTES)`\n *\n * For example:\n *\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n * or\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.routes').then(mod => mod.ROUTES),\n * }];\n * ```\n *\n * If the lazy-loaded routes are exported via a `default` export, the `.then` can be omitted:\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.routes'),\n * }];\n * ```\n *\n * @see {@link Route#loadChildren}\n * @publicApi\n */\nexport type LoadChildrenCallback = () =>\n  | Type<any>\n  | NgModuleFactory<any>\n  | Routes\n  | Observable<Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>>\n  | Promise<\n      NgModuleFactory<any> | Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>\n    >;\n\n/**\n *\n * A function that returns a set of routes to load.\n *\n * @see {@link LoadChildrenCallback}\n * @publicApi\n */\nexport type LoadChildren = LoadChildrenCallback;\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `\"merge\"` : Merge new parameters with current parameters.\n * - `\"preserve\"` : Preserve current parameters.\n * - `\"replace\"` : Replace current parameters with new parameters. This is the default behavior.\n * - `\"\"` : For legacy reasons, the same as `'replace'`.\n *\n * @see {@link UrlCreationOptions#queryParamsHandling}\n * @see {@link RouterLink}\n * @publicApi\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | 'replace' | '';\n\n/**\n * The type for the function that can be used to handle redirects when the path matches a `Route` config.\n *\n * The `RedirectFunction` does have access to the full\n * `ActivatedRouteSnapshot` interface. Some data are not accurately known\n * at the route matching phase. For example, resolvers are not run until\n * later, so any resolved title would not be populated. The same goes for lazy\n * loaded components. This is also true for all the snapshots up to the\n * root, so properties that include parents (root, parent, pathFromRoot)\n * are also excluded. And naturally, the full route matching hasn't yet\n * happened so firstChild and children are not available either.\n *\n * @see {@link Route#redirectTo}\n * @publicApi\n */\nexport type RedirectFunction = (\n  redirectData: Pick<\n    ActivatedRouteSnapshot,\n    'routeConfig' | 'url' | 'params' | 'queryParams' | 'fragment' | 'data' | 'outlet' | 'title'\n  >,\n) => string | UrlTree;\n\n/**\n * A policy for when to run guards and resolvers on a route.\n *\n * Guards and/or resolvers will always run when a route is activated or deactivated. When a route is\n * unchanged, the default behavior is the same as `paramsChange`.\n *\n * `paramsChange` : Rerun the guards and resolvers when path or\n * path param changes. This does not include query parameters. This option is the default.\n * - `always` : Run on every execution.\n * - `pathParamsChange` : Rerun guards and resolvers when the path params\n * change. This does not compare matrix or query parameters.\n * - `paramsOrQueryParamsChange` : Run when path, matrix, or query parameters change.\n * - `pathParamsOrQueryParamsChange` : Rerun guards and resolvers when the path params\n * change or query params have changed. This does not include matrix parameters.\n *\n * @see {@link Route#runGuardsAndResolvers}\n * @publicApi\n */\nexport type RunGuardsAndResolvers =\n  | 'pathParamsChange'\n  | 'pathParamsOrQueryParamsChange'\n  | 'paramsChange'\n  | 'paramsOrQueryParamsChange'\n  | 'always'\n  | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/routing/common-router-tasks).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```ts\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```ts\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```ts\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```ts\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```ts\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property in the `Route` object,\n * instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport interface Route {\n  /**\n   * Used to define a page title for the route. This can be a static string or an `Injectable` that\n   * implements `Resolve`.\n   *\n   * @see {@link TitleStrategy}\n   */\n  title?: string | Type<Resolve<string>> | ResolveFn<string>;\n\n  /**\n   * The path to match against. Cannot be used together with a custom `matcher` function.\n   * A URL string that uses router matching notation.\n   * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n   * Default is \"/\" (the root path).\n   *\n   */\n  path?: string;\n  /**\n   * The path-matching strategy, one of 'prefix' or 'full'.\n   * Default is 'prefix'.\n   *\n   * By default, the router checks URL elements from the left to see if the URL\n   * matches a given path and stops when there is a config match. Importantly there must still be a\n   * config match for each segment of the URL. For example, '/team/11/user' matches the prefix\n   * 'team/:id' if one of the route's children matches the segment 'user'. That is, the URL\n   * '/team/11/user' matches the config\n   * `{path: 'team/:id', children: [{path: ':user', component: User}]}`\n   * but does not match when there are no children as in `{path: 'team/:id', component: Team}`.\n   *\n   * The path-match strategy 'full' matches against the entire URL.\n   * It is important to do this when redirecting empty-path routes.\n   * Otherwise, because an empty path is a prefix of any URL,\n   * the router would apply the redirect even when navigating\n   * to the redirect destination, creating an endless loop.\n   *\n   */\n  pathMatch?: 'prefix' | 'full';\n  /**\n   * A custom URL-matching function. Cannot be used together with `path`.\n   */\n  matcher?: UrlMatcher;\n  /**\n   * The component to instantiate when the path matches.\n   * Can be empty if child routes specify components.\n   */\n  component?: Type<any>;\n\n  /**\n   * An object specifying a lazy-loaded component.\n   */\n  loadComponent?: () =>\n    | Type<unknown>\n    | Observable<Type<unknown> | DefaultExport<Type<unknown>>>\n    | Promise<Type<unknown> | DefaultExport<Type<unknown>>>;\n  /**\n   * Filled for routes `loadComponent` once the component is loaded.\n   * @internal\n   */\n  _loadedComponent?: Type<unknown>;\n\n  /**\n   * A URL or function that returns a URL to redirect to when the path matches.\n   *\n   * Absolute if the URL begins with a slash (/) or the function returns a `UrlTree`, otherwise\n   * relative to the path URL.\n   *\n   * The `RedirectFunction` is run in an injection context so it can call `inject` to get any\n   * required dependencies.\n   *\n   * When not present, router does not redirect.\n   */\n  redirectTo?: string | RedirectFunction;\n  /**\n   * Name of a `RouterOutlet` object where the component can be placed\n   * when the path matches.\n   */\n  outlet?: string;\n  /**\n   * An array of `CanActivateFn` or DI tokens used to look up `CanActivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * activate the component. By default, any user can activate.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canActivate?: Array<CanActivateFn | DeprecatedGuard>;\n  /**\n   * An array of `CanMatchFn` or DI tokens used to look up `CanMatch()`\n   * handlers, in order to determine if the current user is allowed to\n   * match the `Route`. By default, any route can match.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canMatch?: Array<CanMatchFn | DeprecatedGuard>;\n  /**\n   * An array of `CanActivateChildFn` or DI tokens used to look up `CanActivateChild()` handlers,\n   * in order to determine if the current user is allowed to activate\n   * a child of the component. By default, any user can activate a child.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canActivateChild?: Array<CanActivateChildFn | DeprecatedGuard>;\n  /**\n   * An array of `CanDeactivateFn` or DI tokens used to look up `CanDeactivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * deactivate the component. By default, any user can deactivate.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canDeactivate?: Array<CanDeactivateFn<any> | DeprecatedGuard>;\n  /**\n   * An array of `CanLoadFn` or DI tokens used to look up `CanLoad()`\n   * handlers, in order to determine if the current user is allowed to\n   * load the component. By default, any user can load.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   * @deprecated Use `canMatch` instead\n   */\n  canLoad?: Array<CanLoadFn | DeprecatedGuard>;\n  /**\n   * Additional developer-defined data provided to the component via\n   * `ActivatedRoute`. By default, no additional data is passed.\n   */\n  data?: Data;\n  /**\n   * A map of DI tokens used to look up data resolvers. See `Resolve`.\n   */\n  resolve?: ResolveData;\n  /**\n   * An array of child `Route` objects that specifies a nested route\n   * configuration.\n   */\n  children?: Routes;\n  /**\n   * An object specifying lazy-loaded child routes.\n   */\n  loadChildren?: LoadChildren;\n\n  /**\n   * A policy for when to run guards and resolvers on a route.\n   *\n   * Guards and/or resolvers will always run when a route is activated or deactivated. When a route\n   * is unchanged, the default behavior is the same as `paramsChange`.\n   *\n   * `paramsChange` : Rerun the guards and resolvers when path or\n   * path param changes. This does not include query parameters. This option is the default.\n   * - `always` : Run on every execution.\n   * - `pathParamsChange` : Rerun guards and resolvers when the path params\n   * change. This does not compare matrix or query parameters.\n   * - `paramsOrQueryParamsChange` : Run when path, matrix, or query parameters change.\n   * - `pathParamsOrQueryParamsChange` : Rerun guards and resolvers when the path params\n   * change or query params have changed. This does not include matrix parameters.\n   *\n   * @see {@link RunGuardsAndResolvers}\n   */\n  runGuardsAndResolvers?: RunGuardsAndResolvers;\n\n  /**\n   * A `Provider` array to use for this `Route` and its `children`.\n   *\n   * The `Router` will create a new `EnvironmentInjector` for this\n   * `Route` and use it for this `Route` and its `children`. If this\n   * route also has a `loadChildren` function which returns an `NgModuleRef`, this injector will be\n   * used as the parent of the lazy loaded module.\n   */\n  providers?: Array<Provider | EnvironmentProviders>;\n\n  /**\n   * Injector created from the static route providers\n   * @internal\n   */\n  _injector?: EnvironmentInjector;\n\n  /**\n   * Filled for routes with `loadChildren` once the routes are loaded.\n   * @internal\n   */\n  _loadedRoutes?: Route[];\n\n  /**\n   * Filled for routes with `loadChildren` once the routes are loaded\n   * @internal\n   */\n  _loadedInjector?: EnvironmentInjector;\n}\n\nexport interface LoadedRouterConfig {\n  routes: Route[];\n  injector: EnvironmentInjector | undefined;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canActivate(): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanActivate {\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canActivate` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements and uses a `CanActivateFn` that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```ts\n * @Injectable()\n * class UserToken {}\n *\n * @Injectable()\n * class PermissionsService {\n *   canActivate(currentUser: UserToken, userId: string): boolean {\n *     return true;\n *   }\n *   canMatch(currentUser: UserToken): boolean {\n *     return true;\n *   }\n * }\n *\n * const canActivateTeam: CanActivateFn = (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   return inject(PermissionsService).canActivate(inject(UserToken), route.params['id']);\n * };\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * bootstrapApplication(App, {\n *    providers: [\n *      provideRouter([\n *        {\n *          path: 'team/:id',\n *          component: TeamComponent,\n *          canActivate: [canActivateTeam],\n *        },\n *      ]),\n *    ],\n *  });\n * ```\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanActivateFn = (\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivateChild` function that checks whether the\n * current user has permission to activate the requested child route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanActivateChild {\n  canActivateChild(\n    childRoute: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot,\n  ): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canActivateChild` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `canActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * {@example router/route_functional_guards.ts region=\"CanActivateChildFn\"}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanActivateChildFn = (\n  childRoute: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanDeactivate` function that checks whether the\n * current user has permission to deactivate the requested route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanDeactivate<T> {\n  canDeactivate(\n    component: T,\n    currentRoute: ActivatedRouteSnapshot,\n    currentState: RouterStateSnapshot,\n    nextState: RouterStateSnapshot,\n  ): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canDeactivate` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements and uses a `CanDeactivateFn` that checks whether the\n * user component has unsaved changes before navigating away from the route.\n *\n * {@example router/route_functional_guards.ts region=\"CanDeactivateFn\"}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanDeactivateFn<T> = (\n  component: T,\n  currentRoute: ActivatedRouteSnapshot,\n  currentState: RouterStateSnapshot,\n  nextState: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a `Route` can be matched.\n * If all guards return `true`, navigation continues and the `Router` will use the `Route` during\n * activation. If any guard returns `false`, the `Route` is skipped for matching and other `Route`\n * configurations are processed instead.\n *\n * The following example implements a `CanMatch` function that decides whether the\n * current user has permission to access the users page.\n *\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canAccess(user: UserToken, route: Route, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanMatchTeamSection implements CanMatch {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canMatch(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canAccess(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canMatch: [CanMatchTeamSection]\n *       },\n *       {\n *         path: '**',\n *         component: NotFoundComponent\n *       }\n *     ])\n *   ],\n *   providers: [CanMatchTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * If the `CanMatchTeamSection` were to return `false`, the router would continue navigating to the\n * `team/:id` URL, but would load the `NotFoundComponent` because the `Route` for `'team/:id'`\n * could not be used for a URL match but the catch-all `**` `Route` did instead.\n *\n * @publicApi\n */\nexport interface CanMatch {\n  canMatch(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canMatch` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues and the `Router` will use the `Route` during\n * activation. If any guard returns `false`, the `Route` is skipped for matching and other `Route`\n * configurations are processed instead.\n *\n * The following example implements and uses a `CanMatchFn` that checks whether the\n * current user has permission to access the team page.\n *\n * {@example router/route_functional_guards.ts region=\"CanMatchFn\"}\n *\n * @param route The route configuration.\n * @param segments The URL segments that have not been consumed by previous parent route evaluations.\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanMatchFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that classes can implement to be a data provider.\n * A data provider class can be used with the router to resolve data during navigation.\n * The interface defines a `resolve()` method that is invoked right after the `ResolveStart`\n * router event. The router waits for the data to be resolved before the route is finally activated.\n *\n * The following example implements a `resolve()` method that retrieves the data\n * needed to activate the requested route.\n *\n * ```ts\n * @Injectable({ providedIn: 'root' })\n * export class HeroResolver implements Resolve<Hero> {\n *   constructor(private service: HeroService) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<Hero>|Promise<Hero>|Hero {\n *     return this.service.getHero(route.paramMap.get('id'));\n *   }\n * }\n * ```\n *\n * Here, the defined `resolve()` function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {\n *           hero: HeroResolver\n *         }\n *       }\n *     ])\n *   ],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule {}\n * ```\n *\n * And you can access to your resolved data from `HeroComponent`:\n *\n * ```ts\n * @Component({\n *  selector: \"app-hero\",\n *  templateUrl: \"hero.component.html\",\n * })\n * export class HeroComponent {\n *\n *  constructor(private activatedRoute: ActivatedRoute) {}\n *\n *  ngOnInit() {\n *    this.activatedRoute.data.subscribe(({ hero }) => {\n *      // do something with your resolved data ...\n *    })\n *  }\n *\n * }\n * ```\n *\n * @usageNotes\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```ts\n * {\n *  path: 'base'\n *  canActivate: [BaseGuard],\n *  resolve: {data: BaseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     guards: [ChildGuard],\n *     component: ChildComponent,\n *     resolve: {childData: ChildDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\n *\n * @publicApi\n * @see {@link ResolveFn}\n */\nexport interface Resolve<T> {\n  resolve(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot,\n  ): MaybeAsync<T | RedirectCommand>;\n}\n\n/**\n * Function type definition for a data provider.\n *\n * A data provider can be used with the router to resolve data during navigation.\n * The router waits for the data to be resolved before the route is finally activated.\n *\n * A resolver can also redirect a `RedirectCommand` and the Angular router will use\n * it to redirect the current navigation to the new destination.\n *\n * @usageNotes\n *\n * The following example implements a function that retrieves the data\n * needed to activate the requested route.\n *\n * ```ts\n * interface Hero {\n *   name: string;\n * }\n * @Injectable()\n * export class HeroService {\n *   getHero(id: string) {\n *     return {name: `Superman-${id}`};\n *   }\n * }\n *\n * export const heroResolver: ResolveFn<Hero> = (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   return inject(HeroService).getHero(route.paramMap.get('id')!);\n * };\n *\n * bootstrapApplication(App, {\n *   providers: [\n *     provideRouter([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {hero: heroResolver},\n *       },\n *     ]),\n *   ],\n * });\n * ```\n *\n * And you can access to your resolved data from `HeroComponent`:\n *\n * ```ts\n * @Component({template: ''})\n * export class HeroDetailComponent {\n *   private activatedRoute = inject(ActivatedRoute);\n *\n *   ngOnInit() {\n *     this.activatedRoute.data.subscribe(({hero}) => {\n *       // do something with your resolved data ...\n *     });\n *   }\n * }\n * ```\n *\n * If resolved data cannot be retrieved, you may want to redirect the user\n * to a new page instead:\n *\n * ```ts\n * export const heroResolver: ResolveFn<Hero> = async (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   const router = inject(Router);\n *   const heroService = inject(HeroService);\n *   try {\n *     return await heroService.getHero(route.paramMap.get('id')!);\n *   } catch {\n *     return new RedirectCommand(router.parseUrl('/404'));\n *   }\n * };\n * ```\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```ts\n * {\n *  path: 'base'\n *  canActivate: [baseGuard],\n *  resolve: {data: baseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     canActivate: [childGuard],\n *     component: ChildComponent,\n *     resolve: {childData: childDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: baseGuard, childGuard, baseDataResolver, childDataResolver.\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type ResolveFn<T> = (\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<T | RedirectCommand>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if children can be loaded.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanLoad` function that decides whether the\n * current user has permission to load requested child routes.\n *\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n * @deprecated Use {@link CanMatch} instead\n */\nexport interface CanLoad {\n  canLoad(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canLoad` guard on a `Route`.\n *\n * @publicApi\n * @see {@link CanLoad}\n * @see {@link Route}\n * @see {@link CanMatch}\n * @deprecated Use `Route.canMatch` and `CanMatchFn` instead\n */\nexport type CanLoadFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the navigation should be handled.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n *\n * @publicApi\n */\nexport interface NavigationBehaviorOptions {\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   * This value is a subset of the options available in `OnSameUrlNavigation` and\n   * will take precedence over the default value set for the `Router`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   * @see {@link RouterConfigOptions}\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * When true, navigates without pushing a new state into history.\n   *\n   * ```\n   * // Navigate silently to /view\n   * this.router.navigate(['/view'], { skipLocationChange: true });\n   * ```\n   */\n  skipLocationChange?: boolean;\n\n  /**\n   * When true, navigates while replacing the current state in history.\n   *\n   * ```\n   * // Navigate to /view\n   * this.router.navigate(['/view'], { replaceUrl: true });\n   * ```\n   */\n  replaceUrl?: boolean;\n\n  /**\n   * Developer-defined state that can be passed to any navigation.\n   * Access this value through the `Navigation.extras` object\n   * returned from the [Router.getCurrentNavigation()\n   * method](api/router/Router#getcurrentnavigation) while a navigation is executing.\n   *\n   * After a navigation completes, the router writes an object containing this\n   * value together with a `navigationId` to `history.state`.\n   * The value is written when `location.go()` or `location.replaceState()`\n   * is called before activating this route.\n   *\n   * Note that `history.state` does not pass an object equality test because\n   * the router adds the `navigationId` on each navigation.\n   *\n   */\n  state?: {[k: string]: any};\n\n  /**\n   * Use this to convey transient information about this particular navigation, such as how it\n   * happened. In this way, it's different from the persisted value `state` that will be set to\n   * `history.state`. This object is assigned directly to the Router's current `Navigation`\n   * (it is not copied or cloned), so it should be mutated with caution.\n   *\n   * One example of how this might be used is to trigger different single-page navigation animations\n   * depending on how a certain route was reached. For example, consider a photo gallery app, where\n   * you can reach the same photo URL and state via various routes:\n   *\n   * - Clicking on it in a gallery view\n   * - Clicking\n   * - \"next\" or \"previous\" when viewing another photo in the album\n   * - Etc.\n   *\n   * Each of these wants a different animation at navigate time. This information doesn't make sense\n   * to store in the persistent URL or history entry state, but it's still important to communicate\n   * from the rest of the application, into the router.\n   *\n   * This information could be used in coordination with the View Transitions feature and the\n   * `onViewTransitionCreated` callback. The information might be used in the callback to set\n   * classes on the document in order to control the transition animations and remove the classes\n   * when the transition has finished animating.\n   */\n  readonly info?: unknown;\n\n  /**\n   * When set, the Router will update the browser's address bar to match the given `UrlTree` instead\n   * of the one used for route matching.\n   *\n   *\n   * @usageNotes\n   *\n   * This feature is useful for redirects, such as redirecting to an error page, without changing\n   * the value that will be displayed in the browser's address bar.\n   *\n   * ```ts\n   * const canActivate: CanActivateFn = (route: ActivatedRouteSnapshot) => {\n   *   const userService = inject(UserService);\n   *   const router = inject(Router);\n   *   if (!userService.isLoggedIn()) {\n   *     const targetOfCurrentNavigation = router.getCurrentNavigation()?.finalUrl;\n   *     const redirect = router.parseUrl('/404');\n   *     return new RedirectCommand(redirect, {browserUrl: targetOfCurrentNavigation});\n   *   }\n   *   return true;\n   * };\n   * ```\n   *\n   * This value is used directly, without considering any `UrlHandingStrategy`. In this way,\n   * `browserUrl` can also be used to use a different value for the browser URL than what would have\n   * been produced by from the navigation due to `UrlHandlingStrategy.merge`.\n   *\n   * This value only affects the path presented in the browser's address bar. It does not apply to\n   * the internal `Router` state. Information such as `params` and `data` will match the internal\n   * state used to match routes which will be different from the browser URL when using this feature\n   * The same is true when using other APIs that cause the browser URL the differ from the Router\n   * state, such as `skipLocationChange`.\n   */\n  readonly browserUrl?: UrlTree | string;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationCancellationCode} from './events';\nimport {NavigationBehaviorOptions, RedirectCommand} from './models';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\n\nexport const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport type NavigationCancelingError = Error & {\n  [NAVIGATION_CANCELING_ERROR]: true;\n  cancellationCode: NavigationCancellationCode;\n};\nexport type RedirectingNavigationCancelingError = NavigationCancelingError & {\n  url: UrlTree;\n  navigationBehaviorOptions?: NavigationBehaviorOptions;\n  cancellationCode: NavigationCancellationCode.Redirect;\n};\n\nexport function redirectingNavigationError(\n  urlSerializer: UrlSerializer,\n  redirect: UrlTree | RedirectCommand,\n): RedirectingNavigationCancelingError {\n  const {redirectTo, navigationBehaviorOptions} = isUrlTree(redirect)\n    ? {redirectTo: redirect, navigationBehaviorOptions: undefined}\n    : redirect;\n  const error = navigationCancelingError(\n    ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`,\n    NavigationCancellationCode.Redirect,\n  ) as RedirectingNavigationCancelingError;\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nexport function navigationCancelingError(\n  message: string | null | false,\n  code: NavigationCancellationCode,\n) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`) as NavigationCancelingError;\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\n\nexport function isRedirectingNavigationCancelingError(\n  error: unknown | RedirectingNavigationCancelingError,\n): error is RedirectingNavigationCancelingError {\n  return (\n    isNavigationCancelingError(error) &&\n    isUrlTree((error as RedirectingNavigationCancelingError).url)\n  );\n}\n\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return !!error && (error as NavigationCancelingError)[NAVIGATION_CANCELING_ERROR];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport type {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, advanceActivatedRoute, RouterState} from '../router_state';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nlet warnedAboutUnsupportedInputBinding = false;\n\nexport const activateRoutes = (\n  rootContexts: ChildrenOutletContexts,\n  routeReuseStrategy: RouteReuseStrategy,\n  forwardEvent: (evt: Event) => void,\n  inputBindingEnabled: boolean,\n): MonoTypeOperatorFunction<NavigationTransition> =>\n  map((t) => {\n    new ActivateRoutes(\n      routeReuseStrategy,\n      t.targetRouterState!,\n      t.currentRouterState,\n      forwardEvent,\n      inputBindingEnabled,\n    ).activate(rootContexts);\n    return t;\n  });\n\nexport class ActivateRoutes {\n  constructor(\n    private routeReuseStrategy: RouteReuseStrategy,\n    private futureState: RouterState,\n    private currState: RouterState,\n    private forwardEvent: (evt: Event) => void,\n    private inputBindingEnabled: boolean,\n  ) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach((futureChild) => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    Object.values(children).forEach((v: TreeNode<ActivatedRoute>) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContext: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context) {\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n      // info\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n\n  private activateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach((c) => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = <DetachedRouteHandleInternal>(\n            this.routeReuseStrategy.retrieve(future.snapshot)\n          );\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (\n        outlet &&\n        this.inputBindingEnabled &&\n        !outlet.supportsBindingToComponentInputs &&\n        !warnedAboutUnsupportedInputBinding\n      ) {\n        console.warn(\n          `'withComponentInputBinding' feature is enabled but ` +\n            `this application is using an outlet that may not support binding to component inputs.`,\n        );\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, ProviderToken, ɵisInjectable as isInjectable} from '@angular/core';\n\nimport {RunGuardsAndResolvers} from '../models';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {\n  ActivatedRouteSnapshot,\n  equalParamsAndUrlSegments,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {shallowEqual} from '../utils/collection';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(\n    public component: Object | null,\n    public route: ActivatedRouteSnapshot,\n  ) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[];\n  canActivateChecks: CanActivate[];\n};\n\nexport function getAllRouteGuards(\n  future: RouterStateSnapshot,\n  curr: RouterStateSnapshot,\n  parentContexts: ChildrenOutletContexts,\n) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(\n  p: ActivatedRouteSnapshot,\n): {node: ActivatedRouteSnapshot; guards: any[]} | null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getTokenOrFunctionIdentity<T>(\n  tokenOrFunction: Function | ProviderToken<T>,\n  injector: Injector,\n): Function | T {\n  const NOT_FOUND = Symbol();\n  const result = injector.get<T | Symbol>(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !isInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get<T>(tokenOrFunction);\n    }\n  }\n  return result as T;\n}\n\nfunction getChildRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot> | null,\n  contexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach((c) => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  Object.entries(prevChildren).forEach(([k, v]: [string, TreeNode<ActivatedRouteSnapshot>]) =>\n    deactivateRouteAndItsChildren(v, contexts!.getContext(k), checks),\n  );\n\n  return checks;\n}\n\nfunction getRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot>,\n  parentContexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(\n      curr,\n      future,\n      future.routeConfig!.runGuardsAndResolvers,\n    );\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n        futureNode,\n        currNode,\n        context ? context.children : null,\n        futurePath,\n        checks,\n      );\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n  curr: ActivatedRouteSnapshot,\n  future: ActivatedRouteSnapshot,\n  mode: RunGuardsAndResolvers | undefined,\n): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return (\n        !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return (\n        !equalParamsAndUrlSegments(curr, future) ||\n        !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n  route: TreeNode<ActivatedRouteSnapshot>,\n  context: OutletContext | null,\n  checks: Checks,\n): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EmptyError} from 'rxjs';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn} from '../models';\nimport {\n  NAVIGATION_CANCELING_ERROR,\n  NavigationCancelingError,\n  RedirectingNavigationCancelingError,\n} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is {canLoad: CanLoadFn} {\n  return guard && isFunction<CanLoadFn>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is {canActivate: CanActivateFn} {\n  return guard && isFunction<CanActivateFn>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is {canActivateChild: CanActivateChildFn} {\n  return guard && isFunction<CanActivateChildFn>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is {canDeactivate: CanDeactivateFn<T>} {\n  return guard && isFunction<CanDeactivateFn<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is {canMatch: CanMatchFn} {\n  return guard && isFunction<CanMatchFn>(guard.canMatch);\n}\n\nexport function isEmptyError(e: Error): e is EmptyError {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {combineLatest, Observable, OperatorFunction} from 'rxjs';\nimport {filter, map, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {GuardResult, RedirectCommand} from '../models';\nimport {isUrlTree, UrlTree} from '../url_tree';\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | GuardResult;\n\nexport function prioritizedGuardValue(): OperatorFunction<Observable<GuardResult>[], GuardResult> {\n  return switchMap((obs) => {\n    return combineLatest(\n      obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))),\n    ).pipe(\n      map((results: INTERIM_VALUES[]) => {\n        for (const result of results) {\n          if (result === true) {\n            // If result is true, check the next one\n            continue;\n          } else if (result === INITIAL_VALUE) {\n            // If guard has not finished, we need to stop processing.\n            return INITIAL_VALUE;\n          } else if (result === false || isRedirect(result)) {\n            // Result finished and was not true. Return the result.\n            // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n            // ignored.\n            return result;\n          }\n        }\n        // Everything resolved to true. Return true.\n        return true;\n      }),\n      filter((item): item is GuardResult => item !== INITIAL_VALUE),\n      take(1),\n    );\n  });\n}\n\nfunction isRedirect(val: INTERIM_VALUES): val is UrlTree | RedirectCommand {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {\n  concat,\n  defer,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n} from 'rxjs';\nimport {concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {\n  CanActivateChildFn,\n  CanActivateFn,\n  CanDeactivateFn,\n  GuardResult,\n  CanLoadFn,\n  CanMatchFn,\n  Route,\n} from '../models';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {UrlSegment, UrlSerializer} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {\n  CanActivate,\n  CanDeactivate,\n  getCanActivateChild,\n  getTokenOrFunctionIdentity,\n} from '../utils/preactivation';\nimport {\n  isBoolean,\n  isCanActivate,\n  isCanActivateChild,\n  isCanDeactivate,\n  isCanLoad,\n  isCanMatch,\n} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\n\nexport function checkGuards(\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {canActivateChecks, canDeactivateChecks},\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({...t, guardsResult: true});\n    }\n\n    return runCanDeactivateChecks(\n      canDeactivateChecks,\n      targetSnapshot!,\n      currentSnapshot,\n      injector,\n    ).pipe(\n      mergeMap((canDeactivate) => {\n        return canDeactivate && isBoolean(canDeactivate)\n          ? runCanActivateChecks(targetSnapshot!, canActivateChecks, injector, forwardEvent)\n          : of(canDeactivate);\n      }),\n      map((guardsResult) => ({...t, guardsResult})),\n    );\n  });\n}\n\nfunction runCanDeactivateChecks(\n  checks: CanDeactivate[],\n  futureRSS: RouterStateSnapshot,\n  currRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n) {\n  return from(checks).pipe(\n    mergeMap((check) =>\n      runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector),\n    ),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\nfunction runCanActivateChecks(\n  futureSnapshot: RouterStateSnapshot,\n  checks: CanActivate[],\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n) {\n  return from(checks).pipe(\n    concatMap((check: CanActivate) => {\n      return concat(\n        fireChildActivationStart(check.route.parent, forwardEvent),\n        fireActivationStart(check.route, forwardEvent),\n        runCanActivateChild(futureSnapshot, check.path, injector),\n        runCanActivate(futureSnapshot, check.route, injector),\n      );\n    }),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\n\nfunction runCanActivate(\n  futureRSS: RouterStateSnapshot,\n  futureARS: ActivatedRouteSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n\n  const canActivateObservables = canActivate.map(\n    (canActivate: CanActivateFn | ProviderToken<unknown>) => {\n      return defer(() => {\n        const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n        const guard = getTokenOrFunctionIdentity<CanActivate>(canActivate, closestInjector);\n        const guardVal = isCanActivate(guard)\n          ? guard.canActivate(futureARS, futureRSS)\n          : runInInjectionContext(closestInjector, () =>\n              (guard as CanActivateFn)(futureARS, futureRSS),\n            );\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n    },\n  );\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n  futureRSS: RouterStateSnapshot,\n  path: ActivatedRouteSnapshot[],\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path\n    .slice(0, path.length - 1)\n    .reverse()\n    .map((p) => getCanActivateChild(p))\n    .filter((_) => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(\n        (canActivateChild: CanActivateChildFn | ProviderToken<unknown>) => {\n          const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n          const guard = getTokenOrFunctionIdentity<{canActivateChild: CanActivateChildFn}>(\n            canActivateChild,\n            closestInjector,\n          );\n          const guardVal = isCanActivateChild(guard)\n            ? guard.canActivateChild(futureARS, futureRSS)\n            : runInInjectionContext(closestInjector, () =>\n                (guard as CanActivateChildFn)(futureARS, futureRSS),\n              );\n          return wrapIntoObservable(guardVal).pipe(first());\n        },\n      );\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n  component: Object | null,\n  currARS: ActivatedRouteSnapshot,\n  currRSS: RouterStateSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity<any>(c, closestInjector);\n    const guardVal = isCanDeactivate(guard)\n      ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\n      : runInInjectionContext(closestInjector, () =>\n          (guard as CanDeactivateFn<any>)(component, currARS, currRSS, futureRSS),\n        );\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nexport function runCanLoadGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  const canLoadObservables = canLoad.map((injectionToken: any) => {\n    const guard = getTokenOrFunctionIdentity<any>(injectionToken, injector);\n    const guardVal = isCanLoad(guard)\n      ? guard.canLoad(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanLoadFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nfunction redirectIfUrlTree(urlSerializer: UrlSerializer): OperatorFunction<GuardResult, boolean> {\n  return pipe(\n    tap((result: GuardResult) => {\n      if (typeof result === 'boolean') return;\n\n      throw redirectingNavigationError(urlSerializer, result);\n    }),\n    map((result) => result === true),\n  );\n}\n\nexport function runCanMatchGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n): Observable<GuardResult> {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n\n  const canMatchObservables = canMatch.map((injectionToken) => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard)\n      ? guard.canMatch(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanMatchFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, runInInjectionContext, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {Observable, of, throwError} from 'rxjs';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {LoadedRouterConfig, RedirectFunction, Route} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n\nexport class NoMatch {\n  public segmentGroup: UrlSegmentGroup | null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\n\nexport class AbsoluteRedirect extends Error {\n  constructor(public urlTree: UrlTree) {\n    super();\n  }\n}\n\nexport function noMatch(segmentGroup: UrlSegmentGroup): Observable<any> {\n  return throwError(new NoMatch(segmentGroup));\n}\n\nexport function absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nexport function namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return throwError(\n    new RuntimeError(\n      RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`,\n    ),\n  );\n}\n\nexport function canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return throwError(\n    navigationCancelingError(\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`,\n      NavigationCancellationCode.GuardRejected,\n    ),\n  );\n}\n\nexport class ApplyRedirects {\n  constructor(\n    private urlSerializer: UrlSerializer,\n    private urlTree: UrlTree,\n  ) {}\n\n  lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo!}`);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  applyRedirectCommands(\n    segments: UrlSegment[],\n    redirectTo: string | RedirectFunction,\n    posParams: {[k: string]: UrlSegment},\n    currentSnapshot: ActivatedRouteSnapshot,\n    injector: Injector,\n  ): UrlTree {\n    if (typeof redirectTo !== 'string') {\n      const redirectToFn = redirectTo;\n      const {queryParams, fragment, routeConfig, url, outlet, params, data, title} =\n        currentSnapshot;\n      const newRedirect = runInInjectionContext(injector, () =>\n        redirectToFn({params, data, queryParams, fragment, routeConfig, url, outlet, title}),\n      );\n      if (newRedirect instanceof UrlTree) {\n        throw new AbsoluteRedirect(newRedirect);\n      }\n\n      redirectTo = newRedirect;\n    }\n\n    const newTree = this.applyRedirectCreateUrlTree(\n      redirectTo,\n      this.urlSerializer.parse(redirectTo),\n      segments,\n      posParams,\n    );\n    if (redirectTo[0] === '/') {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n\n  applyRedirectCreateUrlTree(\n    redirectTo: string,\n    urlTree: UrlTree,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n      newRoot,\n      this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n      urlTree.fragment,\n    );\n  }\n\n  createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  createSegmentGroup(\n    redirectTo: string,\n    group: UrlSegmentGroup,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  createSegments(\n    redirectTo: string,\n    redirectToSegments: UrlSegment[],\n    actualSegments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment[] {\n    return redirectToSegments.map((s) =>\n      s.path[0] === ':'\n        ? this.findPosParam(redirectTo, s, posParams)\n        : this.findOrReturn(s, actualSegments),\n    );\n  }\n\n  findPosParam(\n    redirectTo: string,\n    redirectToUrlSegment: UrlSegment,\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_REDIRECT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`,\n      );\n    return pos;\n  }\n\n  findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {runCanMatchGuards} from '../operators/check_guards';\nimport {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer} from '../url_tree';\n\nimport {last} from './collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet} from './config';\n\nexport interface MatchResult {\n  matched: boolean;\n  consumedSegments: UrlSegment[];\n  remainingSegments: UrlSegment[];\n  parameters: {[k: string]: string};\n  positionalParamSegments: {[k: string]: UrlSegment};\n}\n\nconst noMatch: MatchResult = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {},\n};\n\nexport function matchWithChecks(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n  injector: EnvironmentInjector,\n  urlSerializer: UrlSerializer,\n): Observable<MatchResult> {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(\n    map((v) => (v === true ? result : {...noMatch})),\n  );\n}\n\nexport function match(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n): MatchResult {\n  if (route.path === '**') {\n    return createWildcardMatchResult(segments);\n  }\n\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {...noMatch};\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {},\n    };\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {...noMatch};\n\n  const posParams: {[n: string]: string} = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters =\n    res.consumed.length > 0\n      ? {...posParams, ...res.consumed[res.consumed.length - 1].parameters}\n      : posParams;\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {},\n  };\n}\n\nfunction createWildcardMatchResult(segments: UrlSegment[]): MatchResult {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last(segments)!.parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {},\n  };\n}\n\nexport function split(\n  segmentGroup: UrlSegmentGroup,\n  consumedSegments: UrlSegment[],\n  slicedSegments: UrlSegment[],\n  config: Route[],\n) {\n  if (\n    slicedSegments.length > 0 &&\n    containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      consumedSegments,\n      createChildrenForEmptyPaths(\n        config,\n        new UrlSegmentGroup(slicedSegments, segmentGroup.children),\n      ),\n    );\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (\n    slicedSegments.length === 0 &&\n    containsEmptyPathMatches(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      segmentGroup.segments,\n      addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children),\n    );\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n  children: {[name: string]: UrlSegmentGroup},\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n  routes: Route[],\n  primarySegment: UrlSegmentGroup,\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some(\n    (r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET,\n  );\n}\n\nfunction containsEmptyPathMatches(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nexport function emptyPathMatch(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  r: Route,\n): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n\nexport function noLeftoversInUrl(\n  segmentGroup: UrlSegmentGroup,\n  segments: UrlSegment[],\n  outlet: string,\n): boolean {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  defaultIfEmpty,\n  first,\n  last,\n  map,\n  mergeMap,\n  scan,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport {AbsoluteRedirect, ApplyRedirects, canLoadFails, noMatch, NoMatch} from './apply_redirects';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  ParamsInheritanceStrategy,\n  RouterStateSnapshot,\n} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {\n  emptyPathMatch,\n  match,\n  matchWithChecks,\n  noLeftoversInUrl,\n  split,\n} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Routes,\n  urlTree: UrlTree,\n  urlSerializer: UrlSerializer,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n  return new Recognizer(\n    injector,\n    configLoader,\n    rootComponentType,\n    config,\n    urlTree,\n    paramsInheritanceStrategy,\n    urlSerializer,\n  ).recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects: ApplyRedirects;\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n    private injector: EnvironmentInjector,\n    private configLoader: RouterConfigLoader,\n    private rootComponentType: Type<any> | null,\n    private config: Routes,\n    private urlTree: UrlTree,\n    private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n    private readonly urlSerializer: UrlSerializer,\n  ) {\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n\n  private noMatchError(e: NoMatch): RuntimeError<RuntimeErrorCode.NO_MATCH> {\n    return new RuntimeError(\n      RuntimeErrorCode.NO_MATCH,\n      typeof ngDevMode === 'undefined' || ngDevMode\n        ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n        : `'${e.segmentGroup}'`,\n    );\n  }\n\n  recognize(): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    return this.match(rootSegmentGroup).pipe(\n      map(({children, rootSnapshot}) => {\n        const rootNode = new TreeNode(rootSnapshot, children);\n        const routeState = new RouterStateSnapshot('', rootNode);\n        const tree = createUrlTreeFromSnapshot(\n          rootSnapshot,\n          [],\n          this.urlTree.queryParams,\n          this.urlTree.fragment,\n        );\n        // https://github.com/angular/angular/issues/47307\n        // Creating the tree stringifies the query params\n        // We don't want to do this here so reassign them to the original.\n        tree.queryParams = this.urlTree.queryParams;\n        routeState.url = this.urlSerializer.serialize(tree);\n        return {state: routeState, tree};\n      }),\n    );\n  }\n\n  private match(rootSegmentGroup: UrlSegmentGroup): Observable<{\n    children: TreeNode<ActivatedRouteSnapshot>[];\n    rootSnapshot: ActivatedRouteSnapshot;\n  }> {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot(\n      [],\n      Object.freeze({}),\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      Object.freeze({}),\n      PRIMARY_OUTLET,\n      this.rootComponentType,\n      null,\n      {},\n    );\n    return this.processSegmentGroup(\n      this.injector,\n      this.config,\n      rootSegmentGroup,\n      PRIMARY_OUTLET,\n      rootSnapshot,\n    ).pipe(\n      map((children) => {\n        return {children, rootSnapshot};\n      }),\n      catchError((e: any) => {\n        if (e instanceof AbsoluteRedirect) {\n          this.urlTree = e.urlTree;\n          return this.match(e.urlTree.root);\n        }\n        if (e instanceof NoMatch) {\n          throw this.noMatchError(e);\n        }\n\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentGroup(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n\n    return this.processSegment(\n      injector,\n      config,\n      segmentGroup,\n      segmentGroup.segments,\n      outlet,\n      true,\n      parentRoute,\n    ).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(\n      concatMap((childOutlet) => {\n        const child = segmentGroup.children[childOutlet];\n        // Sort the config so that routes with outlets that match the one being activated\n        // appear first, followed by routes for other outlets, which might match if they have\n        // an empty path.\n        const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n      }),\n      scan((children, outletChildren) => {\n        children.push(...outletChildren);\n        return children;\n      }),\n      defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n      last(),\n      mergeMap((children) => {\n        if (children === null) return noMatch(segmentGroup);\n        // Because we may have matched two outlets to the same empty path segment, we can have\n        // multiple activated results for the same outlet. We should merge the children of\n        // these results so the final return value is only one `TreeNode` per outlet.\n        const mergedChildren = mergeEmptyPathMatches(children);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // This should really never happen - we are only taking the first match for each\n          // outlet and merge the empty path matches.\n          checkOutletNameUniqueness(mergedChildren);\n        }\n        sortActivatedRouteSnapshots(mergedChildren);\n        return of(mergedChildren);\n      }),\n    );\n  }\n\n  processSegment(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    segmentGroup: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    return from(routes).pipe(\n      concatMap((r) => {\n        return this.processSegmentAgainstRoute(\n          r._injector ?? injector,\n          routes,\n          r,\n          segmentGroup,\n          segments,\n          outlet,\n          allowRedirects,\n          parentRoute,\n        ).pipe(\n          catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              return of(null);\n            }\n            throw e;\n          }),\n        );\n      }),\n      first((x): x is TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl => !!x),\n      catchError((e) => {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new NoLeftoversInUrl());\n          }\n          return noMatch(segmentGroup);\n        }\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    route: Route,\n    rawSegment: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (\n      getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))\n    ) {\n      return noMatch(rawSegment);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(\n        injector,\n        rawSegment,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n        injector,\n        rawSegment,\n        routes,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    return noMatch(rawSegment);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n    injector: EnvironmentInjector,\n    segmentGroup: UrlSegmentGroup,\n    routes: Route[],\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    const {matched, parameters, consumedSegments, positionalParamSegments, remainingSegments} =\n      match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n            RuntimeErrorCode.INFINITE_REDIRECT,\n            `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n              `This is currently a dev mode only error but will become a` +\n              ` call stack size exceeded error in production in a future major version.`,\n          );\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(\n      segments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree = this.applyRedirects.applyRedirectCommands(\n      consumedSegments,\n      route.redirectTo!,\n      positionalParamSegments,\n      currentSnapshot,\n      injector,\n    );\n\n    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(\n      mergeMap((newSegments: UrlSegment[]) => {\n        return this.processSegment(\n          injector,\n          routes,\n          segmentGroup,\n          newSegments.concat(remainingSegments),\n          outlet,\n          false,\n          parentRoute,\n        );\n      }),\n    );\n  }\n\n  matchSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    rawSegment: UrlSegmentGroup,\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>> {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n\n    return matchResult.pipe(\n      switchMap((result) => {\n        if (!result.matched) {\n          return noMatch(rawSegment);\n        }\n        // If the route has an injector created from providers, we should start using that.\n        injector = route._injector ?? injector;\n        return this.getChildConfig(injector, route, segments).pipe(\n          switchMap(({routes: childConfig}) => {\n            const childInjector = route._loadedInjector ?? injector;\n\n            const {parameters, consumedSegments, remainingSegments} = result;\n            const snapshot = new ActivatedRouteSnapshot(\n              consumedSegments,\n              parameters,\n              Object.freeze({...this.urlTree.queryParams}),\n              this.urlTree.fragment,\n              getData(route),\n              getOutlet(route),\n              route.component ?? route._loadedComponent ?? null,\n              route,\n              getResolve(route),\n            );\n            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n            snapshot.params = Object.freeze(inherited.params);\n            snapshot.data = Object.freeze(inherited.data);\n\n            const {segmentGroup, slicedSegments} = split(\n              rawSegment,\n              consumedSegments,\n              remainingSegments,\n              childConfig,\n            );\n\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(\n                map((children) => {\n                  return new TreeNode(snapshot, children);\n                }),\n              );\n            }\n\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return of(new TreeNode(snapshot, []));\n            }\n\n            const matchedOnOutlet = getOutlet(route) === outlet;\n            // If we matched a config due to empty path match on a different outlet, we need to\n            // continue passing the current outlet for the segment rather than switch to PRIMARY.\n            // Note that we switch to primary when we have a match because outlet configs look like\n            // this: {path: 'a', outlet: 'a', children: [\n            //  {path: 'b', component: B},\n            //  {path: 'c', component: C},\n            // ]}\n            // Notice that the children of the named outlet are configured with the primary outlet\n            return this.processSegment(\n              childInjector,\n              childConfig,\n              segmentGroup,\n              slicedSegments,\n              matchedOnOutlet ? PRIMARY_OUTLET : outlet,\n              true,\n              snapshot,\n            ).pipe(\n              map((child) => {\n                return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n              }),\n            );\n          }),\n        );\n      }),\n    );\n  }\n  private getChildConfig(\n    injector: EnvironmentInjector,\n    route: Route,\n    segments: UrlSegment[],\n  ): Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(\n        mergeMap((shouldLoadResult: boolean) => {\n          if (shouldLoadResult) {\n            return this.configLoader.loadChildren(injector, route).pipe(\n              tap((cfg: LoadedRouterConfig) => {\n                route._loadedRoutes = cfg.routes;\n                route._loadedInjector = cfg.injector;\n              }),\n            );\n          }\n          return canLoadFails(route);\n        }),\n      );\n    }\n\n    return of({routes: [], injector});\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(\n  nodes: Array<TreeNode<ActivatedRouteSnapshot>>,\n): Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode = result.find(\n      (resultNode) => node.value.routeConfig === resultNode.value.routeConfig,\n    );\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n      const c = n.value.url.map((s) => s.toString()).join('/');\n      throw new RuntimeError(\n        RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Two segments cannot have the same outlet name: '${p}' and '${c}'.`,\n      );\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\n\nimport type {Route} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {recognize as recognizeFn} from '../recognize';\nimport type {RouterConfigLoader} from '../router_config_loader';\nimport type {UrlSerializer} from '../url_tree';\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Route[],\n  serializer: UrlSerializer,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) =>\n    recognizeFn(\n      injector,\n      configLoader,\n      rootComponentType,\n      config,\n      t.extractedUrl,\n      serializer,\n      paramsInheritanceStrategy,\n    ).pipe(\n      map(({state: targetSnapshot, tree: urlAfterRedirects}) => {\n        return {...t, targetSnapshot, urlAfterRedirects};\n      }),\n    ),\n  );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {EMPTY, from, MonoTypeOperatorFunction, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, map, mergeMap, takeLast, tap} from 'rxjs/operators';\n\nimport {RedirectCommand, ResolveData} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  hasStaticTitle,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {RouteTitleKey} from '../shared';\nimport {getDataKeys, wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {getTokenOrFunctionIdentity} from '../utils/preactivation';\nimport {isEmptyError} from '../utils/type_guards';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport {DefaultUrlSerializer} from '../url_tree';\n\nexport function resolveData(\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      guards: {canActivateChecks},\n    } = t;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n    // preserve the correct order that the resolvers should run in.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n    const routesNeedingDataUpdates = new Set<ActivatedRouteSnapshot>();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      // All children under the route with a resolver to run need to recompute inherited data.\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(\n      concatMap((route) => {\n        if (routesWithResolversToRun.has(route)) {\n          return runResolve(route, targetSnapshot!, paramsInheritanceStrategy, injector);\n        } else {\n          route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n          return of(void 0);\n        }\n      }),\n      tap(() => routesProcessed++),\n      takeLast(1),\n      mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)),\n    );\n  });\n}\n\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot[] {\n  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\n\nfunction runResolve(\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(\n    map((resolvedData: any) => {\n      futureARS._resolvedData = resolvedData;\n      futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n      return null;\n    }),\n  );\n}\n\nfunction resolveNode(\n  resolve: ResolveData,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data: {[k: string | symbol]: any} = {};\n  return from(keys).pipe(\n    mergeMap((key) =>\n      getResolver(resolve[key], futureARS, futureRSS, injector).pipe(\n        first(),\n        tap((value: any) => {\n          if (value instanceof RedirectCommand) {\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n          }\n          data[key] = value;\n        }),\n      ),\n    ),\n    takeLast(1),\n    map(() => data),\n    catchError((e: unknown) => (isEmptyError(e as Error) ? EMPTY : throwError(e))),\n  );\n}\n\nfunction getResolver(\n  injectionToken: ProviderToken<any> | Function,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve\n    ? resolver.resolve(futureARS, futureRSS)\n    : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(\n  next: (x: T) => void | ObservableInput<any>,\n): MonoTypeOperatorFunction<T> {\n  return switchMap((v) => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\nimport {Title} from '@angular/platform-browser';\n\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET, RouteTitleKey} from './shared';\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```ts\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/routing/common-router-tasks#setting-the-page-title)\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy)})\nexport abstract class TitleStrategy {\n  /** Performs the application title update. */\n  abstract updateTitle(snapshot: RouterStateSnapshot): void;\n\n  /**\n   * @returns The `title` of the deepest primary route.\n   */\n  buildTitle(snapshot: RouterStateSnapshot): string | undefined {\n    let pageTitle: string | undefined;\n    let route: ActivatedRouteSnapshot | undefined = snapshot.root;\n    while (route !== undefined) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n\n  /**\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\n   * `Route.title` property, which can either be a static string or a resolved value.\n   */\n  getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n}\n\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultTitleStrategy extends TitleStrategy {\n  constructor(readonly title: Title) {\n    super();\n  }\n\n  /**\n   * Sets the title of the browser to the given value.\n   *\n   * @param title The `pageTitle` from the deepest primary route.\n   */\n  override updateTitle(snapshot: RouterStateSnapshot): void {\n    const title = this.buildTitle(snapshot);\n    if (title !== undefined) {\n      this.title.setTitle(title);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\nimport {OnSameUrlNavigation, QueryParamsHandling, RedirectCommand} from './models';\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabledNonBlocking' - (default) The initial navigation starts after the\n * root component has been created. The bootstrap is not blocked on the completion of the initial\n * navigation.\n * * 'enabledBlocking' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value should be set in\n * case you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration)\n * for your application.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * @see {@link /api/router/RouterModule#forRoot forRoot}\n *\n * @publicApi\n */\nexport type InitialNavigation = 'disabled' | 'enabledBlocking' | 'enabledNonBlocking';\n\n/**\n * Extra configuration options that can be used with the `withRouterConfig` function.\n *\n * @publicApi\n */\nexport interface RouterConfigOptions {\n  /**\n   * Configures how the Router attempts to restore state when a navigation is cancelled.\n   *\n   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n   * router before the navigation started. This means that if the URL of the browser is updated\n   * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n   * than trying to restore to the previous location in the session history. This happens most\n   * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n   * buttons.\n   *\n   * 'computed' - Will attempt to return to the same index in the session history that corresponds\n   * to the Angular route when the navigation gets cancelled. For example, if the browser back\n   * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n   * and vice versa.\n   *\n   * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n   * handles a portion of the URL because the history restoration navigates to the previous place in\n   * the browser history rather than simply resetting a portion of the URL.\n   *\n   * The default value is `replace` when not set.\n   */\n  canceledNavigationResolution?: 'replace' | 'computed';\n\n  /**\n   * Configures the default for handling a navigation request to the current URL.\n   *\n   * If unset, the `Router` will use `'ignore'`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes.\n   *\n   * By default ('emptyOnly'), a route inherits the parent route's parameters when the route itself\n   * has an empty path (meaning its configured with path: '') or when the parent route doesn't have\n   * any component set.\n   *\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   *\n   * Note that when dealing with matrix parameters, \"parent\" refers to the parent `Route`\n   * config which does not necessarily mean the \"URL segment to the left\". When the `Route` `path`\n   * contains multiple segments, the matrix parameters must appear on the last segment. For example,\n   * matrix parameters for `{path: 'a/b', component: MyComp}` should appear as `a/b;foo=bar` and not\n   * `a;foo=bar/b`.\n   *\n   */\n  paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   */\n  urlUpdateStrategy?: 'deferred' | 'eager';\n\n  /**\n   * The default strategy to use for handling query params in `Router.createUrlTree` when one is not provided.\n   *\n   * The `createUrlTree` method is used internally by `Router.navigate` and `RouterLink`.\n   * Note that `QueryParamsHandling` does not apply to `Router.navigateByUrl`.\n   *\n   * When neither the default nor the queryParamsHandling option is specified in the call to `createUrlTree`,\n   * the current parameters will be replaced by new parameters.\n   *\n   * @see {@link Router#createUrlTree}\n   * @see {@link QueryParamsHandling}\n   */\n  defaultQueryParamsHandling?: QueryParamsHandling;\n\n  /**\n   * When `true`, the `Promise` will instead resolve with `false`, as it does with other failed\n   * navigations (for example, when guards are rejected).\n\n   * Otherwise the `Promise` returned by the Router's navigation with be rejected\n   * if an error occurs.\n   */\n  resolveNavigationPromiseOnError?: boolean;\n}\n\n/**\n * Configuration options for the scrolling feature which can be used with `withInMemoryScrolling`\n * function.\n *\n * @publicApi\n */\nexport interface InMemoryScrollingOptions {\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   */\n  anchorScrolling?: 'disabled' | 'enabled';\n\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```ts\n   * class AppComponent {\n   *   movieData: any;\n   *\n   *   constructor(private router: Router, private viewportScroller: ViewportScroller,\n   * changeDetectorRef: ChangeDetectorRef) {\n   *   router.events.pipe(filter((event: Event): event is Scroll => event instanceof Scroll)\n   *     ).subscribe(e => {\n   *       fetch('http://example.com/movies.json').then(response => {\n   *         this.movieData = response.json();\n   *         // update the template with the data before restoring scroll\n   *         changeDetectorRef.detectChanges();\n   *\n   *         if (e.position) {\n   *           viewportScroller.scrollToPosition(e.position);\n   *         }\n   *       });\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n}\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see {@link /api/router/routerModule#forRoot forRoot}\n *\n *\n * @publicApi\n */\nexport interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * One of `enabled`, `enabledBlocking`, `enabledNonBlocking` or `disabled`.\n   * When set to `enabled` or `enabledBlocking`, the initial navigation starts before the root\n   * component is created. The bootstrap is blocked until the initial navigation is complete. This\n   * value should be set in case you use [server-side rendering](guide/ssr), but do not enable\n   * [hydration](guide/hydration) for your application. When set to `enabledNonBlocking`,\n   * the initial navigation starts after the root component has been created.\n   * The bootstrap is not blocked on the completion of the initial navigation. When set to\n   * `disabled`, the initial navigation is not performed. The location listener is set up before the\n   * root component gets created. Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * When true, enables binding information from the `Router` state directly to the inputs of the\n   * component in `Route` configurations.\n   */\n  bindToComponentInputs?: boolean;\n\n  /**\n   * When true, enables view transitions in the Router by running the route activation and\n   * deactivation inside of `document.startViewTransition`.\n   *\n   * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n   * @experimental\n   */\n  enableViewTransitions?: boolean;\n\n  /**\n   * A custom error handler for failed navigations.\n   * If the handler returns a value, the navigation Promise is resolved with this value.\n   * If the handler throws an exception, the navigation Promise is rejected with the exception.\n   *\n   * @see RouterConfigOptions\n   */\n  errorHandler?: (error: any) => RedirectCommand | any;\n\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   */\n  preloadingStrategy?: any;\n\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   */\n  scrollOffset?: [number, number] | (() => [number, number]);\n}\n\n/**\n * A DI token for the router service.\n *\n * @publicApi\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '',\n  {\n    providedIn: 'root',\n    factory: () => ({}),\n  },\n);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Component} from '@angular/core';\n\nimport {RouterOutlet} from '../directives/router_outlet';\nimport {PRIMARY_OUTLET} from '../shared';\nimport {Route} from '../models';\nexport {ɵEmptyOutletComponent as EmptyOutletComponent};\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({\n  template: `<router-outlet/>`,\n  imports: [RouterOutlet],\n  // Used to avoid component ID collisions with user code.\n  exportAs: 'emptyRouterOutlet',\n})\nexport class ɵEmptyOutletComponent {}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if (\n    !c.component &&\n    !c.loadComponent &&\n    (children || c.loadChildren) &&\n    c.outlet &&\n    c.outlet !== PRIMARY_OUTLET\n  ) {\n    c.component = ɵEmptyOutletComponent;\n  }\n  return c;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Compiler,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgModuleFactory,\n  Type,\n} from '@angular/core';\nimport {ConnectableObservable, from, Observable, of, Subject} from 'rxjs';\nimport {finalize, map, mergeMap, refCount, tap} from 'rxjs/operators';\n\nimport {DefaultExport, LoadedRouterConfig, Route, Routes} from './models';\nimport {wrapIntoObservable} from './utils/collection';\nimport {assertStandalone, validateConfig} from './utils/config';\nimport {standardizeConfig} from './components/empty_outlet';\n\n/**\n * The DI token for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>(ngDevMode ? 'ROUTES' : '');\n\ntype ComponentLoader = Observable<Type<unknown>>;\n\n@Injectable({providedIn: 'root'})\nexport class RouterConfigLoader {\n  private componentLoaders = new WeakMap<Route, ComponentLoader>();\n  private childrenLoaders = new WeakMap<Route, Observable<LoadedRouterConfig>>();\n  onLoadStartListener?: (r: Route) => void;\n  onLoadEndListener?: (r: Route) => void;\n  private readonly compiler = inject(Compiler);\n\n  loadComponent(route: Route): Observable<Type<unknown>> {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route)!;\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent!()).pipe(\n      map(maybeUnwrapDefaultExport),\n      tap((component) => {\n        if (this.onLoadEndListener) {\n          this.onLoadEndListener(route);\n        }\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          assertStandalone(route.path ?? '', component);\n        route._loadedComponent = component;\n      }),\n      finalize(() => {\n        this.componentLoaders.delete(route);\n      }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject<Type<unknown>>()).pipe(\n      refCount(),\n    );\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n\n  loadChildren(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route)!;\n    } else if (route._loadedRoutes) {\n      return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ = loadChildren(\n      route,\n      this.compiler,\n      parentInjector,\n      this.onLoadEndListener,\n    );\n    const loadRunner = moduleFactoryOrRoutes$.pipe(\n      finalize(() => {\n        this.childrenLoaders.delete(route);\n      }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(\n      loadRunner,\n      () => new Subject<LoadedRouterConfig>(),\n    ).pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n}\n\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nexport function loadChildren(\n  route: Route,\n  compiler: Compiler,\n  parentInjector: Injector,\n  onLoadEndListener?: (r: Route) => void,\n): Observable<LoadedRouterConfig> {\n  return wrapIntoObservable(route.loadChildren!()).pipe(\n    map(maybeUnwrapDefaultExport),\n    mergeMap((t) => {\n      if (t instanceof NgModuleFactory || Array.isArray(t)) {\n        return of(t);\n      } else {\n        return from(compiler.compileModuleAsync(t));\n      }\n    }),\n    map((factoryOrRoutes: NgModuleFactory<any> | Routes) => {\n      if (onLoadEndListener) {\n        onLoadEndListener(route);\n      }\n      // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n      // no injector associated with lazy loading a `Route` array.\n      let injector: EnvironmentInjector | undefined;\n      let rawRoutes: Route[];\n      let requireStandaloneComponents = false;\n      if (Array.isArray(factoryOrRoutes)) {\n        rawRoutes = factoryOrRoutes;\n        requireStandaloneComponents = true;\n      } else {\n        injector = factoryOrRoutes.create(parentInjector).injector;\n        // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n        // will get stuck in an infinite loop. The child module's Injector will look to\n        // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n        // for it's parent module instead.\n        rawRoutes = injector.get(ROUTES, [], {optional: true, self: true}).flat();\n      }\n      const routes = rawRoutes.map(standardizeConfig);\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        validateConfig(routes, route.path, requireStandaloneComponents);\n      return {routes, injector};\n    }),\n  );\n}\n\nfunction isWrappedDefaultExport<T>(value: T | DefaultExport<T>): value is DefaultExport<T> {\n  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n  // `default` will be a renamed property.\n  return value && typeof value === 'object' && 'default' in value;\n}\n\nfunction maybeUnwrapDefaultExport<T>(input: T | DefaultExport<T>): T {\n  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n  // subject to property renaming, so we reference it with bracket access.\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy)})\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean {\n    return true;\n  }\n  extract(url: UrlTree): UrlTree {\n    return url;\n  }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree {\n    return newUrlPart;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/// <reference types=\"dom-view-transitions\" />\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  afterNextRender,\n  InjectionToken,\n  Injector,\n  NgZone,\n  runInInjectionContext,\n} from '@angular/core';\n\nimport {ActivatedRouteSnapshot} from '../router_state';\n\nexport const CREATE_VIEW_TRANSITION = new InjectionToken<typeof createViewTransition>(\n  ngDevMode ? 'view transition helper' : '',\n);\nexport const VIEW_TRANSITION_OPTIONS = new InjectionToken<\n  ViewTransitionsFeatureOptions & {skipNextTransition: boolean}\n>(ngDevMode ? 'view transition options' : '');\n\n/**\n * Options to configure the View Transitions integration in the Router.\n *\n * @experimental\n * @publicApi\n * @see withViewTransitions\n */\nexport interface ViewTransitionsFeatureOptions {\n  /**\n   * Skips the very first call to `startViewTransition`. This can be useful for disabling the\n   * animation during the application's initial loading phase.\n   */\n  skipInitialTransition?: boolean;\n\n  /**\n   * A function to run after the `ViewTransition` is created.\n   *\n   * This function is run in an injection context and can use `inject`.\n   */\n  onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;\n}\n\n/**\n * The information passed to the `onViewTransitionCreated` function provided in the\n * `withViewTransitions` feature options.\n *\n * @publicApi\n * @experimental\n */\nexport interface ViewTransitionInfo {\n  // TODO(atscott): This type can/should be the built-in `ViewTransition` type\n  // from @types/dom-view-transitions but exporting that type from the public API is currently not\n  // supported by tooling.\n  /**\n   * The `ViewTransition` returned by the call to `startViewTransition`.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition\n   */\n  transition: {\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/finished\n     */\n    finished: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/ready\n     */\n    ready: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/updateCallbackDone\n     */\n    updateCallbackDone: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/skipTransition\n     */\n    skipTransition(): void;\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition#browser_compatibility\n     * @see https://developer.chrome.com/docs/web-platform/view-transitions/same-document#default_style_and_transition_reference\n     */\n    readonly types: Set<string>;\n  };\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning from.\n   */\n  from: ActivatedRouteSnapshot;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning to.\n   */\n  to: ActivatedRouteSnapshot;\n}\n\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nexport function createViewTransition(\n  injector: Injector,\n  from: ActivatedRouteSnapshot,\n  to: ActivatedRouteSnapshot,\n): Promise<void> {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  // Create promises outside the Angular zone to avoid causing extra change detections\n  return injector.get(NgZone).runOutsideAngular(() => {\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n      transitionOptions.skipNextTransition = false;\n      // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n      // until the current event loop exits so we use a promise resolved in a timeout instead\n      // of Promise.resolve().\n      return new Promise((resolve) => setTimeout(resolve));\n    }\n\n    let resolveViewTransitionStarted: () => void;\n    const viewTransitionStarted = new Promise<void>((resolve) => {\n      resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n      resolveViewTransitionStarted();\n      // We don't actually update dom within the transition callback. The resolving of the above\n      // promise unblocks the Router navigation, which synchronously activates and deactivates\n      // routes (the DOM update). This view transition waits for the next change detection to\n      // complete (below), which includes the update phase of the routed components.\n      return createRenderPromise(injector);\n      // TODO(atscott): Types in DefinitelyTyped are not up-to-date\n    }) as ViewTransition & {readonly types: Set<string>};\n    const {onViewTransitionCreated} = transitionOptions;\n    if (onViewTransitionCreated) {\n      runInInjectionContext(injector, () => onViewTransitionCreated({transition, from, to}));\n    }\n    return viewTransitionStarted;\n  });\n}\n\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector: Injector) {\n  return new Promise<void>((resolve) => {\n    // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n    // This ensures any follow-up renders in the microtask queue are completed before the\n    // view transition starts animating.\n    afterNextRender({read: () => setTimeout(resolve)}, {injector});\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  DestroyRef,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  runInInjectionContext,\n  Type,\n} from '@angular/core';\nimport {BehaviorSubject, combineLatest, EMPTY, from, Observable, of, Subject} from 'rxjs';\nimport {\n  catchError,\n  defaultIfEmpty,\n  filter,\n  finalize,\n  map,\n  switchMap,\n  take,\n  takeUntil,\n  tap,\n} from 'rxjs/operators';\n\nimport {createRouterState} from './create_router_state';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {\n  BeforeActivateRoutes,\n  Event,\n  GuardsCheckEnd,\n  GuardsCheckStart,\n  IMPERATIVE_NAVIGATION,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  NavigationTrigger,\n  RedirectRequest,\n  ResolveEnd,\n  ResolveStart,\n  RouteConfigLoadEnd,\n  RouteConfigLoadStart,\n  RoutesRecognized,\n} from './events';\nimport {\n  GuardResult,\n  NavigationBehaviorOptions,\n  QueryParamsHandling,\n  RedirectCommand,\n  Route,\n  Routes,\n} from './models';\nimport {\n  isNavigationCancelingError,\n  isRedirectingNavigationCancelingError,\n  redirectingNavigationError,\n} from './navigation_canceling_error';\nimport {activateRoutes} from './operators/activate_routes';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {TitleStrategy} from './page_title_strategy';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  createEmptyState,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport type {Params} from './shared';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\nimport {CREATE_VIEW_TRANSITION} from './utils/view_transition';\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#createUrlTree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n *\n * @publicApi\n */\nexport interface UrlCreationOptions {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```ts\n   *  @Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   *\n   * A value of `null` or `undefined` indicates that the navigation commands should be applied\n   * relative to the root.\n   */\n  relativeTo?: ActivatedRoute | null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params | null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `preserve` : Preserve current parameters.\n   * * `merge` : Merge new with current parameters.\n   *\n   * The \"preserve\" option discards any new query params:\n   * ```\n   * // from /view1?page=1 to/view2?page=1\n   * router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n   * });\n   * ```\n   * The \"merge\" option appends new query params to the params from the current URL:\n   * ```\n   * // from /view1?page=1 to/view2?page=1&otherKey=2\n   * router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n   * });\n   * ```\n   * In case of a key collision between current parameters and those in the `queryParams` object,\n   * the new value is used.\n   *\n   */\n  queryParamsHandling?: QueryParamsHandling | null;\n\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see {@link Router#createurltree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n * @see {@link UrlCreationOptions}\n * @see {@link NavigationBehaviorOptions}\n *\n * @publicApi\n */\nexport interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {}\n\nexport type RestoredState = {\n  [k: string]: any;\n  // TODO(#27607): Remove `navigationId` and `ɵrouterPageId` and move to `ng` or `ɵ` namespace.\n  navigationId: number;\n  // The `ɵ` prefix is there to reduce the chance of colliding with any existing user properties on\n  // the history state.\n  ɵrouterPageId?: number;\n};\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport interface Navigation {\n  /**\n   * The unique identifier of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlHandlingStrategy.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * `UrlTree` to use when updating the browser URL for the navigation when `extras.browserUrl` is\n   * defined.\n   * @internal\n   */\n  readonly targetBrowserUrl?: UrlTree | string;\n  /**\n   * TODO(atscott): If we want to make StateManager public, they will need access to this. Note that\n   * it's already eventually exposed through router.routerState.\n   * @internal\n   */\n  targetRouterState?: RouterState;\n  /**\n   * Identifies how this navigation was triggered.\n   *\n   * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--Triggered by a popstate event.\n   * * 'hashchange'--Triggered by a hashchange event.\n   */\n  trigger: 'imperative' | 'popstate' | 'hashchange';\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation | null;\n}\n\nexport interface NavigationTransition {\n  id: number;\n  currentUrlTree: UrlTree;\n  extractedUrl: UrlTree;\n  currentRawUrl: UrlTree;\n  urlAfterRedirects?: UrlTree;\n  rawUrl: UrlTree;\n  extras: NavigationExtras;\n  resolve: (value: boolean | PromiseLike<boolean>) => void;\n  reject: (reason?: any) => void;\n  promise: Promise<boolean>;\n  source: NavigationTrigger;\n  restoredState: RestoredState | null;\n  currentSnapshot: RouterStateSnapshot;\n  targetSnapshot: RouterStateSnapshot | null;\n  currentRouterState: RouterState;\n  targetRouterState: RouterState | null;\n  guards: Checks;\n  guardsResult: GuardResult | null;\n}\n\n/**\n * The interface from the Router needed by the transitions. Used to avoid a circular dependency on\n * Router. This interface should be whittled down with future refactors. For example, we do not need\n * to get `UrlSerializer` from the Router. We can instead inject it in `NavigationTransitions`\n * directly.\n */\ninterface InternalRouterInterface {\n  config: Routes;\n  navigated: boolean;\n  routeReuseStrategy: RouteReuseStrategy;\n  onSameUrlNavigation: 'reload' | 'ignore';\n}\n\nexport const NAVIGATION_ERROR_HANDLER = new InjectionToken<\n  (error: NavigationError) => unknown | RedirectCommand\n>(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\n\n@Injectable({providedIn: 'root'})\nexport class NavigationTransitions {\n  currentNavigation: Navigation | null = null;\n  currentTransition: NavigationTransition | null = null;\n  lastSuccessfulNavigation: Navigation | null = null;\n  /**\n   * These events are used to communicate back to the Router about the state of the transition. The\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n   * class is not public, this event subject is not publicly exposed.\n   */\n  readonly events = new Subject<Event | BeforeActivateRoutes | RedirectRequest>();\n  /**\n   * Used to abort the current transition with an error.\n   */\n  readonly transitionAbortSubject = new Subject<Error>();\n  private readonly configLoader = inject(RouterConfigLoader);\n  private readonly environmentInjector = inject(EnvironmentInjector);\n  private readonly destroyRef = inject(DestroyRef);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly rootContexts = inject(ChildrenOutletContexts);\n  private readonly location = inject(Location);\n  private readonly inputBindingEnabled = inject(INPUT_BINDER, {optional: true}) !== null;\n  private readonly titleStrategy?: TitleStrategy = inject(TitleStrategy);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly paramsInheritanceStrategy =\n    this.options.paramsInheritanceStrategy || 'emptyOnly';\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private readonly createViewTransition = inject(CREATE_VIEW_TRANSITION, {optional: true});\n  private readonly navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {optional: true});\n\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  private transitions?: BehaviorSubject<NavigationTransition | null>;\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation: () => Observable<void> = () => of(void 0);\n  /** @internal */\n  rootComponentType: Type<any> | null = null;\n\n  private destroyed = false;\n\n  constructor() {\n    const onLoadStart = (r: Route) => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  complete() {\n    this.transitions?.complete();\n  }\n\n  handleNavigationRequest(\n    request: Pick<\n      NavigationTransition,\n      | 'source'\n      | 'restoredState'\n      | 'currentUrlTree'\n      | 'currentRawUrl'\n      | 'rawUrl'\n      | 'extras'\n      | 'resolve'\n      | 'reject'\n      | 'promise'\n      | 'currentSnapshot'\n      | 'currentRouterState'\n    >,\n  ) {\n    const id = ++this.navigationId;\n    this.transitions?.next({\n      ...request,\n      extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n      targetSnapshot: null,\n      targetRouterState: null,\n      guards: {canActivateChecks: [], canDeactivateChecks: []},\n      guardsResult: null,\n      id,\n    });\n  }\n\n  setupNavigations(router: InternalRouterInterface): Observable<NavigationTransition> {\n    this.transitions = new BehaviorSubject<NavigationTransition | null>(null);\n    return this.transitions.pipe(\n      filter((t): t is NavigationTransition => t !== null),\n\n      // Using switchMap so we cancel executing navigations when a new one comes in\n      switchMap((overallTransitionState) => {\n        let completed = false;\n        let errored = false;\n        return of(overallTransitionState).pipe(\n          switchMap((t) => {\n            // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n            // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n            // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n            // https://github.com/ReactiveX/rxjs/issues/7455\n            if (this.navigationId > overallTransitionState.id) {\n              const cancellationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancellationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n              return EMPTY;\n            }\n            this.currentTransition = overallTransitionState;\n            // Store the Navigation object\n            this.currentNavigation = {\n              id: t.id,\n              initialUrl: t.rawUrl,\n              extractedUrl: t.extractedUrl,\n              targetBrowserUrl:\n                typeof t.extras.browserUrl === 'string'\n                  ? this.urlSerializer.parse(t.extras.browserUrl)\n                  : t.extras.browserUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: !this.lastSuccessfulNavigation\n                ? null\n                : {\n                    ...this.lastSuccessfulNavigation,\n                    previousNavigation: null,\n                  },\n            };\n            const urlTransition =\n              !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n\n            const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n            if (!urlTransition && onSameUrlNavigation !== 'reload') {\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.rawUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredSameUrlNavigation,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n\n            if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n              return of(t).pipe(\n                // Fire NavigationStart event\n                switchMap((t) => {\n                  this.events.next(\n                    new NavigationStart(\n                      t.id,\n                      this.urlSerializer.serialize(t.extractedUrl),\n                      t.source,\n                      t.restoredState,\n                    ),\n                  );\n                  if (t.id !== this.navigationId) {\n                    return EMPTY;\n                  }\n\n                  // This delay is required to match old behavior that forced\n                  // navigation to always be async\n                  return Promise.resolve(t);\n                }),\n\n                // Recognize\n                recognize(\n                  this.environmentInjector,\n                  this.configLoader,\n                  this.rootComponentType,\n                  router.config,\n                  this.urlSerializer,\n                  this.paramsInheritanceStrategy,\n                ),\n\n                // Update URL if in `eager` update mode\n                tap((t) => {\n                  overallTransitionState.targetSnapshot = t.targetSnapshot;\n                  overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                  this.currentNavigation = {\n                    ...this.currentNavigation!,\n                    finalUrl: t.urlAfterRedirects,\n                  };\n\n                  // Fire RoutesRecognized\n                  const routesRecognized = new RoutesRecognized(\n                    t.id,\n                    this.urlSerializer.serialize(t.extractedUrl),\n                    this.urlSerializer.serialize(t.urlAfterRedirects!),\n                    t.targetSnapshot!,\n                  );\n                  this.events.next(routesRecognized);\n                }),\n              );\n            } else if (\n              urlTransition &&\n              this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)\n            ) {\n              /* When the current URL shouldn't be processed, but the previous one\n               * was, we handle this \"error condition\" by navigating to the\n               * previously successful URL, but leaving the URL intact.*/\n              const {id, extractedUrl, source, restoredState, extras} = t;\n              const navStart = new NavigationStart(\n                id,\n                this.urlSerializer.serialize(extractedUrl),\n                source,\n                restoredState,\n              );\n              this.events.next(navStart);\n              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n\n              this.currentTransition = overallTransitionState = {\n                ...t,\n                targetSnapshot,\n                urlAfterRedirects: extractedUrl,\n                extras: {...extras, skipLocationChange: false, replaceUrl: false},\n              };\n              this.currentNavigation!.finalUrl = extractedUrl;\n              return of(overallTransitionState);\n            } else {\n              /* When neither the current or previous URL can be processed, do\n               * nothing other than update router's internal reference to the\n               * current \"settled\" URL. This way the next navigation will be coming\n               * from the current URL in the browser.\n               */\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation was ignored because the UrlHandlingStrategy` +\n                    ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredByUrlHandlingStrategy,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n          }),\n\n          // --- GUARDS ---\n          tap((t) => {\n            const guardsStart = new GuardsCheckStart(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n            );\n            this.events.next(guardsStart);\n          }),\n\n          map((t) => {\n            this.currentTransition = overallTransitionState = {\n              ...t,\n              guards: getAllRouteGuards(t.targetSnapshot!, t.currentSnapshot, this.rootContexts),\n            };\n            return overallTransitionState;\n          }),\n\n          checkGuards(this.environmentInjector, (evt: Event) => this.events.next(evt)),\n          tap((t) => {\n            overallTransitionState.guardsResult = t.guardsResult;\n            if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n            }\n\n            const guardsEnd = new GuardsCheckEnd(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n              !!t.guardsResult,\n            );\n            this.events.next(guardsEnd);\n          }),\n\n          filter((t) => {\n            if (!t.guardsResult) {\n              this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n              return false;\n            }\n            return true;\n          }),\n\n          // --- RESOLVE ---\n          switchTap((t) => {\n            if (t.guards.canActivateChecks.length === 0) {\n              return undefined;\n            }\n\n            return of(t).pipe(\n              tap((t) => {\n                const resolveStart = new ResolveStart(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                  t.targetSnapshot!,\n                );\n                this.events.next(resolveStart);\n              }),\n              switchMap((t) => {\n                let dataResolved = false;\n                return of(t).pipe(\n                  resolveData(this.paramsInheritanceStrategy, this.environmentInjector),\n                  tap({\n                    next: () => (dataResolved = true),\n                    complete: () => {\n                      if (!dataResolved) {\n                        this.cancelNavigationTransition(\n                          t,\n                          typeof ngDevMode === 'undefined' || ngDevMode\n                            ? `At least one route resolver didn't emit any value.`\n                            : '',\n                          NavigationCancellationCode.NoDataFromResolver,\n                        );\n                      }\n                    },\n                  }),\n                );\n              }),\n              tap((t) => {\n                const resolveEnd = new ResolveEnd(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                  t.targetSnapshot!,\n                );\n                this.events.next(resolveEnd);\n              }),\n            );\n          }),\n\n          // --- LOAD COMPONENTS ---\n          switchTap((t: NavigationTransition) => {\n            const loadComponents = (route: ActivatedRouteSnapshot): Array<Observable<void>> => {\n              const loaders: Array<Observable<void>> = [];\n              if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\n                loaders.push(\n                  this.configLoader.loadComponent(route.routeConfig).pipe(\n                    tap((loadedComponent) => {\n                      route.component = loadedComponent;\n                    }),\n                    map(() => void 0),\n                  ),\n                );\n              }\n              for (const child of route.children) {\n                loaders.push(...loadComponents(child));\n              }\n              return loaders;\n            };\n            return combineLatest(loadComponents(t.targetSnapshot!.root)).pipe(\n              defaultIfEmpty(null),\n              take(1),\n            );\n          }),\n\n          switchTap(() => this.afterPreactivation()),\n\n          switchMap(() => {\n            const {currentSnapshot, targetSnapshot} = overallTransitionState;\n            const viewTransitionStarted = this.createViewTransition?.(\n              this.environmentInjector,\n              currentSnapshot.root,\n              targetSnapshot!.root,\n            );\n\n            // If view transitions are enabled, block the navigation until the view\n            // transition callback starts. Otherwise, continue immediately.\n            return viewTransitionStarted\n              ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\n              : of(overallTransitionState);\n          }),\n\n          map((t: NavigationTransition) => {\n            const targetRouterState = createRouterState(\n              router.routeReuseStrategy,\n              t.targetSnapshot!,\n              t.currentRouterState,\n            );\n            this.currentTransition = overallTransitionState = {...t, targetRouterState};\n            this.currentNavigation!.targetRouterState = targetRouterState;\n            return overallTransitionState;\n          }),\n\n          tap(() => {\n            this.events.next(new BeforeActivateRoutes());\n          }),\n\n          activateRoutes(\n            this.rootContexts,\n            router.routeReuseStrategy,\n            (evt: Event) => this.events.next(evt),\n            this.inputBindingEnabled,\n          ),\n\n          // Ensure that if some observable used to drive the transition doesn't\n          // complete, the navigation still finalizes This should never happen, but\n          // this is done as a safety measure to avoid surfacing this error (#49567).\n          take(1),\n\n          tap({\n            next: (t: NavigationTransition) => {\n              completed = true;\n              this.lastSuccessfulNavigation = this.currentNavigation;\n              this.events.next(\n                new NavigationEnd(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                ),\n              );\n              this.titleStrategy?.updateTitle(t.targetRouterState!.snapshot);\n              t.resolve(true);\n            },\n            complete: () => {\n              completed = true;\n            },\n          }),\n\n          // There used to be a lot more logic happening directly within the\n          // transition Observable. Some of this logic has been refactored out to\n          // other places but there may still be errors that happen there. This gives\n          // us a way to cancel the transition from the outside. This may also be\n          // required in the future to support something like the abort signal of the\n          // Navigation API where the navigation gets aborted from outside the\n          // transition.\n          takeUntil(\n            this.transitionAbortSubject.pipe(\n              tap((err) => {\n                throw err;\n              }),\n            ),\n          ),\n\n          finalize(() => {\n            /* When the navigation stream finishes either through error or success,\n             * we set the `completed` or `errored` flag. However, there are some\n             * situations where we could get here without either of those being set.\n             * For instance, a redirect during NavigationStart. Therefore, this is a\n             * catch-all to make sure the NavigationCancel event is fired when a\n             * navigation gets cancelled but not caught by other means. */\n            if (!completed && !errored) {\n              const cancelationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancelationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n            }\n            // Only clear current navigation if it is still set to the one that\n            // finalized.\n            if (this.currentTransition?.id === overallTransitionState.id) {\n              this.currentNavigation = null;\n              this.currentTransition = null;\n            }\n          }),\n          catchError((e) => {\n            // If the application is already destroyed, the catch block should not\n            // execute anything in practice because other resources have already\n            // been released and destroyed.\n            if (this.destroyed) {\n              overallTransitionState.resolve(false);\n              return EMPTY;\n            }\n\n            errored = true;\n            /* This error type is issued during Redirect, and is handled as a\n             * cancellation rather than an error. */\n            if (isNavigationCancelingError(e)) {\n              this.events.next(\n                new NavigationCancel(\n                  overallTransitionState.id,\n                  this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                  e.message,\n                  e.cancellationCode,\n                ),\n              );\n\n              // When redirecting, we need to delay resolving the navigation\n              // promise and push it to the redirect navigation\n              if (!isRedirectingNavigationCancelingError(e)) {\n                overallTransitionState.resolve(false);\n              } else {\n                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n              }\n\n              /* All other errors should reset to the router's internal URL reference\n               * to the pre-error state. */\n            } else {\n              const navigationError = new NavigationError(\n                overallTransitionState.id,\n                this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                e,\n                overallTransitionState.targetSnapshot ?? undefined,\n              );\n\n              try {\n                const navigationErrorHandlerResult = runInInjectionContext(\n                  this.environmentInjector,\n                  () => this.navigationErrorHandler?.(navigationError),\n                );\n\n                if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                  const {message, cancellationCode} = redirectingNavigationError(\n                    this.urlSerializer,\n                    navigationErrorHandlerResult,\n                  );\n                  this.events.next(\n                    new NavigationCancel(\n                      overallTransitionState.id,\n                      this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                      message,\n                      cancellationCode,\n                    ),\n                  );\n                  this.events.next(\n                    new RedirectRequest(\n                      navigationErrorHandlerResult.redirectTo,\n                      navigationErrorHandlerResult.navigationBehaviorOptions,\n                    ),\n                  );\n                } else {\n                  this.events.next(navigationError);\n                  throw e;\n                }\n              } catch (ee) {\n                // TODO(atscott): consider flipping the default behavior of\n                // resolveNavigationPromiseOnError to be `resolve(false)` when\n                // undefined. This is the most sane thing to do given that\n                // applications very rarely handle the promise rejection and, as a\n                // result, would get \"unhandled promise rejection\" console logs.\n                // The vast majority of applications would not be affected by this\n                // change so omitting a migration seems reasonable. Instead,\n                // applications that rely on rejection can specifically opt-in to the\n                // old behavior.\n                if (this.options.resolveNavigationPromiseOnError) {\n                  overallTransitionState.resolve(false);\n                } else {\n                  overallTransitionState.reject(ee);\n                }\n              }\n            }\n\n            return EMPTY;\n          }),\n        );\n        // casting because `pipe` returns observable({}) when called with 8+ arguments\n      }),\n    ) as Observable<NavigationTransition>;\n  }\n\n  private cancelNavigationTransition(\n    t: NavigationTransition,\n    reason: string,\n    code: NavigationCancellationCode,\n  ) {\n    const navCancel = new NavigationCancel(\n      t.id,\n      this.urlSerializer.serialize(t.extractedUrl),\n      reason,\n      code,\n    );\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n\n  /**\n   * @returns Whether we're navigating to somewhere that is not what the Router is\n   * currently set to.\n   */\n  private isUpdatingInternalState() {\n    // TODO(atscott): The serializer should likely be used instead of\n    // `UrlTree.toString()`. Custom serializers are often written to handle\n    // things better than the default one (objects, for example will be\n    // [Object object] with the custom serializer and be \"the same\" when they\n    // aren't).\n    // (Same for isUpdatedBrowserUrl)\n    return (\n      this.currentTransition?.extractedUrl.toString() !==\n      this.currentTransition?.currentUrlTree.toString()\n    );\n  }\n\n  /**\n   * @returns Whether we're updating the browser URL to something new (navigation is going\n   * to somewhere not displayed in the URL bar and we will update the URL\n   * bar if navigation succeeds).\n   */\n  private isUpdatedBrowserUrl() {\n    // The extracted URL is the part of the URL that this application cares about. `extract` may\n    // return only part of the browser URL and that part may have not changed even if some other\n    // portion of the URL did.\n    const currentBrowserUrl = this.urlHandlingStrategy.extract(\n      this.urlSerializer.parse(this.location.path(true)),\n    );\n    const targetBrowserUrl =\n      this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\n    return (\n      currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\n      !this.currentNavigation?.extras.skipLocationChange\n    );\n  }\n}\n\nexport function isBrowserTriggeredNavigation(source: NavigationTrigger) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, inject, Injectable} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>;\n  componentRef: ComponentRef<any>;\n  route: TreeNode<ActivatedRoute>;\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy)})\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable} from '@angular/core';\nimport {SubscriptionLike} from 'rxjs';\n\nimport {\n  BeforeActivateRoutes,\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationStart,\n  NavigationTrigger,\n  PrivateRouterEvents,\n  RoutesRecognized,\n} from '../events';\nimport {Navigation, RestoredState} from '../navigation_transition';\nimport {ROUTER_CONFIGURATION} from '../router_config';\nimport {createEmptyState, RouterState} from '../router_state';\nimport {UrlHandlingStrategy} from '../url_handling_strategy';\nimport {UrlSerializer, UrlTree} from '../url_tree';\n\n@Injectable({providedIn: 'root', useFactory: () => inject(HistoryStateManager)})\nexport abstract class StateManager {\n  protected readonly urlSerializer = inject(UrlSerializer);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  protected readonly canceledNavigationResolution =\n    this.options.canceledNavigationResolution || 'replace';\n  protected location = inject(Location);\n  protected urlHandlingStrategy = inject(UrlHandlingStrategy);\n  protected urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n\n  private currentUrlTree = new UrlTree();\n  /**\n   * Returns the currently activated `UrlTree`.\n   *\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`).\n   *\n   * The value is set after finding the route config tree to activate but before activating the\n   * route.\n   */\n  getCurrentUrlTree(): UrlTree {\n    return this.currentUrlTree;\n  }\n\n  private rawUrlTree = this.currentUrlTree;\n  /**\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\n   *\n   * In the life of a navigation transition:\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n   * navigated to.\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n   * to `UrlHandlingStrategy`).\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n   * original raw URL.\n   *\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n   * deviated from the raw `UrlTree`.\n   *\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n   * `UrlHandlingStrategy`.\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\n   * still need to know what the browser's URL is for future navigations.\n   */\n  getRawUrlTree(): UrlTree {\n    return this.rawUrlTree;\n  }\n\n  protected createBrowserPath({finalUrl, initialUrl, targetBrowserUrl}: Navigation): string {\n    const rawUrl =\n      finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl!, initialUrl) : initialUrl;\n    const url = targetBrowserUrl ?? rawUrl;\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    return path;\n  }\n\n  protected commitTransition({targetRouterState, finalUrl, initialUrl}: Navigation) {\n    // If we are committing the transition after having a final URL and target state, we're updating\n    // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n    // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n    if (finalUrl && targetRouterState) {\n      this.currentUrlTree = finalUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n      this.routerState = targetRouterState;\n    } else {\n      this.rawUrlTree = initialUrl;\n    }\n  }\n\n  private routerState = createEmptyState(null);\n\n  /** Returns the current RouterState. */\n  getRouterState(): RouterState {\n    return this.routerState;\n  }\n\n  private stateMemento = this.createStateMemento();\n\n  protected updateStateMemento() {\n    this.stateMemento = this.createStateMemento();\n  }\n\n  private createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState,\n    };\n  }\n\n  protected resetInternalState({finalUrl}: Navigation): void {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree = this.urlHandlingStrategy.merge(\n      this.currentUrlTree,\n      finalUrl ?? this.rawUrlTree,\n    );\n  }\n\n  /** Returns the current state stored by the browser for the current history entry. */\n  abstract restoredState(): RestoredState | null | undefined;\n\n  /**\n   * Registers a listener that is called whenever the current history entry changes by some API\n   * outside the Router. This includes user-activated changes like back buttons and link clicks, but\n   * also includes programmatic APIs called by non-Router JavaScript.\n   */\n  abstract registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike;\n\n  /**\n   * Handles a navigation event sent from the Router. These are typically events that indicate a\n   * navigation has started, progressed, been cancelled, or finished.\n   */\n  abstract handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void;\n}\n\n@Injectable({providedIn: 'root'})\nexport class HistoryStateManager extends StateManager {\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  private lastSuccessfulId: number = -1;\n\n  override restoredState(): RestoredState | null | undefined {\n    return this.location.getState() as RestoredState | null | undefined;\n  }\n\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n  }\n\n  override registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike {\n    return this.location.subscribe((event) => {\n      if (event['type'] === 'popstate') {\n        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n        // hybrid apps.\n        setTimeout(() => {\n          listener(event['url']!, event.state as RestoredState | null | undefined, 'popstate');\n        });\n      }\n    });\n  }\n\n  override handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation) {\n    if (e instanceof NavigationStart) {\n      this.updateStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.commitTransition(currentTransition);\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.commitTransition(currentTransition);\n      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n      }\n    } else if (\n      e instanceof NavigationCancel &&\n      (e.code === NavigationCancellationCode.GuardRejected ||\n        e.code === NavigationCancellationCode.NoDataFromResolver)\n    ) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n\n  private setBrowserUrl(path: string, {extras, id}: Navigation) {\n    const {replaceUrl, state} = extras;\n    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, currentBrowserPageId),\n      };\n      this.location.replaceState(path, '', newState);\n    } else {\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, this.browserPageId + 1),\n      };\n      this.location.go(path, '', newState);\n    }\n  }\n\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  private restoreHistory(navigation: Navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetInternalState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else {\n        // The browser URL and router state was not updated before the navigation cancelled so\n        // there's no restoration needed.\n      }\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetInternalState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n      this.urlSerializer.serialize(this.getRawUrlTree()),\n      '',\n      this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId),\n    );\n  }\n\n  private generateNgRouterState(navigationId: number, routerPageId: number) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {navigationId, ɵrouterPageId: routerPageId};\n    }\n    return {navigationId};\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\nimport {filter, map, take} from 'rxjs/operators';\n\nimport {\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n} from '../events';\n\nconst enum NavigationResult {\n  COMPLETE,\n  FAILED,\n  REDIRECTING,\n}\n\n/**\n * Performs the given action once the router finishes its next/current navigation.\n *\n * The navigation is considered complete under the following conditions:\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\n * redirecting/superseding navigation must finish.\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\n */\nexport function afterNextNavigation(router: {events: Observable<Event>}, action: () => void) {\n  router.events\n    .pipe(\n      filter(\n        (e): e is NavigationEnd | NavigationCancel | NavigationError | NavigationSkipped =>\n          e instanceof NavigationEnd ||\n          e instanceof NavigationCancel ||\n          e instanceof NavigationError ||\n          e instanceof NavigationSkipped,\n      ),\n      map((e) => {\n        if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n          return NavigationResult.COMPLETE;\n        }\n        const redirecting =\n          e instanceof NavigationCancel\n            ? e.code === NavigationCancellationCode.Redirect ||\n              e.code === NavigationCancellationCode.SupersededByNewNavigation\n            : false;\n        return redirecting ? NavigationResult.REDIRECTING : NavigationResult.FAILED;\n      }),\n      filter(\n        (result): result is NavigationResult.COMPLETE | NavigationResult.FAILED =>\n          result !== NavigationResult.REDIRECTING,\n      ),\n      take(1),\n    )\n    .subscribe(() => {\n      action();\n    });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  inject,\n  Injectable,\n  Type,\n  ɵConsole as Console,\n  ɵPendingTasksInternal as PendingTasks,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\nimport {Observable, Subject, Subscription, SubscriptionLike} from 'rxjs';\n\nimport {createSegmentGroupFromRoute, createUrlTreeFromSegmentGroup} from './create_url_tree';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {\n  BeforeActivateRoutes,\n  Event,\n  IMPERATIVE_NAVIGATION,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationTrigger,\n  PrivateRouterEvents,\n  RedirectRequest,\n} from './events';\nimport {NavigationBehaviorOptions, OnSameUrlNavigation, Routes} from './models';\nimport {\n  isBrowserTriggeredNavigation,\n  Navigation,\n  NavigationExtras,\n  NavigationTransitions,\n  RestoredState,\n  UrlCreationOptions,\n} from './navigation_transition';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {Params} from './shared';\nimport {StateManager} from './statemanager/state_manager';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {\n  containsTree,\n  IsActiveMatchOptions,\n  isUrlTree,\n  UrlSegmentGroup,\n  UrlSerializer,\n  UrlTree,\n} from './url_tree';\nimport {validateConfig} from './utils/config';\nimport {afterNextNavigation} from './utils/navigations';\nimport {standardizeConfig} from './components/empty_outlet';\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nexport const exactMatchOptions: IsActiveMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact',\n};\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nexport const subsetMatchOptions: IsActiveMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset',\n};\n\n/**\n * @description\n *\n * A service that facilitates navigation among views and URL manipulation capabilities.\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\n *\n * @see {@link Route}\n * @see {@link provideRouter}\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Router {\n  private get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  private get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  private disposed = false;\n  private nonRouterCurrentEntryChangeSubscription?: SubscriptionLike;\n\n  private readonly console = inject(Console);\n  private readonly stateManager = inject(StateManager);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly pendingTasks = inject(PendingTasks);\n  private readonly urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  private readonly navigationTransitions = inject(NavigationTransitions);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly location = inject(Location);\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n\n  /**\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\n   * to push events to. The separate field allows us to expose separate types in the public API\n   * (i.e., an Observable rather than the Subject).\n   */\n  private _events = new Subject<Event>();\n  /**\n   * An event stream for routing events.\n   */\n  public get events(): Observable<Event> {\n    // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n    // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n    // allowed/supported but we still have to fix these or file bugs against the teams before making\n    // the change.\n    return this._events;\n  }\n  /**\n   * The current state of routing in this NgModule.\n   */\n  get routerState() {\n    return this.stateManager.getRouterState();\n  }\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n\n  /**\n   * A strategy for re-using routes.\n   *\n   * @deprecated Configure using `providers` instead:\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n   */\n  routeReuseStrategy: RouteReuseStrategy = inject(RouteReuseStrategy);\n\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   *\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n   * @see {@link withRouterConfig}\n   * @see {@link provideRouter}\n   * @see {@link RouterModule}\n   */\n  onSameUrlNavigation: OnSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n\n  config: Routes = inject(ROUTES, {optional: true})?.flat() ?? [];\n\n  /**\n   * Indicates whether the application has opted in to binding Router data to component inputs.\n   *\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n   */\n  readonly componentInputBindingEnabled: boolean = !!inject(INPUT_BINDER, {optional: true});\n\n  constructor() {\n    this.resetConfig(this.config);\n\n    this.navigationTransitions.setupNavigations(this).subscribe({\n      error: (e) => {\n        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n      },\n    });\n    this.subscribeToNavigationEvents();\n  }\n\n  private eventsSubscription = new Subscription();\n  private subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe((e) => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = this.navigationTransitions.currentNavigation;\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (\n            e instanceof NavigationCancel &&\n            e.code !== NavigationCancellationCode.Redirect &&\n            e.code !== NavigationCancellationCode.SupersededByNewNavigation\n          ) {\n            // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n            // however it's how things were written initially. Investigation would need to be done\n            // to determine if this can be removed.\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const opts = e.navigationBehaviorOptions;\n            const mergedTree = this.urlHandlingStrategy.merge(\n              e.url,\n              currentTransition.currentRawUrl,\n            );\n            const extras = {\n              browserUrl: currentTransition.extras.browserUrl,\n              info: currentTransition.extras.info,\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl:\n                currentTransition.extras.replaceUrl ||\n                this.urlUpdateStrategy === 'eager' ||\n                isBrowserTriggeredNavigation(currentTransition.source),\n              // allow developer to override default options with RedirectCommand\n              ...opts,\n            };\n\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise,\n            });\n          }\n        }\n        // Note that it's important to have the Router process the events _before_ the event is\n        // pushed through the public observable. This ensures the correct router state is in place\n        // before applications observe the events.\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e: unknown) {\n        this.navigationTransitions.transitionAbortSubject.next(e as Error);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n\n  /** @internal */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(\n        this.location.path(true),\n        IMPERATIVE_NAVIGATION,\n        this.stateManager.restoredState(),\n      );\n    }\n  }\n\n  /**\n   * Sets up the location change listener. This listener detects navigations triggered from outside\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n   * navigation so that the correct events, guards, etc. are triggered.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    this.nonRouterCurrentEntryChangeSubscription ??=\n      this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n        this.navigateToSyncWithBrowser(url, source, state);\n      });\n  }\n\n  /**\n   * Schedules a router navigation to synchronize Router state with the browser state.\n   *\n   * This is done as a response to a popstate event and the initial navigation. These\n   * two scenarios represent times when the browser URL/state has been updated and\n   * the Router needs to respond to ensure its internal state matches.\n   */\n  private navigateToSyncWithBrowser(\n    url: string,\n    source: NavigationTrigger,\n    state: RestoredState | null | undefined,\n  ) {\n    const extras: NavigationExtras = {replaceUrl: true};\n\n    // TODO: restoredState should always include the entire state, regardless\n    // of navigationId. This requires a breaking change to update the type on\n    // NavigationStart’s restoredState, which currently requires navigationId\n    // to always be present. The Router used to only restore history state if\n    // a navigationId was present.\n\n    // The stored navigationId is used by the RouterScroller to retrieve the scroll\n    // position for the page.\n    const restoredState = state?.navigationId ? state : null;\n\n    // Separate to NavigationStart.restoredState, we must also restore the state to\n    // history.state and generate a new navigationId, since it will be overwritten\n    if (state) {\n      const stateCopy = {...state} as Partial<RestoredState>;\n      delete stateCopy.navigationId;\n      delete stateCopy.ɵrouterPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras);\n  }\n\n  /** The current URL. */\n  get url(): string {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n\n  /**\n   * Returns the current `Navigation` object when the router is navigating,\n   * and `null` when idle.\n   */\n  getCurrentNavigation(): Navigation | null {\n    return this.navigationTransitions.currentNavigation;\n  }\n\n  /**\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\n   *     has not been a successful navigation yet.\n   */\n  get lastSuccessfulNavigation(): Navigation | null {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n\n  /**\n   * Resets the route configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.dispose();\n  }\n\n  /** Disposes of the router. */\n  dispose(): void {\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `router.events`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this._events.unsubscribe();\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n\n  /**\n   * Appends URL segments to the current URL tree to create a new URL tree.\n   *\n   * @param commands An array of URL fragments with which to construct the new URL tree.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n   * property of the options object, if supplied.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   *\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n   * tree should be created relative to the root.\n   * ```\n   */\n  createUrlTree(commands: any[], navigationExtras: UrlCreationOptions = {}): UrlTree {\n    const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} =\n      navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params | null = null;\n    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n      case 'merge':\n        q = {...this.currentUrlTree.queryParams, ...queryParams};\n        break;\n      case 'preserve':\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n\n    let relativeToUrlSegmentGroup: UrlSegmentGroup | undefined;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e: unknown) {\n      // This is strictly for backwards compatibility with tests that create\n      // invalid `ActivatedRoute` mocks.\n      // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n      // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n      // the moment.\n      if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n        // Navigations that were absolute in the old way of creating UrlTrees\n        // would still work because they wouldn't attempt to match the\n        // segments in the `ActivatedRoute` to the `currentUrlTree` but\n        // instead just replace the root segment with the navigation result.\n        // Non-absolute navigations would fail to apply the commands because\n        // the logic could not find the segment to replace (so they'd act like there were no\n        // commands).\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n  }\n\n  /**\n   * Navigates to a view using an absolute route path.\n   *\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\n   *     current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to an absolute path.\n   *\n   * ```ts\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigateByUrl(\n    url: string | UrlTree,\n    extras: NavigationBehaviorOptions = {\n      skipLocationChange: false,\n    },\n  ): Promise<boolean> {\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * @param commands An array of URL fragments with which to construct the target URL.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n   * of the options object, if supplied.\n   * @param extras An options object that determines how the URL should be constructed or\n   *     interpreted.\n   *\n   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n   * not `true`.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to a dynamic route path relative to the current URL.\n   *\n   * ```ts\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL, overriding the default behavior\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigate(\n    commands: any[],\n    extras: NavigationExtras = {skipLocationChange: false},\n  ): Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string {\n    return this.urlSerializer.serialize(url);\n  }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch {\n      return this.urlSerializer.parse('/');\n    }\n  }\n\n  /**\n   * Returns whether the url is activated.\n   *\n   * @deprecated\n   * Use `IsActiveMatchOptions` instead.\n   *\n   * - The equivalent `IsActiveMatchOptions` for `true` is\n   * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n   * - The equivalent for `false` is\n   * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n   */\n  isActive(url: string | UrlTree, exact: boolean): boolean;\n  /**\n   * Returns whether the url is activated.\n   */\n  isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n  /** @internal */\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean;\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean {\n    let options: IsActiveMatchOptions;\n    if (matchOptions === true) {\n      options = {...exactMatchOptions};\n    } else if (matchOptions === false) {\n      options = {...subsetMatchOptions};\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.entries(params).reduce((result: Params, [key, value]: [string, any]) => {\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private scheduleNavigation(\n    rawUrl: UrlTree,\n    source: NavigationTrigger,\n    restoredState: RestoredState | null,\n    extras: NavigationExtras,\n    priorPromise?: {\n      resolve: (result: boolean | PromiseLike<boolean>) => void;\n      reject: (reason?: any) => void;\n      promise: Promise<boolean>;\n    },\n  ): Promise<boolean> {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n\n    let resolve: (result: boolean | PromiseLike<boolean>) => void;\n    let reject: (reason?: any) => void;\n    let promise: Promise<boolean>;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise<boolean>((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n\n    // Indicate that the navigation is happening.\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      // Remove pending task in a microtask to allow for cancelled\n      // initial navigations and redirects within the same task.\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve: resolve!,\n      reject: reject!,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState,\n    });\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => {\n      return Promise.reject(e);\n    });\n  }\n}\n\nfunction validateCommands(commands: string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NULLISH_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `The requested path contains ${cmd} segment at index ${i}`,\n      );\n    }\n  }\n}\n\nfunction isPublicRouterEvent(e: Event | PrivateRouterEvents): e is Event {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LocationStrategy} from '@angular/common';\nimport {\n  Attribute,\n  booleanAttribute,\n  Directive,\n  ElementRef,\n  HostBinding,\n  HostListener,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  ɵRuntimeError as RuntimeError,\n  SimpleChanges,\n  ɵɵsanitizeUrlOrResourceUrl,\n} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\n\nimport {Event, NavigationEnd} from '../events';\nimport {QueryParamsHandling} from '../models';\nimport {Router} from '../router';\nimport {ActivatedRoute} from '../router_state';\nimport {Params} from '../shared';\nimport {isUrlTree, UrlTree} from '../url_tree';\nimport {RuntimeErrorCode} from '../errors';\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * `queryParams`, `fragment`, `queryParamsHandling`, `preserveFragment`, and `relativeTo`\n * cannot be used when the `routerLink` input is a `UrlTree`.\n *\n * See {@link UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```ts\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLink]',\n})\nexport class RouterLink implements OnChanges, OnDestroy {\n  /**\n   * Represents an `href` attribute value applied to a host element,\n   * when a host element is `<a>`. For other tags, the value is `null`.\n   */\n  href: string | null = null;\n\n  /**\n   * Represents the `target` attribute on a host element.\n   * This is only used when the host element is an `<a>` tag.\n   */\n  @HostBinding('attr.target') @Input() target?: string;\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParams}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParams?: Params | null;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#fragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() fragment?: string;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParamsHandling}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParamsHandling?: QueryParamsHandling | null;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#state}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input() state?: {[k: string]: any};\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#info}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input() info?: unknown;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * Specify a value here when you do not want to use the default value\n   * for `routerLink`, which is the current activated route.\n   * Note that a value of `undefined` here will use the `routerLink` default.\n   * @see {@link UrlCreationOptions#relativeTo}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() relativeTo?: ActivatedRoute | null;\n\n  /** Whether a host element is an `<a>` tag. */\n  private isAnchorElement: boolean;\n\n  private subscription?: Subscription;\n\n  /** @internal */\n  onChanges = new Subject<RouterLink>();\n\n  constructor(\n    private router: Router,\n    private route: ActivatedRoute,\n    @Attribute('tabindex') private readonly tabIndexAttribute: string | null | undefined,\n    private readonly renderer: Renderer2,\n    private readonly el: ElementRef,\n    private locationStrategy?: LocationStrategy,\n  ) {\n    const tagName = el.nativeElement.tagName?.toLowerCase();\n    this.isAnchorElement = tagName === 'a' || tagName === 'area';\n\n    if (this.isAnchorElement) {\n      this.subscription = router.events.subscribe((s: Event) => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    } else {\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n  }\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#preserveFragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input({transform: booleanAttribute}) preserveFragment: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#skipLocationChange}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) skipLocationChange: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#replaceUrl}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) replaceUrl: boolean = false;\n\n  /**\n   * Modifies the tab index if there was not a tabindex attribute on the element during\n   * instantiation.\n   */\n  private setTabIndexIfNotOnNativeEl(newTabIndex: string | null) {\n    if (this.tabIndexAttribute != null /* both `null` and `undefined` */ || this.isAnchorElement) {\n      return;\n    }\n    this.applyAttributeValue('tabindex', newTabIndex);\n  }\n\n  /** @nodoc */\n  // TODO(atscott): Remove changes parameter in major version as a breaking change.\n  ngOnChanges(changes?: SimpleChanges) {\n    if (\n      ngDevMode &&\n      isUrlTree(this.routerLinkInput) &&\n      (this.fragment !== undefined ||\n        this.queryParams ||\n        this.queryParamsHandling ||\n        this.preserveFragment ||\n        this.relativeTo)\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTER_LINK_INPUTS,\n        'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.',\n      );\n    }\n    if (this.isAnchorElement) {\n      this.updateHref();\n    }\n    // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n    // to the RouterLinks it's tracking.\n    this.onChanges.next(this);\n  }\n\n  private routerLinkInput: any[] | UrlTree | null = null;\n\n  /**\n   * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.\n   *   - **array**: commands to pass to {@link Router#createUrlTree}.\n   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n   *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands\n   *     and other inputs that correspond to properties of `UrlCreationOptions`.\n   *   - **null|undefined**: effectively disables the `routerLink`\n   * @see {@link Router#createUrlTree}\n   */\n  @Input()\n  set routerLink(commandsOrUrlTree: any[] | string | UrlTree | null | undefined) {\n    if (commandsOrUrlTree == null) {\n      this.routerLinkInput = null;\n      this.setTabIndexIfNotOnNativeEl(null);\n    } else {\n      if (isUrlTree(commandsOrUrlTree)) {\n        this.routerLinkInput = commandsOrUrlTree;\n      } else {\n        this.routerLinkInput = Array.isArray(commandsOrUrlTree)\n          ? commandsOrUrlTree\n          : [commandsOrUrlTree];\n      }\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n  }\n\n  /** @nodoc */\n  @HostListener('click', [\n    '$event.button',\n    '$event.ctrlKey',\n    '$event.shiftKey',\n    '$event.altKey',\n    '$event.metaKey',\n  ])\n  onClick(\n    button: number,\n    ctrlKey: boolean,\n    shiftKey: boolean,\n    altKey: boolean,\n    metaKey: boolean,\n  ): boolean {\n    const urlTree = this.urlTree;\n\n    if (urlTree === null) {\n      return true;\n    }\n\n    if (this.isAnchorElement) {\n      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n        return true;\n      }\n\n      if (typeof this.target === 'string' && this.target != '_self') {\n        return true;\n      }\n    }\n\n    const extras = {\n      skipLocationChange: this.skipLocationChange,\n      replaceUrl: this.replaceUrl,\n      state: this.state,\n      info: this.info,\n    };\n    this.router.navigateByUrl(urlTree, extras);\n\n    // Return `false` for `<a>` elements to prevent default action\n    // and cancel the native behavior, since the navigation is handled\n    // by the Router.\n    return !this.isAnchorElement;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): any {\n    this.subscription?.unsubscribe();\n  }\n\n  private updateHref(): void {\n    const urlTree = this.urlTree;\n    this.href =\n      urlTree !== null && this.locationStrategy\n        ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree))\n        : null;\n\n    const sanitizedValue =\n      this.href === null\n        ? null\n        : // This class represents a directive that can be added to both `<a>` elements,\n          // as well as other elements. As a result, we can't define security context at\n          // compile time. So the security context is deferred to runtime.\n          // The `ɵɵsanitizeUrlOrResourceUrl` selects the necessary sanitizer function\n          // based on the tag and property names. The logic mimics the one from\n          // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.\n          //\n          // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`\n          // instead of applying a value via a renderer, after a final merge of the\n          // `RouterLinkWithHref` directive.\n          ɵɵsanitizeUrlOrResourceUrl(\n            this.href,\n            this.el.nativeElement.tagName.toLowerCase(),\n            'href',\n          );\n    this.applyAttributeValue('href', sanitizedValue);\n  }\n\n  private applyAttributeValue(attrName: string, attrValue: string | null) {\n    const renderer = this.renderer;\n    const nativeElement = this.el.nativeElement;\n    if (attrValue !== null) {\n      renderer.setAttribute(nativeElement, attrName, attrValue);\n    } else {\n      renderer.removeAttribute(nativeElement, attrName);\n    }\n  }\n\n  get urlTree(): UrlTree | null {\n    if (this.routerLinkInput === null) {\n      return null;\n    } else if (isUrlTree(this.routerLinkInput)) {\n      return this.routerLinkInput;\n    }\n    return this.router.createUrlTree(this.routerLinkInput, {\n      // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n      // Otherwise, we should use the value provided by the user in the input.\n      relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: this.preserveFragment,\n    });\n  }\n}\n\n/**\n * @description\n * An alias for the `RouterLink` directive.\n * Deprecated since v15, use `RouterLink` directive instead.\n *\n * @deprecated use `RouterLink` directive instead.\n * @publicApi\n */\nexport {RouterLink as RouterLinkWithHref};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectorRef,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {from, of, Subscription} from 'rxjs';\nimport {mergeAll} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {IsActiveMatchOptions} from '../url_tree';\n\nimport {RouterLink} from './router_link';\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```html\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```html\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLinkActive]',\n  exportAs: 'routerLinkActive',\n})\nexport class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n  @ContentChildren(RouterLink, {descendants: true}) links!: QueryList<RouterLink>;\n\n  private classes: string[] = [];\n  private routerEventsSubscription: Subscription;\n  private linkInputChangesSubscription?: Subscription;\n  private _isActive = false;\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  /**\n   * Options to configure how to determine if the router link is active.\n   *\n   * These options are passed to the `Router.isActive()` function.\n   *\n   * @see {@link Router#isActive}\n   */\n  @Input() routerLinkActiveOptions: {exact: boolean} | IsActiveMatchOptions = {exact: false};\n\n  /**\n   * Aria-current attribute to apply when the router link is active.\n   *\n   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n   */\n  @Input() ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;\n\n  /**\n   *\n   * You can use the output `isActiveChange` to get notified each time the link becomes\n   * active or inactive.\n   *\n   * Emits:\n   * true  -> Route is active\n   * false -> Route is inactive\n   *\n   * ```html\n   * <a\n   *  routerLink=\"/user/bob\"\n   *  routerLinkActive=\"active-link\"\n   *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n   * ```\n   */\n  @Output() readonly isActiveChange: EventEmitter<boolean> = new EventEmitter();\n\n  constructor(\n    private router: Router,\n    private element: ElementRef,\n    private renderer: Renderer2,\n    private readonly cdr: ChangeDetectorRef,\n    @Optional() private link?: RouterLink,\n  ) {\n    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n\n  /** @nodoc */\n  ngAfterContentInit(): void {\n    // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n    of(this.links.changes, of(null))\n      .pipe(mergeAll())\n      .subscribe((_) => {\n        this.update();\n        this.subscribeToEachLinkOnChanges();\n      });\n  }\n\n  private subscribeToEachLinkOnChanges() {\n    this.linkInputChangesSubscription?.unsubscribe();\n    const allLinkChanges = [...this.links.toArray(), this.link]\n      .filter((link): link is RouterLink => !!link)\n      .map((link) => link.onChanges);\n    this.linkInputChangesSubscription = from(allLinkChanges)\n      .pipe(mergeAll())\n      .subscribe((link) => {\n        if (this._isActive !== this.isLinkActive(this.router)(link)) {\n          this.update();\n        }\n      });\n  }\n\n  @Input()\n  set routerLinkActive(data: string[] | string) {\n    const classes = Array.isArray(data) ? data : data.split(' ');\n    this.classes = classes.filter((c) => !!c);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    this.update();\n  }\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.routerEventsSubscription.unsubscribe();\n    this.linkInputChangesSubscription?.unsubscribe();\n  }\n\n  private update(): void {\n    if (!this.links || !this.router.navigated) return;\n\n    queueMicrotask(() => {\n      const hasActiveLinks = this.hasActiveLinks();\n      this.classes.forEach((c) => {\n        if (hasActiveLinks) {\n          this.renderer.addClass(this.element.nativeElement, c);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, c);\n        }\n      });\n      if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n        this.renderer.setAttribute(\n          this.element.nativeElement,\n          'aria-current',\n          this.ariaCurrentWhenActive.toString(),\n        );\n      } else {\n        this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n      }\n\n      // Only emit change if the active state changed.\n      if (this._isActive !== hasActiveLinks) {\n        this._isActive = hasActiveLinks;\n        this.cdr.markForCheck();\n        // Emit on isActiveChange after classes are updated\n        this.isActiveChange.emit(hasActiveLinks);\n      }\n    });\n  }\n\n  private isLinkActive(router: Router): (link: RouterLink) => boolean {\n    const options: boolean | IsActiveMatchOptions = isActiveMatchOptions(\n      this.routerLinkActiveOptions,\n    )\n      ? this.routerLinkActiveOptions\n      : // While the types should disallow `undefined` here, it's possible without strict inputs\n        this.routerLinkActiveOptions.exact || false;\n    return (link: RouterLink) => {\n      const urlTree = link.urlTree;\n      return urlTree ? router.isActive(urlTree, options) : false;\n    };\n  }\n\n  private hasActiveLinks(): boolean {\n    const isActiveCheckFn = this.isLinkActive(this.router);\n    return (this.link && isActiveCheckFn(this.link)) || this.links.some(isActiveCheckFn);\n  }\n}\n\n/**\n * Use instead of `'paths' in options` to be compatible with property renaming\n */\nfunction isActiveMatchOptions(\n  options: {exact: boolean} | IsActiveMatchOptions,\n): options is IsActiveMatchOptions {\n  return !!(options as IsActiveMatchOptions).paths;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {createEnvironmentInjector, EnvironmentInjector, Injectable, OnDestroy} from '@angular/core';\nimport {from, Observable, of, Subscription} from 'rxjs';\nimport {catchError, concatMap, filter, mergeAll, mergeMap} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from './events';\nimport {LoadedRouterConfig, Route, Routes} from './models';\nimport {Router} from './router';\nimport {RouterConfigLoader} from './router_config_loader';\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport abstract class PreloadingStrategy {\n  abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```ts\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class PreloadAllModules implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return fn().pipe(catchError(() => of(null)));\n  }\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class NoPreloading implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return of(null);\n  }\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class RouterPreloader implements OnDestroy {\n  private subscription?: Subscription;\n\n  constructor(\n    private router: Router,\n    private injector: EnvironmentInjector,\n    private preloadingStrategy: PreloadingStrategy,\n    private loader: RouterConfigLoader,\n  ) {}\n\n  setUpPreloading(): void {\n    this.subscription = this.router.events\n      .pipe(\n        filter((e: Event) => e instanceof NavigationEnd),\n        concatMap(() => this.preload()),\n      )\n      .subscribe(() => {});\n  }\n\n  preload(): Observable<any> {\n    return this.processRoutes(this.injector, this.router.config);\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  private processRoutes(injector: EnvironmentInjector, routes: Routes): Observable<void> {\n    const res: Observable<any>[] = [];\n    for (const route of routes) {\n      if (route.providers && !route._injector) {\n        route._injector = createEnvironmentInjector(\n          route.providers,\n          injector,\n          `Route: ${route.path}`,\n        );\n      }\n\n      const injectorForCurrentRoute = route._injector ?? injector;\n      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n\n      // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n      // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n      // happens as a consequence of needing to descend into children for route matching immediately\n      // while component loading is deferred until route activation. Because `canLoad` guards can\n      // have side effects, we cannot execute them here so we instead skip preloading altogether\n      // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n      // at all. Code splitting and lazy loading is separate from client-side authorization checks\n      // and should not be used as a security measure to prevent loading of code.\n      if (\n        (route.loadChildren && !route._loadedRoutes && route.canLoad === undefined) ||\n        (route.loadComponent && !route._loadedComponent)\n      ) {\n        res.push(this.preloadConfig(injectorForCurrentRoute, route));\n      }\n      if (route.children || route._loadedRoutes) {\n        res.push(this.processRoutes(injectorForChildren, (route.children ?? route._loadedRoutes)!));\n      }\n    }\n    return from(res).pipe(mergeAll());\n  }\n\n  private preloadConfig(injector: EnvironmentInjector, route: Route): Observable<void> {\n    return this.preloadingStrategy.preload(route, () => {\n      let loadedChildren$: Observable<LoadedRouterConfig | null>;\n      if (route.loadChildren && route.canLoad === undefined) {\n        loadedChildren$ = this.loader.loadChildren(injector, route);\n      } else {\n        loadedChildren$ = of(null);\n      }\n\n      const recursiveLoadChildren$ = loadedChildren$.pipe(\n        mergeMap((config: LoadedRouterConfig | null) => {\n          if (config === null) {\n            return of(void 0);\n          }\n          route._loadedRoutes = config.routes;\n          route._loadedInjector = config.injector;\n          // If the loaded config was a module, use that as the module/module injector going\n          // forward. Otherwise, continue using the current module/module injector.\n          return this.processRoutes(config.injector ?? injector, config.routes);\n        }),\n      );\n      if (route.loadComponent && !route._loadedComponent) {\n        const loadComponent$ = this.loader.loadComponent(route);\n        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n      } else {\n        return recursiveLoadChildren$;\n      }\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {Injectable, InjectionToken, NgZone, OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {\n  NavigationEnd,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  Scroll,\n} from './events';\nimport {NavigationTransitions} from './navigation_transition';\nimport {UrlSerializer} from './url_tree';\n\nexport const ROUTER_SCROLLER = new InjectionToken<RouterScroller>('');\n\n@Injectable()\nexport class RouterScroller implements OnDestroy {\n  private routerEventsSubscription?: Unsubscribable;\n  private scrollEventsSubscription?: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: 'imperative' | 'popstate' | 'hashchange' | undefined = 'imperative';\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  /** @nodoc */\n  constructor(\n    readonly urlSerializer: UrlSerializer,\n    private transitions: NavigationTransitions,\n    public readonly viewportScroller: ViewportScroller,\n    private readonly zone: NgZone,\n    private options: {\n      scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n      anchorScrolling?: 'disabled' | 'enabled';\n    } = {},\n  ) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration ||= 'disabled';\n    options.anchorScrolling ||= 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n      } else if (\n        e instanceof NavigationSkipped &&\n        e.code === NavigationSkippedCode.IgnoredSameUrlNavigation\n      ) {\n        this.lastSource = undefined;\n        this.restoredId = 0;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(\n    routerEvent: NavigationEnd | NavigationSkipped,\n    anchor: string | null,\n  ): void {\n    this.zone.runOutsideAngular(() => {\n      // The scroll event needs to be delayed until after change detection. Otherwise, we may\n      // attempt to restore the scroll position before the router outlet has fully rendered the\n      // component by executing its update block of the template function.\n      setTimeout(() => {\n        this.zone.run(() => {\n          this.transitions.events.next(\n            new Scroll(\n              routerEvent,\n              this.lastSource === 'popstate' ? this.store[this.restoredId] : null,\n              anchor,\n            ),\n          );\n        });\n      }, 0);\n    });\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    this.routerEventsSubscription?.unsubscribe();\n    this.scrollEventsSubscription?.unsubscribe();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  HashLocationStrategy,\n  LOCATION_INITIALIZED,\n  LocationStrategy,\n  ViewportScroller,\n} from '@angular/common';\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  ApplicationRef,\n  ComponentRef,\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  InjectFlags,\n  InjectionToken,\n  Injector,\n  makeEnvironmentProviders,\n  NgZone,\n  provideAppInitializer,\n  Provider,\n  runInInjectionContext,\n  Type,\n  ɵperformanceMarkFeature as performanceMarkFeature,\n} from '@angular/core';\nimport {of, Subject} from 'rxjs';\n\nimport {INPUT_BINDER, RoutedComponentInputBinder} from './directives/router_outlet';\nimport {Event, NavigationError, stringifyEvent} from './events';\nimport {RedirectCommand, Routes} from './models';\nimport {NAVIGATION_ERROR_HANDLER, NavigationTransitions} from './navigation_transition';\nimport {Router} from './router';\nimport {InMemoryScrollingOptions, ROUTER_CONFIGURATION, RouterConfigOptions} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {PreloadingStrategy, RouterPreloader} from './router_preloader';\nimport {ROUTER_SCROLLER, RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {UrlSerializer} from './url_tree';\nimport {afterNextNavigation} from './utils/navigations';\nimport {\n  CREATE_VIEW_TRANSITION,\n  createViewTransition,\n  VIEW_TRANSITION_OPTIONS,\n  ViewTransitionsFeatureOptions,\n} from './utils/view_transition';\n\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link RouterFeatures}\n *\n * @publicApi\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\nexport function provideRouter(routes: Routes, ...features: RouterFeatures[]): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    {provide: ROUTES, multi: true, useValue: routes},\n    typeof ngDevMode === 'undefined' || ngDevMode\n      ? {provide: ROUTER_IS_PROVIDED, useValue: true}\n      : [],\n    {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useFactory: getBootstrapListener},\n    features.map((feature) => feature.ɵproviders),\n  ]);\n}\n\nexport function rootRoute(router: Router): ActivatedRoute {\n  return router.routerState.root;\n}\n\n/**\n * Helper type to represent a Router feature.\n *\n * @publicApi\n */\nexport interface RouterFeature<FeatureKind extends RouterFeatureKind> {\n  ɵkind: FeatureKind;\n  ɵproviders: Array<Provider | EnvironmentProviders>;\n}\n\n/**\n * Helper function to create an object that represents a Router feature.\n */\nfunction routerFeature<FeatureKind extends RouterFeatureKind>(\n  kind: FeatureKind,\n  providers: Array<Provider | EnvironmentProviders>,\n): RouterFeature<FeatureKind> {\n  return {ɵkind: kind, ɵproviders: providers};\n}\n\n/**\n * An Injection token used to indicate whether `provideRouter` or `RouterModule.forRoot` was ever\n * called.\n */\nexport const ROUTER_IS_PROVIDED = new InjectionToken<boolean>('', {\n  providedIn: 'root',\n  factory: () => false,\n});\n\nconst routerIsProvidedDevModeCheck = {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => {\n      if (!inject(ROUTER_IS_PROVIDED)) {\n        console.warn(\n          '`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' +\n            'This is likely a mistake.',\n        );\n      }\n    };\n  },\n};\n\n/**\n * Registers a DI provider for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```ts\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @deprecated If necessary, provide routes using the `ROUTES` `InjectionToken`.\n * @see {@link ROUTES}\n * @publicApi\n */\nexport function provideRoutes(routes: Routes): Provider[] {\n  return [\n    {provide: ROUTES, multi: true, useValue: routes},\n    typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : [],\n  ];\n}\n\n/**\n * A type alias for providers returned by `withInMemoryScrolling` for use with `provideRouter`.\n *\n * @see {@link withInMemoryScrolling}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InMemoryScrollingFeature = RouterFeature<RouterFeatureKind.InMemoryScrollingFeature>;\n\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link ViewportScroller}\n *\n * @publicApi\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withInMemoryScrolling(\n  options: InMemoryScrollingOptions = {},\n): InMemoryScrollingFeature {\n  const providers = [\n    {\n      provide: ROUTER_SCROLLER,\n      useFactory: () => {\n        const viewportScroller = inject(ViewportScroller);\n        const zone = inject(NgZone);\n        const transitions = inject(NavigationTransitions);\n        const urlSerializer = inject(UrlSerializer);\n        return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);\n      },\n    },\n  ];\n  return routerFeature(RouterFeatureKind.InMemoryScrollingFeature, providers);\n}\n\nexport function getBootstrapListener() {\n  const injector = inject(Injector);\n  return (bootstrappedComponentRef: ComponentRef<unknown>) => {\n    const ref = injector.get(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n\n    if (injector.get(INITIAL_NAVIGATION) === InitialNavigation.EnabledNonBlocking) {\n      router.initialNavigation();\n    }\n\n    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\n\n/**\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\n * to the activation phase.\n */\nconst BOOTSTRAP_DONE = new InjectionToken<Subject<void>>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '',\n  {\n    factory: () => {\n      return new Subject<void>();\n    },\n  },\n);\n\n/**\n * This and the INITIAL_NAVIGATION token are used internally only. The public API side of this is\n * configured through the `ExtraOptions`.\n *\n * When set to `EnabledBlocking`, the initial navigation starts before the root\n * component is created. The bootstrap is blocked until the initial navigation is complete. This\n * value should be set in case you use [server-side rendering](guide/ssr), but do not enable\n * [hydration](guide/hydration) for your application.\n *\n * When set to `EnabledNonBlocking`, the initial navigation starts after the root component has been\n * created. The bootstrap is not blocked on the completion of the initial navigation.\n *\n * When set to `Disabled`, the initial navigation is not performed. The location listener is set up\n * before the root component gets created. Use if there is a reason to have more control over when\n * the router starts its initial navigation due to some complex initialization logic.\n *\n * @see {@link ExtraOptions}\n */\nconst enum InitialNavigation {\n  EnabledBlocking,\n  EnabledNonBlocking,\n  Disabled,\n}\n\nconst INITIAL_NAVIGATION = new InjectionToken<InitialNavigation>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '',\n  {providedIn: 'root', factory: () => InitialNavigation.EnabledNonBlocking},\n);\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type EnabledBlockingInitialNavigationFeature =\n  RouterFeature<RouterFeatureKind.EnabledBlockingInitialNavigationFeature>;\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` or\n * `withDisabledInitialNavigation` functions for use with `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InitialNavigationFeature =\n  | EnabledBlockingInitialNavigationFeature\n  | DisabledInitialNavigationFeature;\n\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This should be set in case\n * you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration) for\n * your application.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withEnabledBlockingInitialNavigation(): EnabledBlockingInitialNavigationFeature {\n  const providers = [\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.EnabledBlocking},\n    provideAppInitializer(() => {\n      const injector = inject(Injector);\n      const locationInitialized: Promise<any> = injector.get(\n        LOCATION_INITIALIZED,\n        Promise.resolve(),\n      );\n\n      return locationInitialized.then(() => {\n        return new Promise((resolve) => {\n          const router = injector.get(Router);\n          const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n          afterNextNavigation(router, () => {\n            // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n            // without a redirect.\n            resolve(true);\n          });\n\n          injector.get(NavigationTransitions).afterPreactivation = () => {\n            // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n            // assume activation will complete successfully (even though this is not\n            // guaranteed).\n            resolve(true);\n            return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n          };\n          router.initialNavigation();\n        });\n      });\n    }),\n  ];\n  return routerFeature(RouterFeatureKind.EnabledBlockingInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDisabledInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DisabledInitialNavigationFeature =\n  RouterFeature<RouterFeatureKind.DisabledInitialNavigationFeature>;\n\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDisabledInitialNavigation(): DisabledInitialNavigationFeature {\n  const providers = [\n    provideAppInitializer(() => {\n      inject(Router).setUpLocationChangeListener();\n    }),\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.Disabled},\n  ];\n  return routerFeature(RouterFeatureKind.DisabledInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDebugTracing` for use with `provideRouter`.\n *\n * @see {@link withDebugTracing}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DebugTracingFeature = RouterFeature<RouterFeatureKind.DebugTracingFeature>;\n\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDebugTracing(): DebugTracingFeature {\n  let providers: Provider[] = [];\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    providers = [\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useFactory: () => {\n          const router = inject(Router);\n          return () =>\n            router.events.subscribe((e: Event) => {\n              // tslint:disable:no-console\n              console.group?.(`Router Event: ${(<any>e.constructor).name}`);\n              console.log(stringifyEvent(e));\n              console.log(e);\n              console.groupEnd?.();\n              // tslint:enable:no-console\n            });\n        },\n      },\n    ];\n  } else {\n    providers = [];\n  }\n  return routerFeature(RouterFeatureKind.DebugTracingFeature, providers);\n}\n\nconst ROUTER_PRELOADER = new InjectionToken<RouterPreloader>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '',\n);\n\n/**\n * A type alias that represents a feature which enables preloading in Router.\n * The type is used to describe the return value of the `withPreloading` function.\n *\n * @see {@link withPreloading}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type PreloadingFeature = RouterFeature<RouterFeatureKind.PreloadingFeature>;\n\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withPreloading(preloadingStrategy: Type<PreloadingStrategy>): PreloadingFeature {\n  const providers = [\n    {provide: ROUTER_PRELOADER, useExisting: RouterPreloader},\n    {provide: PreloadingStrategy, useExisting: preloadingStrategy},\n  ];\n  return routerFeature(RouterFeatureKind.PreloadingFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withRouterConfig` for use with `provideRouter`.\n *\n * @see {@link withRouterConfig}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterConfigurationFeature =\n  RouterFeature<RouterFeatureKind.RouterConfigurationFeature>;\n\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withRouterConfig(options: RouterConfigOptions): RouterConfigurationFeature {\n  const providers = [{provide: ROUTER_CONFIGURATION, useValue: options}];\n  return routerFeature(RouterFeatureKind.RouterConfigurationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withHashLocation` for use with `provideRouter`.\n *\n * @see {@link withHashLocation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterHashLocationFeature = RouterFeature<RouterFeatureKind.RouterHashLocationFeature>;\n\n/**\n * Provides the location strategy that uses the URL fragment instead of the history API.\n *\n * @usageNotes\n *\n * Basic example of how you can use the hash location option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withHashLocation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link /api/common/HashLocationStrategy HashLocationStrategy}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withHashLocation(): RouterHashLocationFeature {\n  const providers = [{provide: LocationStrategy, useClass: HashLocationStrategy}];\n  return routerFeature(RouterFeatureKind.RouterHashLocationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withNavigationErrorHandler` for use with `provideRouter`.\n *\n * @see {@link withNavigationErrorHandler}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type NavigationErrorHandlerFeature =\n  RouterFeature<RouterFeatureKind.NavigationErrorHandlerFeature>;\n\n/**\n * Provides a function which is called when a navigation error occurs.\n *\n * This function is run inside application's [injection context](guide/di/dependency-injection-context)\n * so you can use the [`inject`](api/core/inject) function.\n *\n * This function can return a `RedirectCommand` to convert the error to a redirect, similar to returning\n * a `UrlTree` or `RedirectCommand` from a guard. This will also prevent the `Router` from emitting\n * `NavigationError`; it will instead emit `NavigationCancel` with code NavigationCancellationCode.Redirect.\n * Return values other than `RedirectCommand` are ignored and do not change any behavior with respect to\n * how the `Router` handles the error.\n *\n * @usageNotes\n *\n * Basic example of how you can use the error handler option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withNavigationErrorHandler((e: NavigationError) =>\n * inject(MyErrorTracker).trackError(e)))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link NavigationError}\n * @see {@link /api/core/inject inject}\n * @see {@link runInInjectionContext}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withNavigationErrorHandler(\n  handler: (error: NavigationError) => unknown | RedirectCommand,\n): NavigationErrorHandlerFeature {\n  const providers = [\n    {\n      provide: NAVIGATION_ERROR_HANDLER,\n      useValue: handler,\n    },\n  ];\n  return routerFeature(RouterFeatureKind.NavigationErrorHandlerFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withComponentInputBinding` for use with `provideRouter`.\n *\n * @see {@link withComponentInputBinding}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ComponentInputBindingFeature =\n  RouterFeature<RouterFeatureKind.ComponentInputBindingFeature>;\n\n/**\n * A type alias for providers returned by `withViewTransitions` for use with `provideRouter`.\n *\n * @see {@link withViewTransitions}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ViewTransitionsFeature = RouterFeature<RouterFeatureKind.ViewTransitionsFeature>;\n\n/**\n * Enables binding information from the `Router` state directly to the inputs of the component in\n * `Route` configurations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withComponentInputBinding())\n *     ]\n *   }\n * );\n * ```\n *\n * The router bindings information from any of the following sources:\n *\n *  - query parameters\n *  - path and matrix parameters\n *  - static route data\n *  - data from resolvers\n *\n * Duplicate keys are resolved in the same order from above, from least to greatest,\n * meaning that resolvers have the highest precedence and override any of the other information\n * from the route.\n *\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. This prevents previous information from being\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n * Default values can be provided with a resolver on the route to ensure the value is always present\n * or an input and use an input transform in the component.\n *\n * @see {@link /guide/components/inputs#input-transforms Input Transforms}\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withComponentInputBinding(): ComponentInputBindingFeature {\n  const providers = [\n    RoutedComponentInputBinder,\n    {provide: INPUT_BINDER, useExisting: RoutedComponentInputBinder},\n  ];\n\n  return routerFeature(RouterFeatureKind.ComponentInputBindingFeature, providers);\n}\n\n/**\n * Enables view transitions in the Router by running the route activation and deactivation inside of\n * `document.startViewTransition`.\n *\n * Note: The View Transitions API is not available in all browsers. If the browser does not support\n * view transitions, the Router will not attempt to start a view transition and continue processing\n * the navigation as usual.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withViewTransitions())\n *     ]\n *   }\n * );\n * ```\n *\n * @returns A set of providers for use with `provideRouter`.\n * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n * @developerPreview\n */\nexport function withViewTransitions(\n  options?: ViewTransitionsFeatureOptions,\n): ViewTransitionsFeature {\n  performanceMarkFeature('NgRouterViewTransitions');\n  const providers = [\n    {provide: CREATE_VIEW_TRANSITION, useValue: createViewTransition},\n    {\n      provide: VIEW_TRANSITION_OPTIONS,\n      useValue: {skipNextTransition: !!options?.skipInitialTransition, ...options},\n    },\n  ];\n  return routerFeature(RouterFeatureKind.ViewTransitionsFeature, providers);\n}\n\n/**\n * A type alias that represents all Router features available for use with `provideRouter`.\n * Features can be enabled by adding special functions to the `provideRouter` call.\n * See documentation for each symbol to find corresponding function name. See also `provideRouter`\n * documentation on how to use those functions.\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterFeatures =\n  | PreloadingFeature\n  | DebugTracingFeature\n  | InitialNavigationFeature\n  | InMemoryScrollingFeature\n  | RouterConfigurationFeature\n  | NavigationErrorHandlerFeature\n  | ComponentInputBindingFeature\n  | ViewTransitionsFeature\n  | RouterHashLocationFeature;\n\n/**\n * The list of features as an enum to uniquely type each feature.\n */\nexport const enum RouterFeatureKind {\n  PreloadingFeature,\n  DebugTracingFeature,\n  EnabledBlockingInitialNavigationFeature,\n  DisabledInitialNavigationFeature,\n  InMemoryScrollingFeature,\n  RouterConfigurationFeature,\n  RouterHashLocationFeature,\n  NavigationErrorHandlerFeature,\n  ComponentInputBindingFeature,\n  ViewTransitionsFeature,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  HashLocationStrategy,\n  Location,\n  LocationStrategy,\n  PathLocationStrategy,\n  ViewportScroller,\n} from '@angular/common';\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  ComponentRef,\n  inject,\n  Inject,\n  InjectionToken,\n  ModuleWithProviders,\n  NgModule,\n  NgZone,\n  Optional,\n  Provider,\n  SkipSelf,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {EmptyOutletComponent} from './components/empty_outlet';\nimport {RouterLink} from './directives/router_link';\nimport {RouterLinkActive} from './directives/router_link_active';\nimport {RouterOutlet} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {Routes} from './models';\nimport {NAVIGATION_ERROR_HANDLER, NavigationTransitions} from './navigation_transition';\nimport {\n  getBootstrapListener,\n  rootRoute,\n  ROUTER_IS_PROVIDED,\n  withComponentInputBinding,\n  withDebugTracing,\n  withDisabledInitialNavigation,\n  withEnabledBlockingInitialNavigation,\n  withPreloading,\n  withViewTransitions,\n} from './provide_router';\nimport {Router} from './router';\nimport {ExtraOptions, ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader, ROUTES} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ROUTER_SCROLLER, RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {DefaultUrlSerializer, UrlSerializer} from './url_tree';\n\n/**\n * The directives defined in the `RouterModule`.\n */\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, EmptyOutletComponent];\n\n/**\n * @docsNotRequired\n */\nexport const ROUTER_FORROOT_GUARD = new InjectionToken<void>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router duplicate forRoot guard' : '',\n);\n\n// TODO(atscott): All of these except `ActivatedRoute` are `providedIn: 'root'`. They are only kept\n// here to avoid a breaking change whereby the provider order matters based on where the\n// `RouterModule`/`RouterTestingModule` is imported. These can/should be removed as a \"breaking\"\n// change in a major version.\nexport const ROUTER_PROVIDERS: Provider[] = [\n  Location,\n  {provide: UrlSerializer, useClass: DefaultUrlSerializer},\n  Router,\n  ChildrenOutletContexts,\n  {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n  RouterConfigLoader,\n  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can\n  // be removed when `provideRoutes` is removed.\n  typeof ngDevMode === 'undefined' || ngDevMode\n    ? {provide: ROUTER_IS_PROVIDED, useValue: true}\n    : [],\n];\n\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\n@NgModule({\n  imports: ROUTER_DIRECTIVES,\n  exports: ROUTER_DIRECTIVES,\n})\nexport class RouterModule {\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      inject(ROUTER_FORROOT_GUARD, {optional: true});\n    }\n  }\n\n  /**\n   * Creates and configures a module with all the router providers and directives.\n   * Optionally sets up an application listener to perform an initial navigation.\n   *\n   * When registering the NgModule at the root, import as follows:\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [RouterModule.forRoot(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the application.\n   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n   * @return The new `NgModule`.\n   *\n   */\n  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule> {\n    return {\n      ngModule: RouterModule,\n      providers: [\n        ROUTER_PROVIDERS,\n        typeof ngDevMode === 'undefined' || ngDevMode\n          ? config?.enableTracing\n            ? withDebugTracing().ɵproviders\n            : []\n          : [],\n        {provide: ROUTES, multi: true, useValue: routes},\n        typeof ngDevMode === 'undefined' || ngDevMode\n          ? {\n              provide: ROUTER_FORROOT_GUARD,\n              useFactory: provideForRootGuard,\n              deps: [[Router, new Optional(), new SkipSelf()]],\n            }\n          : [],\n        config?.errorHandler\n          ? {\n              provide: NAVIGATION_ERROR_HANDLER,\n              useValue: config.errorHandler,\n            }\n          : [],\n        {provide: ROUTER_CONFIGURATION, useValue: config ? config : {}},\n        config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(),\n        provideRouterScroller(),\n        config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).ɵproviders : [],\n        config?.initialNavigation ? provideInitialNavigation(config) : [],\n        config?.bindToComponentInputs ? withComponentInputBinding().ɵproviders : [],\n        config?.enableViewTransitions ? withViewTransitions().ɵproviders : [],\n        provideRouterInitializer(),\n      ],\n    };\n  }\n\n  /**\n   * Creates a module with all the router directives and a provider registering routes,\n   * without creating a new Router service.\n   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [RouterModule.forChild(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n   * @return The new NgModule.\n   *\n   */\n  static forChild(routes: Routes): ModuleWithProviders<RouterModule> {\n    return {\n      ngModule: RouterModule,\n      providers: [{provide: ROUTES, multi: true, useValue: routes}],\n    };\n  }\n}\n\n/**\n * For internal use by `RouterModule` only. Note that this differs from `withInMemoryRouterScroller`\n * because it reads from the `ExtraOptions` which should not be used in the standalone world.\n */\nexport function provideRouterScroller(): Provider {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const config: ExtraOptions = inject(ROUTER_CONFIGURATION);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      if (config.scrollOffset) {\n        viewportScroller.setOffset(config.scrollOffset);\n      }\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);\n    },\n  };\n}\n\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` should\n// provide hash location directly via `{provide: LocationStrategy, useClass: HashLocationStrategy}`.\nfunction provideHashLocationStrategy(): Provider {\n  return {provide: LocationStrategy, useClass: HashLocationStrategy};\n}\n\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` does not\n// need this at all because `PathLocationStrategy` is the default factory for `LocationStrategy`.\nfunction providePathLocationStrategy(): Provider {\n  return {provide: LocationStrategy, useClass: PathLocationStrategy};\n}\n\nexport function provideForRootGuard(router: Router): any {\n  if (router) {\n    throw new RuntimeError(\n      RuntimeErrorCode.FOR_ROOT_CALLED_TWICE,\n      `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` +\n        ` Lazy loaded modules should use RouterModule.forChild() instead.`,\n    );\n  }\n  return 'guarded';\n}\n\n// Note: For internal use only with `RouterModule`. Standalone router setup with `provideRouter`\n// users call `withXInitialNavigation` directly.\nfunction provideInitialNavigation(config: Pick<ExtraOptions, 'initialNavigation'>): Provider[] {\n  return [\n    config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().ɵproviders : [],\n    config.initialNavigation === 'enabledBlocking'\n      ? withEnabledBlockingInitialNavigation().ɵproviders\n      : [],\n  ];\n}\n\n// TODO(atscott): This should not be in the public API\n/**\n * A DI token for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport const ROUTER_INITIALIZER = new InjectionToken<(compRef: ComponentRef<any>) => void>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'Router Initializer' : '',\n);\n\nfunction provideRouterInitializer(): Provider[] {\n  return [\n    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n    {provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER},\n  ];\n}\n", "import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { catchError, map } from 'rxjs/operators';\r\n\r\nexport interface LoginRequest {\r\n  username: string;\r\n  password: string;\r\n}\r\n\r\nexport interface LoginResponse {\r\n  token?: string;\r\n  user?: any;\r\n}\r\n\r\nexport interface RegisterRequest {\r\n  name: string;\r\n  username: string;\r\n  email: string;\r\n  role: string;\r\n  password: string;\r\n}\r\n\r\nexport interface Job {\r\n  id?: number;\r\n  title: string;\r\n  role: string;\r\n  location: string;\r\n  description: string;\r\n  isActive: boolean;\r\n  salaryMin: number;\r\n  salaryMax: number;\r\n  type: string;\r\n  level: string;\r\n}\r\n\r\nexport interface CreateJobRequest {\r\n  title: string;\r\n  role: string;\r\n  location: string;\r\n  description: string;\r\n  salaryMin: number;\r\n  salaryMax: number;\r\n  type: string;\r\n  level: string;\r\n  isActive: boolean;\r\n}\r\n\r\nexport interface AssessmentTemplate {\r\n  id: number;\r\n  role: string;\r\n  stepOrder: number;\r\n  stepName: string;\r\n  question: string | null;\r\n  options: string | null;\r\n  correctAnswer: string | null;\r\n  type: string | null;\r\n}\r\n\r\n// Backend candidate structure (what API returns)\r\nexport interface BackendCandidate {\r\n  id: number;\r\n  name: string;\r\n  role: string;\r\n  appliedRole: string;\r\n  department: string;\r\n  employmentType: string;\r\n  workType: string;\r\n  appliedDateStr: string; // Backend uses appliedDateStr\r\n  resumeUrl?: string; // Backend uses resumeUrl\r\n  attachment?: {\r\n    base64: string;\r\n    fileName: string;\r\n    fileType: string;\r\n  };\r\n  status: string;\r\n  score: number;\r\n  email: string;\r\n  phone: string;\r\n  position: string;\r\n  experience: number;\r\n  jobId: number;\r\n}\r\n\r\n// Frontend candidate structure (for forms and display)\r\nexport interface Candidate {\r\n  id?: number;\r\n  name: string;\r\n  role: string;\r\n  appliedRole: string;\r\n  department: string;\r\n  employmentType: string;\r\n  workType: string;\r\n  appliedDate: string; // Frontend uses appliedDate\r\n  attachments: string; // For display purposes\r\n  status: string;\r\n  score: number;\r\n  email: string;\r\n  phone: string;\r\n  position: string;\r\n  experience: number;\r\n  jobId?: number;\r\n}\r\n\r\n// Request structure for creating/updating candidates (what API expects)\r\nexport interface CreateCandidateRequest {\r\n  name: string;\r\n  role: string;\r\n  appliedRole: string;\r\n  department: string;\r\n  employmentType: string;\r\n  workType: string;\r\n  appliedDateStr: string; // Backend expects appliedDateStr\r\n  resumeUrl?: string; // Backend expects resumeUrl\r\n  status: string;\r\n  score: number;\r\n  email: string;\r\n  phone: string;\r\n  position: string;\r\n  experience: number;\r\n  jobId: number;\r\n}\r\n\r\n// New interfaces for assessment steps\r\nexport interface CandidateStep {\r\n  id: number;\r\n  candidateId: number;\r\n  assessmentId: number | null;\r\n  stepOrder: number | null;\r\n  stepName: string;\r\n  status: string;\r\n  completed: boolean;\r\n  score: number;\r\n}\r\n\r\nexport interface CandidateAssessment {\r\n  candidateId: number;\r\n  steps: CandidateStep[];\r\n}\r\n\r\nexport interface Assessment {\r\n  id: number;\r\n  jobId: number;\r\n  stepOrder: number;\r\n  stepName: string;\r\n  mode: string;\r\n  passingCriteria: string;\r\n}\r\n\r\nexport interface ApiError {\r\n  error: string;\r\n}\r\n\r\nexport interface Review {\r\n  id?: number;\r\n  stepId: number;\r\n  reviewer: string;\r\n  feedback: string;\r\n  score: number;\r\n  createdAt?: string;\r\n}\r\n\r\nexport interface CreateReviewRequest {\r\n  reviewer: string;\r\n  feedback: string;\r\n  score: number;\r\n}\r\n\r\nexport interface AssessmentStepPayload {\r\n  jobId: number;\r\n  stepOrder: number;\r\n  stepName: string;\r\n  mode: string;\r\n  passingCriteria: string;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ApiService {\r\n  private baseUrl = \"http://172.30.12.158:8080\";\r\n\r\n  private apiKey = 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJiaGFza2FyIiwiaWF0IjoxNzQ5ODAzMzg4LCJleHAiOjE3NDk4MzkzODh9.vs518QlQXCvHB-YUhauw9Pzbi_cg14F8z5j9SIsSINc';\r\n\r\n  private httpOptions = {\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'ngrok-skip-browser-warning': 'true',\r\n      'Authorization': `Bearer ${this.apiKey}`\r\n    }\r\n  };\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  // Transform backend candidate to frontend candidate\r\n  private transformCandidate(backendCandidate: BackendCandidate): Candidate {\r\n    return {\r\n      id: backendCandidate.id,\r\n      name: backendCandidate.name,\r\n      role: backendCandidate.role,\r\n      appliedRole: backendCandidate.appliedRole,\r\n      department: backendCandidate.department,\r\n      employmentType: backendCandidate.employmentType,\r\n      workType: backendCandidate.workType,\r\n      appliedDate: backendCandidate.appliedDateStr, // Map appliedDateStr to appliedDate\r\n      attachments: backendCandidate.resumeUrl || backendCandidate.attachment?.fileName || 'No attachment',\r\n      status: backendCandidate.status,\r\n      score: backendCandidate.score,\r\n      email: backendCandidate.email,\r\n      phone: backendCandidate.phone,\r\n      position: backendCandidate.position,\r\n      experience: backendCandidate.experience,\r\n      jobId: backendCandidate.jobId\r\n    };\r\n  }\r\n\r\n  // Transform frontend candidate to backend request format\r\n  private transformCandidateForAPI(candidate: Candidate): CreateCandidateRequest {\r\n    return {\r\n      name: candidate.name,\r\n      role: candidate.role,\r\n      appliedRole: candidate.appliedRole,\r\n      department: candidate.department,\r\n      employmentType: candidate.employmentType,\r\n      workType: candidate.workType,\r\n      appliedDateStr: candidate.appliedDate, // Map appliedDate to appliedDateStr\r\n      resumeUrl: candidate.attachments !== 'No attachment' ? candidate.attachments : undefined,\r\n      status: candidate.status,\r\n      score: Number(candidate.score),\r\n      email: candidate.email,\r\n      phone: candidate.phone,\r\n      position: candidate.position,\r\n      experience: Number(candidate.experience),\r\n      jobId: candidate.jobId || 1\r\n    };\r\n  }\r\n  getAssessmentTemplates(): Observable<AssessmentTemplate[]> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<AssessmentTemplate[]>(`${this.baseUrl}/api/assessment-templates`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  getAssessmentTemplatesByRole(role: string): Observable<AssessmentTemplate[]> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<AssessmentTemplate[]>(`${this.baseUrl}/api/assessment-templates/role/${role}`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n  // Auth methods\r\n  login(credentials: LoginRequest): Observable<LoginResponse> {\r\n    return this.http.post<LoginResponse>(`${this.baseUrl}/api/auth/login`, credentials, this.httpOptions)\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  register(userData: RegisterRequest): Observable<any> {\r\n    return this.http.post<any>(`${this.baseUrl}/api/users`, userData, this.httpOptions)\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  // Job methods\r\n  createJob(jobData: CreateJobRequest): Observable<Job> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.post<Job>(`${this.baseUrl}/api/jobs`, jobData, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  getJobs(): Observable<Job[]> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<Job[]>(`${this.baseUrl}/api/jobs`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  updateJob(id: number, jobData: CreateJobRequest): Observable<Job> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.put<Job>(`${this.baseUrl}/api/jobs/${id}`, jobData, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  deleteJob(id: number): Observable<any> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.delete(`${this.baseUrl}/api/jobs/${id}`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  getJobById(id: number): Observable<Job> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<Job>(`${this.baseUrl}/api/jobs/${id}`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  // Candidate methods - Updated to handle both FormData and JSON\r\n  createCandidate(candidateData: FormData | Candidate): Observable<Candidate> {\r\n    if (candidateData instanceof FormData) {\r\n      const headers = new HttpHeaders({\r\n        'ngrok-skip-browser-warning': 'true',\r\n        'Authorization': `Bearer ${this.apiKey}`\r\n      });\r\n\r\n      return this.http.post<BackendCandidate>(`${this.baseUrl}/api/candidates`, candidateData, { headers })\r\n        .pipe(\r\n          map(candidate => this.transformCandidate(candidate)),\r\n          catchError(this.handleError)\r\n        );\r\n    } else {\r\n      const requestData = this.transformCandidateForAPI(candidateData);\r\n      return this.http.post<BackendCandidate>(`${this.baseUrl}/api/candidates`, requestData, this.httpOptions)\r\n        .pipe(\r\n          map(candidate => this.transformCandidate(candidate)),\r\n          catchError(this.handleError)\r\n        );\r\n    }\r\n  }\r\n\r\n  getCandidates(): Observable<Candidate[]> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<BackendCandidate[]>(`${this.baseUrl}/api/candidates`, { headers })\r\n      .pipe(\r\n        map(candidates => candidates.map(candidate => this.transformCandidate(candidate))),\r\n        catchError(this.handleError)\r\n      );\r\n  }\r\n\r\n  getCandidateById(id: number): Observable<Candidate> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<BackendCandidate>(`${this.baseUrl}/api/candidates/${id}`, { headers })\r\n      .pipe(\r\n        map(candidate => this.transformCandidate(candidate)),\r\n        catchError(this.handleError)\r\n      );\r\n  }\r\n\r\n  updateCandidate(id: number, candidateData: FormData | Candidate): Observable<Candidate> {\r\n    if (candidateData instanceof FormData) {\r\n      const headers = new HttpHeaders({\r\n        'ngrok-skip-browser-warning': 'true',\r\n        'Authorization': `Bearer ${this.apiKey}`\r\n      });\r\n\r\n      return this.http.put<BackendCandidate>(`${this.baseUrl}/api/candidates/${id}`, candidateData, { headers })\r\n        .pipe(\r\n          map(candidate => this.transformCandidate(candidate)),\r\n          catchError(this.handleError)\r\n        );\r\n    } else {\r\n      const requestData = this.transformCandidateForAPI(candidateData);\r\n      const headers = this.getAuthHeaders();\r\n      return this.http.put<BackendCandidate>(`${this.baseUrl}/api/candidates/${id}`, requestData, { headers })\r\n        .pipe(\r\n          map(candidate => this.transformCandidate(candidate)),\r\n          catchError(this.handleError)\r\n        );\r\n    }\r\n  }\r\n\r\n  deleteCandidate(id: number): Observable<any> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.delete(`${this.baseUrl}/api/candidates/${id}`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  // NEW: Assessment/Steps methods\r\n  getCandidateSteps(candidateId: number): Observable<CandidateStep[]> {\r\n    const headers = this.getAuthHeaders();\r\n    // Expect { steps: CandidateStep[] }\r\n    return this.http.get<{ steps: CandidateStep[] }>(`${this.baseUrl}/api/candidate-steps/by-candidate/${candidateId}`, { headers })\r\n      .pipe(\r\n        map(res => res.steps), // Extract steps array\r\n        catchError(this.handleError)\r\n      );\r\n  }\r\n\r\n  getCandidateAssessment(candidateId: number): Observable<CandidateAssessment> {\r\n    return this.getCandidateSteps(candidateId).pipe(\r\n      map(steps => ({\r\n        candidateId: candidateId,\r\n        steps: steps\r\n      }))\r\n    );\r\n  }\r\n\r\n  createAssessment(steps: AssessmentStepPayload[]): Observable<any> {\r\n    const headers = this.getAuthHeaders();\r\n    // Use /bulk endpoint for array payload\r\n    return this.http.post<any>(`${this.baseUrl}/api/assessments/bulk`, steps, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  getAssessments(): Observable<Assessment[]> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.get<Assessment[]>(`${this.baseUrl}/api/assessments`, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  // Review methods\r\n  createReview(stepId: number, reviewData: CreateReviewRequest): Observable<Review> {\r\n    const headers = this.getAuthHeaders();\r\n    return this.http.post<Review>(`${this.baseUrl}/reviews/step/${stepId}`, reviewData, { headers })\r\n      .pipe(catchError(this.handleError));\r\n  }\r\n\r\n  // Helper method to get step status summary\r\n  getStepStatusSummary(steps: CandidateStep[]): { completed: number; total: number; currentStep: string | null } {\r\n    const completedSteps = steps.filter(step => step.completed).length;\r\n    const totalSteps = steps.length;\r\n    const currentStep = steps.find(step => !step.completed && step.status !== 'COMPLETED')?.stepName || null;\r\n\r\n    return {\r\n      completed: completedSteps,\r\n      total: totalSteps,\r\n      currentStep: currentStep\r\n    };\r\n  }\r\n\r\n  private getAuthHeaders(): HttpHeaders {\r\n    const token = localStorage.getItem('token');\r\n    let headers = new HttpHeaders({\r\n      'Content-Type': 'application/json',\r\n      'ngrok-skip-browser-warning': 'true',\r\n      'Authorization': `Bearer ${this.apiKey}`\r\n    });\r\n\r\n    if (token) {\r\n      headers = headers.set('X-User-Token', token);\r\n    }\r\n\r\n    return headers;\r\n  }\r\n\r\n  private handleError(error: HttpErrorResponse) {\r\n    let errorMessage = 'An unknown error occurred';\r\n\r\n    if (error.error instanceof ErrorEvent) {\r\n      errorMessage = error.error.message;\r\n    } else {\r\n      if (error.error && error.error.error) {\r\n        errorMessage = error.error.error;\r\n      } else if (error.error && typeof error.error === 'string') {\r\n        errorMessage = error.error;\r\n      } else {\r\n        errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n      }\r\n    }\r\n\r\n    return throwError(() => errorMessage);\r\n  }\r\n\r\n  static getFallbackJobs(): Job[] {\r\n    return [\r\n      {\r\n        id: 1,\r\n        title: 'Software Engineer',\r\n        role: 'Backend Developer',\r\n        location: 'Bangalore',\r\n        description: 'Build scalable APIs.',\r\n        isActive: true,\r\n        salaryMin: 1000000,\r\n        salaryMax: 2000000,\r\n        type: 'Full-time',\r\n        level: 'Mid'\r\n      },\r\n      {\r\n        id: 2,\r\n        title: 'Frontend Developer',\r\n        role: 'Frontend Developer',\r\n        location: 'Mumbai',\r\n        description: 'Create responsive user interfaces.',\r\n        isActive: true,\r\n        salaryMin: 800000,\r\n        salaryMax: 1500000,\r\n        type: 'Full-time',\r\n        level: 'Entry-level'\r\n      }\r\n    ];\r\n  }\r\n\r\n  static getFallbackCandidates(): Candidate[] {\r\n    return [\r\n      {\r\n        id: 1,\r\n        name: 'Sophia Turner',\r\n        role: 'Legal Advisor',\r\n        appliedRole: 'Legal Advisor',\r\n        department: 'Legal',\r\n        employmentType: 'Full-time',\r\n        workType: 'Hybrid',\r\n        appliedDate: '2030-10-01',\r\n        attachments: 'Resume, Cover Letter',\r\n        status: 'Interview',\r\n        score: 50,\r\n        email: 'sophia@example.com',\r\n        phone: '1234567890',\r\n        position: 'Legal Advisor',\r\n        experience: 5,\r\n        jobId: 1\r\n      },\r\n      {\r\n        id: 2,\r\n        name: 'John Smith',\r\n        role: 'Software Engineer',\r\n        appliedRole: 'Software Engineer',\r\n        department: 'Engineering',\r\n        employmentType: 'Full-time',\r\n        workType: 'Remote',\r\n        appliedDate: '2030-10-02',\r\n        attachments: 'Resume, Cover Letter',\r\n        status: 'In-Review',\r\n        score: 75,\r\n        email: 'john@example.com',\r\n        phone: '1234567891',\r\n        position: 'Software Engineer',\r\n        experience: 3,\r\n        jobId: 2\r\n      },\r\n      {\r\n        id: 3,\r\n        name: 'Emily Johnson',\r\n        role: 'Marketing Manager',\r\n        appliedRole: 'Marketing Manager',\r\n        department: 'Marketing',\r\n        employmentType: 'Full-time',\r\n        workType: 'Onsite',\r\n        appliedDate: '2030-10-03',\r\n        attachments: 'Resume, Cover Letter',\r\n        status: 'Hired',\r\n        score: 90,\r\n        email: 'emily@example.com',\r\n        phone: '1234567892',\r\n        position: 'Marketing Manager',\r\n        experience: 7,\r\n        jobId: 1\r\n      },\r\n      {\r\n        id: 4,\r\n        name: 'Michael Brown',\r\n        role: 'Data Analyst',\r\n        appliedRole: 'Data Analyst',\r\n        department: 'Analytics',\r\n        employmentType: 'Contract',\r\n        workType: 'Hybrid',\r\n        appliedDate: '2030-10-04',\r\n        attachments: 'Resume, Cover Letter',\r\n        status: 'Rejected',\r\n        score: 35,\r\n        email: 'michael@example.com',\r\n        phone: '1234567893',\r\n        position: 'Data Analyst',\r\n        experience: 2,\r\n        jobId: 2\r\n      }\r\n    ];\r\n  }\r\n\r\n  // NEW: Fallback assessment steps for testing\r\n  static getFallbackCandidateSteps(candidateId: number): CandidateStep[] {\r\n    const stepTemplates = [\r\n      { stepName: 'Application Review', status: 'COMPLETED', completed: true, score: 85 },\r\n      { stepName: 'Resume Screening', status: 'COMPLETED', completed: true, score: 90 },\r\n      { stepName: 'Technical Interview', status: 'PENDING', completed: false, score: 0 },\r\n      { stepName: 'HR Interview', status: 'PENDING', completed: false, score: 0 },\r\n      { stepName: 'Final Decision', status: 'PENDING', completed: false, score: 0 }\r\n    ];\r\n\r\n    return stepTemplates.map((template, index) => ({\r\n      id: candidateId * 10 + index + 1,\r\n      candidateId: candidateId,\r\n      assessmentId: null,\r\n      stepOrder: index + 1,\r\n      stepName: template.stepName,\r\n      status: template.status,\r\n      completed: template.completed,\r\n      score: template.score // <-- Add this line\r\n    }));\r\n  }\r\n\r\n  static getFallbackAssessments(): Assessment[] {\r\n    return [\r\n      {\r\n        id: 1,\r\n        jobId: 1,\r\n        stepOrder: 1,\r\n        stepName: 'Technical Round',\r\n        mode: 'Video Conferencing',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 2,\r\n        jobId: 1,\r\n        stepOrder: 2,\r\n        stepName: 'Managerial Round',\r\n        mode: 'In-Person',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 3,\r\n        jobId: 2,\r\n        stepOrder: 1,\r\n        stepName: 'HR Round',\r\n        mode: 'Phone',\r\n        passingCriteria: 'Qualified'\r\n      },\r\n      {\r\n        id: 4,\r\n        jobId: 3,\r\n        stepOrder: 1,\r\n        stepName: 'Technical Round',\r\n        mode: 'Video Conferencing',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 5,\r\n        jobId: 3,\r\n        stepOrder: 2,\r\n        stepName: 'Managerial Round',\r\n        mode: 'In-Person',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 6,\r\n        jobId: 3,\r\n        stepOrder: 3,\r\n        stepName: 'HR Round',\r\n        mode: 'Phone',\r\n        passingCriteria: 'Qualified'\r\n      },\r\n      {\r\n        id: 7,\r\n        jobId: 4,\r\n        stepOrder: 1,\r\n        stepName: 'Technical Round',\r\n        mode: 'Video Conferencing',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 8,\r\n        jobId: 4,\r\n        stepOrder: 2,\r\n        stepName: 'Managerial Round',\r\n        mode: 'In-Person',\r\n        passingCriteria: 'Pass'\r\n      },\r\n      {\r\n        id: 9,\r\n        jobId: 4,\r\n        stepOrder: 1,\r\n        stepName: 'HR Round',\r\n        mode: 'Phone',\r\n        passingCriteria: 'Qualified'\r\n      }\r\n    ];\r\n  }\r\n}"],
  "mappings": "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",
  "names": ["EVENT_MANAGER_PLUGINS", "InjectionToken", "EventManager", "_zone", "_plugins", "_eventNameToPlugin", "Map", "constructor", "plugins", "forEach", "plugin", "manager", "slice", "reverse", "addEventListener", "element", "eventName", "handler", "options", "_findPluginFor", "getZone", "get", "find", "supports", "_RuntimeError", "ngDevMode", "set", "\u0275fac", "__ngFactoryType__", "\u0275\u0275inject", "NgZone", "\u0275\u0275defineInjectable", "token", "factory", "EventManagerPlugin", "_doc", "APP_ID_ATTRIBUTE_NAME", "removeElements", "elements", "remove", "createStyleElement", "style", "doc", "styleElement", "createElement", "textContent", "addServerStyles", "appId", "inline", "external", "head", "querySelectorAll", "removeAttribute", "HTMLLinkElement", "href", "lastIndexOf", "usage", "createLinkElement", "url", "linkElement", "setAttribute", "SharedStylesHost", "nonce", "hosts", "Set", "isServer", "platformId", "isPlatformServer", "add", "addStyles", "styles", "urls", "value", "addUsage", "removeStyles", "removeUsage", "usages", "creator", "record", "map", "host", "addElement", "delete", "ngOnDestroy", "clear", "addHost", "hostNode", "push", "removeHost", "appendChild", "DOCUMENT", "APP_ID", "CSP_NONCE", "PLATFORM_ID", "NAMESPACE_URIS", "COMPONENT_REGEX", "COMPONENT_VARIABLE", "HOST_ATTR", "CONTENT_ATTR", "REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT", "REMOVE_STYLES_ON_COMPONENT_DESTROY", "InjectionToken", "providedIn", "factory", "shimContentAttribute", "componentShortId", "replace", "COMPONENT_REGEX", "shimHostAttribute", "shimStylesContent", "compId", "styles", "map", "s", "DomRendererFactory2", "eventManager", "sharedStylesHost", "appId", "removeStylesOnCompDestroy", "doc", "platformId", "ngZone", "nonce", "tracingService", "rendererByCompId", "Map", "defaultRenderer", "platformIsServer", "constructor", "isPlatformServer", "DefaultDomRenderer2", "createRenderer", "element", "type", "encapsulation", "ViewEncapsulation", "ShadowDom", "__spreadProps", "__spreadValues", "Emulated", "renderer", "getOrCreateRenderer", "EmulatedEncapsulationDomRenderer2", "applyToHost", "NoneEncapsulationDomRenderer", "applyStyles", "get", "id", "ShadowDomRenderer", "set", "ngOnDestroy", "clear", "componentReplaced", "componentId", "delete", "\u0275fac", "__ngFactoryType__", "\u0275\u0275inject", "EventManager", "SharedStylesHost", "APP_ID", "REMOVE_STYLES_ON_COMPONENT_DESTROY", "DOCUMENT", "PLATFORM_ID", "NgZone", "CSP_NONCE", "_TracingService", "\u0275prov", "\u0275\u0275defineInjectable", "token", "factory", "data", "Object", "create", "throwOnSyntheticProps", "destroy", "destroyNode", "createElement", "name", "namespace", "createElementNS", "NAMESPACE_URIS", "createComment", "value", "createText", "createTextNode", "appendChild", "parent", "newChild", "isTemplateNode", "content", "insertBefore", "refChild", "removeChild", "_parent", "oldChild", "remove", "selectRootElement", "selectorOrNode", "preserveContent", "el", "querySelector", "_RuntimeError", "ngDevMode", "textContent", "parentNode", "node", "nextSibling", "setAttribute", "namespaceUri", "setAttributeNS", "removeAttribute", "removeAttributeNS", "addClass", "classList", "add", "removeClass", "setStyle", "style", "flags", "RendererStyleFlags2", "DashCase", "Important", "setProperty", "removeStyle", "removeProperty", "setValue", "nodeValue", "listen", "target", "event", "callback", "options", "_getDOM", "getGlobalEventTarget", "wrappedCallback", "decoratePreventDefault", "wrapEventListener", "addEventListener", "eventHandler", "runGuarded", "preventDefault", "isTemplateNode", "node", "tagName", "content", "undefined", "ShadowDomRenderer", "DefaultDomRenderer2", "sharedStylesHost", "hostEl", "shadowRoot", "constructor", "eventManager", "component", "doc", "ngZone", "nonce", "platformIsServer", "tracingService", "attachShadow", "mode", "addHost", "styles", "shimStylesContent", "id", "style", "styleEl", "document", "createElement", "setAttribute", "textContent", "appendChild", "styleUrls", "getExternalStyles", "styleUrl", "linkEl", "createLinkElement", "nodeOrShadowRoot", "parent", "newChild", "insertBefore", "refChild", "removeChild", "_parent", "oldChild", "parentNode", "destroy", "removeHost", "NoneEncapsulationDomRenderer", "removeStylesOnCompDestroy", "compId", "applyStyles", "addStyles", "removeStyles", "EmulatedEncapsulationDomRenderer2", "contentAttr", "hostAttr", "appId", "shimContentAttribute", "shimHostAttribute", "applyToHost", "element", "name", "el", "BrowserDomAdapter", "_DomAdapter", "supportsDOMEvents", "makeCurrent", "_setRootDomAdapter", "onAndCancel", "el", "evt", "listener", "options", "addEventListener", "removeEventListener", "dispatchEvent", "remove", "node", "createElement", "tagName", "doc", "getDefaultDocument", "createHtmlDocument", "document", "implementation", "createHTMLDocument", "isElementNode", "nodeType", "Node", "ELEMENT_NODE", "isShadowRoot", "DocumentFragment", "getGlobalEventTarget", "target", "window", "body", "getBaseHref", "href", "getBaseElementHref", "relativePath", "resetBaseElement", "baseElement", "getUserAgent", "navigator", "userAgent", "getCookie", "name", "_parseCookieValue", "cookie", "querySelector", "getAttribute", "url", "URL", "baseURI", "pathname", "BrowserXhr", "build", "XMLHttpRequest", "factory", "\u0275fac", "DomEventsPlugin", "EventManagerPlugin", "constructor", "doc", "supports", "eventName", "addEventListener", "element", "handler", "options", "removeEventListener", "target", "callback", "__ngFactoryType__", "\u0275\u0275inject", "DOCUMENT", "MODIFIER_KEYS", "_keyMap", "MODIFIER_KEY_GETTERS", "event", "altKey", "ctrlKey", "metaKey", "shiftKey", "KeyEventsPlugin", "parseEventName", "parsedEvent", "outsideHandler", "eventCallback", "manager", "getZone", "runOutsideAngular", "_getDOM", "onAndCancel", "parts", "toLowerCase", "split", "domEventName", "shift", "length", "key", "_normalizeKey", "pop", "fullKey", "codeIX", "indexOf", "splice", "forEach", "modifierName", "index", "result", "matchEventFullKeyCode", "fullKeyCode", "keycode", "code", "modifierGetter", "zone", "runGuarded", "keyName", "bootstrapApplication", "rootComponent", "_internalCreateApplication", "__spreadValues", "createProvidersConfig", "createProvidersConfig", "options", "appProviders", "BROWSER_MODULE_PROVIDERS", "providers", "platformProviders", "INTERNAL_BROWSER_PLATFORM_PROVIDERS", "initDomAdapter", "BrowserDomAdapter", "makeCurrent", "errorHandler", "ErrorHandler", "_document", "_setDocument", "document", "INTERNAL_BROWSER_PLATFORM_PROVIDERS", "provide", "PLATFORM_ID", "useValue", "_PLATFORM_BROWSER_ID", "PLATFORM_INITIALIZER", "multi", "DOCUMENT", "useFactory", "BROWSER_MODULE_PROVIDERS", "provide", "_INJECTOR_SCOPE", "useValue", "ErrorHandler", "useFactory", "errorHandler", "EVENT_MANAGER_PLUGINS", "useClass", "DomEventsPlugin", "multi", "deps", "DOCUMENT", "KeyEventsPlugin", "DomRendererFactory2", "SharedStylesHost", "EventManager", "RendererFactory2", "useExisting", "XhrFactory", "BrowserXhr", "HttpHandler", "HttpBackend", "HttpHeaders", "headers", "normalizedNames", "Map", "lazyInit", "lazyUpdate", "constructor", "split", "forEach", "line", "index", "indexOf", "name", "slice", "value", "trim", "addHeaderEntry", "Headers", "Object", "entries", "values", "setHeaderEntries", "has", "init", "toLowerCase", "get", "length", "keys", "Array", "from", "getAll", "append", "clone", "op", "set", "delete", "maybeSetNormalizedName", "lcName", "copyFrom", "update", "applyUpdate", "other", "key", "concat", "base", "undefined", "push", "toDelete", "existing", "filter", "headerValues", "isArray", "map", "toString", "fn", "HttpUrlEncodingCodec", "encodeKey", "key", "standardEncoding", "encodeValue", "value", "decodeKey", "decodeURIComponent", "decodeValue", "paramParser", "rawParams", "codec", "map", "Map", "length", "replace", "split", "forEach", "param", "eqIdx", "indexOf", "val", "slice", "list", "get", "push", "set", "STANDARD_ENCODING_REGEX", "STANDARD_ENCODING_REPLACEMENTS", "v", "encodeURIComponent", "s", "t", "valueToString", "HttpParams", "encoder", "updates", "cloneFrom", "constructor", "options", "fromString", "fromObject", "_RuntimeError", "ngDevMode", "Object", "keys", "values", "Array", "isArray", "has", "init", "res", "getAll", "from", "append", "clone", "op", "appendAll", "params", "_value", "delete", "toString", "eKey", "join", "filter", "update", "concat", "base", "undefined", "idx", "splice", "HttpContext", "map", "Map", "set", "token", "value", "get", "has", "defaultValue", "delete", "keys", "mightHaveBody", "method", "isArrayBuffer", "ArrayBuffer", "isBlob", "Blob", "isFormData", "FormData", "isUrlSearchParams", "URLSearchParams", "CONTENT_TYPE_HEADER", "ACCEPT_HEADER", "X_REQUEST_URL_HEADER", "TEXT_CONTENT_TYPE", "JSON_CONTENT_TYPE", "ACCEPT_HEADER_VALUE", "HttpRequest", "url", "body", "headers", "context", "reportProgress", "withCredentials", "responseType", "params", "urlWithParams", "transferCache", "constructor", "third", "fourth", "toUpperCase", "options", "undefined", "HttpHeaders", "HttpParams", "toString", "length", "qIdx", "indexOf", "sep", "serializeBody", "Array", "isArray", "JSON", "stringify", "detectContentTypeHeader", "type", "clone", "update", "setHeaders", "Object", "reduce", "name", "setParams", "param", "HttpEventType", "HttpResponseBase", "status", "statusText", "ok", "init", "defaultStatus", "defaultStatusText", "HttpHeaderResponse", "ResponseHeader", "HttpResponse", "Response", "HttpErrorResponse", "message", "error", "HTTP_STATUS_CODE_OK", "HTTP_STATUS_CODE_NO_CONTENT", "addBody", "options", "body", "headers", "context", "observe", "params", "reportProgress", "responseType", "withCredentials", "transferCache", "HttpClient", "handler", "constructor", "request", "first", "url", "req", "HttpRequest", "HttpHeaders", "HttpParams", "fromObject", "undefined", "events$", "of", "pipe", "concatMap", "handle", "res$", "filter", "event", "HttpResponse", "map", "res", "ArrayBuffer", "_RuntimeError", "ngDevMode", "Blob", "delete", "get", "head", "jsonp", "callbackParam", "append", "patch", "post", "put", "\u0275\u0275inject", "HttpHandler", "factory", "\u0275fac", "FETCH_BACKEND", "InjectionToken", "interceptorChainEndFn", "req", "finalHandlerFn", "chainedInterceptorFn", "chainTailFn", "interceptorFn", "injector", "initialRequest", "finalHandlerFn", "runInInjectionContext", "downstreamRequest", "HTTP_INTERCEPTOR_FNS", "InjectionToken", "HTTP_ROOT_INTERCEPTOR_FNS", "REQUESTS_CONTRIBUTE_TO_STABILITY", "providedIn", "factory", "HttpInterceptorHandler", "HttpHandler", "backend", "injector", "chain", "pendingTasks", "inject", "_PendingTasksInternal", "contributeToStability", "REQUESTS_CONTRIBUTE_TO_STABILITY", "constructor", "handle", "initialRequest", "dedupedInterceptorFns", "Array", "from", "Set", "get", "HTTP_INTERCEPTOR_FNS", "HTTP_ROOT_INTERCEPTOR_FNS", "reduceRight", "nextSequencedFn", "interceptorFn", "chainedInterceptorFn", "interceptorChainEndFn", "taskId", "add", "downstreamRequest", "pipe", "finalize", "remove", "\u0275\u0275inject", "HttpBackend", "EnvironmentInjector", "factory", "\u0275fac", "XSSI_PREFIX", "X_REQUEST_URL_REGEXP", "RegExp", "X_REQUEST_URL_HEADER", "getResponseUrl", "xhr", "responseURL", "test", "getAllResponseHeaders", "getResponseHeader", "HttpXhrBackend", "xhrFactory", "constructor", "handle", "req", "method", "_RuntimeError", "ngDevMode", "\u0275loadImpl", "from", "of", "pipe", "switchMap", "Observable", "observer", "build", "open", "urlWithParams", "withCredentials", "headers", "forEach", "name", "values", "setRequestHeader", "join", "has", "ACCEPT_HEADER", "ACCEPT_HEADER_VALUE", "CONTENT_TYPE_HEADER", "detectedType", "detectContentTypeHeader", "responseType", "toLowerCase", "reqBody", "serializeBody", "headerResponse", "partialFromXhr", "statusText", "HttpHeaders", "url", "HttpHeaderResponse", "status", "onLoad", "body", "HTTP_STATUS_CODE_NO_CONTENT", "response", "responseText", "HTTP_STATUS_CODE_OK", "ok", "originalBody", "replace", "JSON", "parse", "error", "text", "next", "HttpResponse", "undefined", "complete", "HttpErrorResponse", "onError", "res", "sentHeaders", "onDownProgress", "event", "progressEvent", "type", "HttpEventType", "DownloadProgress", "loaded", "lengthComputable", "total", "partialText", "onUpProgress", "progress", "UploadProgress", "addEventListener", "reportProgress", "upload", "send", "Sent", "removeEventListener", "readyState", "DONE", "abort", "\u0275\u0275inject", "XhrFactory", "factory", "\u0275fac", "XSRF_ENABLED", "InjectionToken", "XSRF_DEFAULT_COOKIE_NAME", "XSRF_COOKIE_NAME", "providedIn", "XSRF_DEFAULT_HEADER_NAME", "XSRF_HEADER_NAME", "HttpXsrfTokenExtractor", "HttpXsrfCookieExtractor", "doc", "cookieName", "lastCookieString", "lastToken", "parseCount", "getToken", "cookieString", "cookie", "parseCookieValue", "DOCUMENT", "xsrfInterceptorFn", "lcUrl", "inject", "startsWith", "token", "headerName", "clone", "set", "provideHttpClient", "features", "providers", "HttpClient", "HttpXhrBackend", "HttpInterceptorHandler", "provide", "HttpHandler", "useExisting", "HttpBackend", "useFactory", "inject", "FETCH_BACKEND", "optional", "HTTP_INTERCEPTOR_FNS", "useValue", "xsrfInterceptorFn", "multi", "XSRF_ENABLED", "HttpXsrfTokenExtractor", "useClass", "HttpXsrfCookieExtractor", "feature", "push", "\u0275providers", "makeEnvironmentProviders", "Title", "_doc", "constructor", "getTitle", "title", "setTitle", "newTitle", "\u0275fac", "__ngFactoryType__", "\u0275\u0275inject", "DOCUMENT", "\u0275prov", "\u0275\u0275defineInjectable", "token", "factory", "providedIn", "PRIMARY_OUTLET", "RouteTitleKey", "Symbol", "ParamsAsMap", "params", "constructor", "has", "name", "Object", "prototype", "hasOwnProperty", "call", "get", "v", "Array", "isArray", "getAll", "keys", "convertToParamMap", "defaultUrlMatcher", "segments", "segmentGroup", "route", "parts", "path", "split", "length", "pathMatch", "hasChildren", "posParams", "index", "part", "segment", "substring", "consumed", "slice", "shallowEqualArrays", "a", "b", "i", "shallowEqual", "k1", "getDataKeys", "undefined", "k2", "key", "equalArraysOrString", "obj", "getOwnPropertySymbols", "aSorted", "sort", "bSorted", "every", "val", "last", "wrapIntoObservable", "value", "isObservable", "_isPromise", "from", "Promise", "resolve", "of", "pathCompareMap", "equalSegmentGroups", "containsSegmentGroup", "paramCompareMap", "equalParams", "containsParams", "ignored", "containsTree", "container", "containee", "options", "paths", "root", "matrixParams", "queryParams", "fragment", "equalPath", "matrixParamsMatch", "numberOfChildren", "c", "children", "containsSegmentGroupHelper", "containeePaths", "current", "next", "containerPaths", "containeeSegment", "parameters", "UrlTree", "_queryParamMap", "UrlSegmentGroup", "queryParamMap", "toString", "DEFAULT_SERIALIZER", "serialize", "parent", "values", "forEach", "serializePaths", "UrlSegment", "_parameterMap", "parameterMap", "serializePath", "equalSegments", "as", "bs", "mapChildrenIntoArray", "fn", "res", "entries", "childOutlet", "child", "concat", "UrlSerializer", "factory", "DefaultUrlSerializer", "providedIn", "parse", "url", "p", "UrlParser", "parseRootSegment", "parseQueryParams", "parseFragment", "tree", "serializeSegment", "query", "serializeQueryParams", "encodeUriFragment", "map", "join", "primary", "k", "push", "encodeUriString", "s", "encodeURIComponent", "replace", "encodeUriQuery", "encodeURI", "encodeUriSegment", "decode", "decodeURIComponent", "decodeQuery", "serializeMatrixParams", "strParams", "filter", "SEGMENT_RE", "matchSegments", "str", "match", "MATRIX_PARAM_SEGMENT_RE", "matchMatrixKeySegments", "QUERY_PARAM_RE", "matchQueryParams", "QUERY_PARAM_VALUE_RE", "matchUrlQueryParamValue", "remaining", "consumeOptional", "peekStartsWith", "parseChildren", "parseQueryParam", "parseSegment", "capture", "parseParens", "_RuntimeError", "ngDevMode", "parseMatrixParams", "parseParam", "valueMatch", "decodedKey", "decodedVal", "currentVal", "allowPrimary", "outletName", "indexOf", "startsWith", "createRoot", "rootCandidate", "squashSegmentGroup", "newChildren", "childCandidate", "grandChildOutlet", "grandChild", "mergeTrivialChildren", "isUrlTree", "createUrlTreeFromSnapshot", "relativeTo", "commands", "relativeToUrlSegmentGroup", "createSegmentGroupFromRoute", "createUrlTreeFromSegmentGroup", "targetGroup", "createSegmentGroupFromRouteRecursive", "currentRoute", "childOutlets", "childSnapshot", "outlet", "rootSegmentGroup", "nav", "computeNavigation", "toRoot", "position", "findStartingPositionForTargetGroup", "newSegmentGroup", "processChildren", "updateSegmentGroupChildren", "updateSegmentGroup", "isMatrixParams", "command", "outlets", "segmentPath", "isCommandWithOutlets", "oldRoot", "oldSegmentGroup", "qp", "replaceSegment", "newRoot", "oldSegment", "newSegment", "Navigation", "isAbsolute", "numberOfDoubleDots", "cmdWithOutlet", "find", "reduce", "cmd", "cmdIdx", "urlPart", "partIndex", "Position", "target", "NaN", "modifier", "createPositionApplyingDoubleDots", "group", "g", "ci", "dd", "getOutlets", "startIndex", "m", "prefixedWith", "slicedCommands", "commandIndex", "pathIndex", "createNewSegmentGroup", "some", "o", "childrenOfEmptyChild", "currentCommandIndex", "currentPathIndex", "noMatch", "curr", "compare", "createNewSegmentChildren", "stringify", "IMPERATIVE_NAVIGATION", "EventType", "RouterEvent", "id", "NavigationStart", "type", "navigationTrigger", "restoredState", "NavigationEnd", "urlAfterRedirects", "NavigationCancellationCode", "NavigationSkippedCode", "NavigationCancel", "reason", "code", "NavigationSkipped", "NavigationError", "error", "RoutesRecognized", "state", "GuardsCheckStart", "GuardsCheckEnd", "shouldActivate", "ResolveStart", "ResolveEnd", "RouteConfigLoadStart", "RouteConfigLoadEnd", "ChildActivationStart", "snapshot", "routeConfig", "ChildActivationEnd", "ActivationStart", "ActivationEnd", "Scroll", "routerEvent", "anchor", "pos", "BeforeActivateRoutes", "RedirectRequest", "navigationBehaviorOptions", "getOrCreateRouteInjectorIfNeeded", "route", "currentInjector", "providers", "_injector", "createEnvironmentInjector", "path", "getOutlet", "route", "outlet", "PRIMARY_OUTLET", "sortByMatchingOutlets", "routes", "outletName", "sortedConfig", "filter", "r", "push", "getClosestRouteInjector", "snapshot", "routeConfig", "_injector", "s", "parent", "_loadedInjector", "OutletContext", "rootInjector", "children", "attachRef", "injector", "constructor", "ChildrenOutletContexts", "contexts", "Map", "onChildOutletCreated", "childName", "context", "getOrCreateContext", "set", "onChildOutletDestroyed", "getContext", "onOutletDeactivated", "onOutletReAttached", "get", "\u0275\u0275inject", "EnvironmentInjector", "\u0275prov", "\u0275\u0275defineInjectable", "factory", "\u0275fac", "providedIn", "Tree", "_root", "root", "value", "t", "p", "pathFromRoot", "length", "n", "findNode", "map", "firstChild", "siblings", "findPath", "c", "cc", "node", "child", "path", "unshift", "TreeNode", "toString", "nodeChildrenAsMap", "forEach", "RouterState", "setRouterState", "createEmptyState", "rootComponent", "createEmptyStateSnapshot", "emptyUrl", "BehaviorSubject", "UrlSegment", "emptyParams", "emptyData", "emptyQueryParams", "fragment", "activated", "ActivatedRoute", "ActivatedRouteSnapshot", "RouterStateSnapshot", "urlSubject", "paramsSubject", "queryParamsSubject", "fragmentSubject", "dataSubject", "component", "_futureSnapshot", "_routerState", "_paramMap", "_queryParamMap", "title", "url", "params", "queryParams", "data", "futureSnapshot", "pipe", "d", "RouteTitleKey", "of", "undefined", "paramMap", "convertToParamMap", "queryParamMap", "getInherited", "paramsInheritanceStrategy", "inherited", "loadComponent", "__spreadValues", "resolve", "_resolvedData", "hasStaticTitle", "_resolve", "segment", "join", "matched", "serializeNode", "state", "advanceActivatedRoute", "currentSnapshot", "nextSnapshot", "shallowEqual", "next", "shallowEqualArrays", "equalParamsAndUrlSegments", "a", "b", "equalUrlParams", "equalSegments", "parentsMismatch", "config", "ROUTER_OUTLET_DATA", "InjectionToken", "RouterOutlet", "activatedComponentRef", "_activatedRoute", "name", "activateEvents", "EventEmitter", "deactivateEvents", "attachEvents", "detachEvents", "routerOutletData", "input", "parentContexts", "inject", "location", "ViewContainerRef", "changeDetector", "ChangeDetectorRef", "inputBinder", "INPUT_BINDER", "optional", "supportsBindingToComponentInputs", "ngOnChanges", "changes", "firstChange", "previousValue", "isTrackedInParentContexts", "deactivate", "initializeOutletWithName", "ngOnDestroy", "unsubscribeFromRouteData", "ngOnInit", "attach", "activateWith", "isActivated", "_RuntimeError", "ngDevMode", "instance", "activatedRoute", "activatedRouteData", "detach", "cmp", "emit", "ref", "insert", "hostView", "bindActivatedRouteToOutletComponent", "destroy", "environmentInjector", "childContexts", "OutletInjector", "createComponent", "index", "markForCheck", "selectors", "inputs", "outputs", "exportAs", "features", "\u0275\u0275NgOnChangesFeature", "outletData", "token", "notFoundValue", "RoutedComponentInputBinder", "outletDataSubscriptions", "subscribeToRouteData", "unsubscribe", "delete", "dataSubscription", "combineLatest", "switchMap", "Promise", "subscribe", "mirror", "reflectComponentType", "templateName", "setInput", "createRouterState", "routeReuseStrategy", "curr", "prevState", "createNode", "shouldReuseRoute", "createOrReuseChildren", "shouldAttach", "detachedRouteHandle", "retrieve", "tree", "createActivatedRoute", "RedirectCommand", "redirectTo", "navigationBehaviorOptions", "NAVIGATION_CANCELING_ERROR", "redirectingNavigationError", "urlSerializer", "redirect", "isUrlTree", "error", "navigationCancelingError", "NavigationCancellationCode", "Redirect", "message", "code", "Error", "cancellationCode", "isRedirectingNavigationCancelingError", "isNavigationCancelingError", "activateRoutes", "rootContexts", "routeReuseStrategy", "forwardEvent", "inputBindingEnabled", "map", "t", "ActivateRoutes", "targetRouterState", "currentRouterState", "activate", "futureState", "currState", "constructor", "parentContexts", "futureRoot", "_root", "currRoot", "deactivateChildRoutes", "advanceActivatedRoute", "root", "activateChildRoutes", "futureNode", "currNode", "contexts", "children", "nodeChildrenAsMap", "forEach", "futureChild", "childOutletName", "value", "outlet", "deactivateRoutes", "Object", "values", "v", "deactivateRouteAndItsChildren", "parentContext", "future", "curr", "component", "context", "getContext", "route", "shouldDetach", "snapshot", "detachAndStoreRouteSubtree", "deactivateRouteAndOutlet", "treeNode", "componentRef", "detach", "onOutletDeactivated", "store", "deactivate", "attachRef", "c", "ActivationEnd", "length", "ChildActivationEnd", "getOrCreateContext", "shouldAttach", "stored", "retrieve", "onOutletReAttached", "attach", "activateWith", "injector", "CanActivate", "path", "CanDeactivate", "getAllRouteGuards", "getChildRouteGuards", "getCanActivateChild", "p", "canActivateChild", "routeConfig", "node", "guards", "getTokenOrFunctionIdentity", "tokenOrFunction", "NOT_FOUND", "Symbol", "result", "get", "_isInjectable", "futurePath", "checks", "canDeactivateChecks", "canActivateChecks", "prevChildren", "getRouteGuards", "concat", "entries", "k", "shouldRun", "shouldRunGuardsAndResolvers", "runGuardsAndResolvers", "push", "data", "_resolvedData", "isActivated", "mode", "equalPath", "url", "shallowEqual", "queryParams", "equalParamsAndUrlSegments", "r", "childName", "isFunction", "isBoolean", "isCanLoad", "guard", "canLoad", "isCanActivate", "canActivate", "isCanActivateChild", "isCanDeactivate", "canDeactivate", "isCanMatch", "canMatch", "isEmptyError", "e", "EmptyError", "name", "INITIAL_VALUE", "prioritizedGuardValue", "switchMap", "obs", "combineLatest", "o", "pipe", "take", "startWith", "results", "isRedirect", "filter", "item", "val", "isUrlTree", "RedirectCommand", "checkGuards", "mergeMap", "targetSnapshot", "currentSnapshot", "of", "__spreadProps", "__spreadValues", "guardsResult", "runCanDeactivateChecks", "runCanActivateChecks", "futureRSS", "currRSS", "from", "check", "runCanDeactivate", "first", "futureSnapshot", "concatMap", "fireChildActivationStart", "parent", "fireActivationStart", "runCanActivateChild", "runCanActivate", "ActivationStart", "ChildActivationStart", "futureARS", "canActivateObservables", "defer", "closestInjector", "getClosestRouteInjector", "guardVal", "runInInjectionContext", "wrapIntoObservable", "canActivateChildGuardsMapped", "slice", "reverse", "_", "d", "guardsMapped", "currARS", "canDeactivateObservables", "runCanLoadGuards", "segments", "urlSerializer", "undefined", "canLoadObservables", "injectionToken", "redirectIfUrlTree", "tap", "redirectingNavigationError", "runCanMatchGuards", "canMatchObservables", "NoMatch", "segmentGroup", "AbsoluteRedirect", "Error", "urlTree", "noMatch$1", "throwError", "namedOutletsRedirect", "redirectTo", "_RuntimeError", "ngDevMode", "canLoadFails", "navigationCancelingError", "NavigationCancellationCode", "GuardRejected", "ApplyRedirects", "lineralizeSegments", "res", "numberOfChildren", "PRIMARY_OUTLET", "applyRedirectCommands", "posParams", "redirectToFn", "fragment", "params", "title", "newRedirect", "UrlTree", "newTree", "applyRedirectCreateUrlTree", "parse", "newRoot", "createSegmentGroup", "createQueryParams", "redirectToParams", "actualParams", "sourceName", "substring", "group", "updatedSegments", "createSegments", "child", "UrlSegmentGroup", "redirectToSegments", "actualSegments", "s", "findPosParam", "findOrReturn", "redirectToUrlSegment", "pos", "idx", "splice", "noMatch", "matched", "consumedSegments", "remainingSegments", "parameters", "positionalParamSegments", "matchWithChecks", "match", "getOrCreateRouteInjectorIfNeeded", "createWildcardMatchResult", "pathMatch", "hasChildren", "matcher", "defaultUrlMatcher", "consumed", "last", "split", "slicedSegments", "config", "containsEmptyPathMatchesWithNamedOutlets", "createChildrenForEmptyPaths", "containsEmptyPathMatches", "addEmptyPathsToChildrenIfNeeded", "routes", "emptyPathMatch", "getOutlet", "primarySegment", "some", "noLeftoversInUrl", "NoLeftoversInUrl", "recognize$1", "configLoader", "rootComponentType", "paramsInheritanceStrategy", "Recognizer", "recognize", "MAX_ALLOWED_REDIRECTS", "applyRedirects", "absoluteRedirectCount", "allowRedirects", "noMatchError", "rootSegmentGroup", "rootSnapshot", "rootNode", "TreeNode", "routeState", "RouterStateSnapshot", "tree", "createUrlTreeFromSnapshot", "serialize", "state", "ActivatedRouteSnapshot", "freeze", "processSegmentGroup", "catchError", "parentRoute", "processChildren", "processSegment", "childOutlets", "keys", "unshift", "childOutlet", "sortedConfig", "sortByMatchingOutlets", "scan", "outletChildren", "defaultIfEmpty", "last$1", "mergedChildren", "mergeEmptyPathMatches", "sortActivatedRouteSnapshots", "processSegmentAgainstRoute", "_injector", "x", "rawSegment", "matchSegmentAgainstRoute", "expandSegmentAgainstRouteUsingRedirect", "getData", "_loadedComponent", "getResolve", "inherited", "getInherited", "newSegments", "matchResult", "getChildConfig", "childConfig", "childInjector", "_loadedInjector", "matchedOnOutlet", "loadChildren", "_loadedRoutes", "shouldLoadResult", "cfg", "nodes", "sort", "a", "b", "localeCompare", "hasEmptyPathConfig", "mergedNodes", "Set", "duplicateEmptyPathNode", "find", "resultNode", "add", "mergedNode", "n", "has", "getData", "route", "data", "getResolve", "resolve", "recognize", "injector", "configLoader", "rootComponentType", "config", "serializer", "paramsInheritanceStrategy", "mergeMap", "t", "recognize$1", "extractedUrl", "pipe", "map", "state", "targetSnapshot", "tree", "urlAfterRedirects", "__spreadProps", "__spreadValues", "resolveData", "guards", "canActivateChecks", "length", "of", "routesWithResolversToRun", "Set", "check", "routesNeedingDataUpdates", "has", "newRoute", "flattenRouteTree", "add", "routesProcessed", "from", "concatMap", "runResolve", "getInherited", "parent", "tap", "takeLast", "_", "size", "EMPTY", "descendants", "children", "child", "flat", "futureARS", "futureRSS", "routeConfig", "_resolve", "title", "undefined", "hasStaticTitle", "RouteTitleKey", "resolveNode", "resolvedData", "_resolvedData", "keys", "getDataKeys", "key", "getResolver", "first", "value", "RedirectCommand", "redirectingNavigationError", "DefaultUrlSerializer", "catchError", "e", "isEmptyError", "throwError", "injectionToken", "closestInjector", "getClosestRouteInjector", "resolver", "getTokenOrFunctionIdentity", "resolverValue", "runInInjectionContext", "wrapIntoObservable", "switchTap", "next", "switchMap", "v", "nextResult", "TitleStrategy", "buildTitle", "snapshot", "pageTitle", "root", "getResolvedTitleForRoute", "find", "outlet", "PRIMARY_OUTLET", "factory", "inject", "DefaultTitleStrategy", "providedIn", "constructor", "updateTitle", "setTitle", "\u0275\u0275inject", "Title", "\u0275prov", "\u0275\u0275defineInjectable", "\u0275fac", "ROUTER_CONFIGURATION", "InjectionToken", "\u0275EmptyOutletComponent", "selectors", "exportAs", "decls", "vars", "template", "rf", "ctx", "dependencies", "RouterOutlet", "encapsulation", "standardizeConfig", "r", "c", "component", "loadComponent", "loadChildren", "ROUTES", "RouterConfigLoader", "componentLoaders", "WeakMap", "childrenLoaders", "onLoadStartListener", "onLoadEndListener", "compiler", "Compiler", "get", "_loadedComponent", "loadRunner", "maybeUnwrapDefaultExport", "finalize", "delete", "loader", "ConnectableObservable", "Subject", "refCount", "set", "parentInjector", "_loadedRoutes", "routes", "_loadedInjector", "NgModuleFactory", "Array", "isArray", "compileModuleAsync", "factoryOrRoutes", "rawRoutes", "requireStandaloneComponents", "create", "optional", "self", "isWrappedDefaultExport", "input", "UrlHandlingStrategy", "DefaultUrlHandlingStrategy", "shouldProcessUrl", "url", "extract", "merge", "newUrlPart", "wholeUrl", "CREATE_VIEW_TRANSITION", "VIEW_TRANSITION_OPTIONS", "createViewTransition", "to", "transitionOptions", "document", "DOCUMENT", "NgZone", "runOutsideAngular", "startViewTransition", "skipNextTransition", "Promise", "setTimeout", "resolveViewTransitionStarted", "viewTransitionStarted", "transition", "createRenderPromise", "onViewTransitionCreated", "afterNextRender", "read", "NAVIGATION_ERROR_HANDLER", "NavigationTransitions", "currentNavigation", "currentTransition", "lastSuccessfulNavigation", "events", "transitionAbortSubject", "environmentInjector", "EnvironmentInjector", "destroyRef", "DestroyRef", "urlSerializer", "UrlSerializer", "rootContexts", "ChildrenOutletContexts", "location", "Location", "inputBindingEnabled", "INPUT_BINDER", "titleStrategy", "options", "urlHandlingStrategy", "navigationErrorHandler", "navigationId", "hasRequestedNavigation", "transitions", "afterPreactivation", "destroyed", "onLoadStart", "RouteConfigLoadStart", "onLoadEnd", "RouteConfigLoadEnd", "onDestroy", "complete", "handleNavigationRequest", "request", "id", "rawUrl", "targetRouterState", "canDeactivateChecks", "guardsResult", "setupNavigations", "router", "BehaviorSubject", "filter", "overallTransitionState", "completed", "errored", "cancelNavigationTransition", "NavigationCancellationCode", "SupersededByNewNavigation", "initialUrl", "targetBrowserUrl", "extras", "browserUrl", "parse", "trigger", "source", "previousNavigation", "urlTransition", "navigated", "isUpdatingInternalState", "isUpdatedBrowserUrl", "onSameUrlNavigation", "reason", "NavigationSkipped", "serialize", "NavigationSkippedCode", "IgnoredSameUrlNavigation", "NavigationStart", "restoredState", "finalUrl", "routesRecognized", "RoutesRecognized", "currentRawUrl", "navStart", "createEmptyState", "skipLocationChange", "replaceUrl", "IgnoredByUrlHandlingStrategy", "guardsStart", "GuardsCheckStart", "getAllRouteGuards", "currentSnapshot", "checkGuards", "evt", "guardsEnd", "GuardsCheckEnd", "GuardRejected", "resolveStart", "ResolveStart", "dataResolved", "NoDataFromResolver", "resolveEnd", "ResolveEnd", "loadComponents", "loaders", "push", "loadedComponent", "combineLatest", "defaultIfEmpty", "take", "createRouterState", "routeReuseStrategy", "currentRouterState", "BeforeActivateRoutes", "activateRoutes", "NavigationEnd", "takeUntil", "err", "isNavigationCancelingError", "NavigationCancel", "message", "cancellationCode", "isRedirectingNavigationCancelingError", "RedirectRequest", "navigationBehaviorOptions", "navigationError", "NavigationError", "navigationErrorHandlerResult", "redirectTo", "ee", "resolveNavigationPromiseOnError", "reject", "code", "navCancel", "toString", "currentUrlTree", "currentBrowserUrl", "path", "isBrowserTriggeredNavigation", "IMPERATIVE_NAVIGATION", "RouteReuseStrategy", "DefaultRouteReuseStrategy", "BaseRouteReuseStrategy", "shouldDetach", "store", "detachedTree", "shouldAttach", "retrieve", "shouldReuseRoute", "future", "curr", "__ngFactoryType__", "StateManager", "canceledNavigationResolution", "urlUpdateStrategy", "UrlTree", "getCurrentUrlTree", "rawUrlTree", "getRawUrlTree", "createBrowserPath", "commitTransition", "routerState", "getRouterState", "stateMemento", "createStateMemento", "updateStateMemento", "resetInternalState", "HistoryStateManager", "currentPageId", "lastSuccessfulId", "getState", "browserPageId", "\u0275routerPageId", "registerNonRouterCurrentEntryChangeListener", "listener", "subscribe", "event", "handleRouterEvent", "setBrowserUrl", "restoreHistory", "isCurrentPathEqualTo", "currentBrowserPageId", "newState", "generateNgRouterState", "replaceState", "go", "navigation", "restoringFromCaughtError", "targetPagePosition", "historyGo", "resetUrlToCurrentUrlTree", "routerPageId", "afterNextNavigation", "action", "Redirect", "result", "exactMatchOptions", "paths", "fragment", "matrixParams", "queryParams", "subsetMatchOptions", "Router", "stateManager", "disposed", "nonRouterCurrentEntryChangeSubscription", "console", "_Console", "pendingTasks", "_PendingTasksInternal", "navigationTransitions", "_events", "componentInputBindingEnabled", "resetConfig", "error", "warn", "subscribeToNavigationEvents", "eventsSubscription", "Subscription", "subscription", "opts", "mergedTree", "info", "scheduleNavigation", "promise", "isPublicRouterEvent", "resetRootComponentType", "initialNavigation", "setUpLocationChangeListener", "navigateToSyncWithBrowser", "stateCopy", "Object", "urlTree", "parseUrl", "serializeUrl", "getCurrentNavigation", "ngOnDestroy", "dispose", "unsubscribe", "createUrlTree", "commands", "navigationExtras", "relativeTo", "queryParamsHandling", "preserveFragment", "f", "q", "defaultQueryParamsHandling", "removeEmptyProps", "relativeToUrlSegmentGroup", "relativeToSnapshot", "createSegmentGroupFromRoute", "createUrlTreeFromSegmentGroup", "navigateByUrl", "isUrlTree", "navigate", "validateCommands", "isActive", "matchOptions", "containsTree", "params", "entries", "reduce", "priorPromise", "res", "rej", "taskId", "queueMicrotask", "remove", "catch", "i", "_RuntimeError", "ngDevMode", "RouterLink", "router", "route", "tabIndexAttribute", "renderer", "el", "locationStrategy", "href", "target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "isAnchorElement", "subscription", "onChanges", "Subject", "constructor", "tagName", "nativeElement", "toLowerCase", "events", "subscribe", "s", "NavigationEnd", "updateHref", "setTabIndexIfNotOnNativeEl", "preserveFragment", "skipLocationChange", "replaceUrl", "newTabIndex", "applyAttributeValue", "ngOnChanges", "changes", "next", "routerLinkInput", "routerLink", "commandsOrUrlTree", "isUrlTree", "Array", "isArray", "onClick", "button", "ctrlKey", "shiftKey", "altKey", "metaKey", "urlTree", "extras", "navigateByUrl", "ngOnDestroy", "unsubscribe", "prepareExternalUrl", "serializeUrl", "sanitizedValue", "__sanitizeUrlOrResourceUrl", "attrName", "attrValue", "setAttribute", "removeAttribute", "createUrlTree", "undefined", "\u0275fac", "__ngFactoryType__", "\u0275\u0275directiveInject", "Router", "ActivatedRoute", "\u0275\u0275injectAttribute", "Renderer2", "ElementRef", "LocationStrategy", "\u0275dir", "\u0275\u0275defineDirective", "type", "selectors", "hostVars", "hostBindings", "rf", "ctx", "\u0275\u0275listener", "$event", "\u0275\u0275attribute", "inputs", "booleanAttribute", "features", "\u0275\u0275NgOnChangesFeature", "RouterLinkActive", "element", "cdr", "link", "links", "classes", "routerEventsSubscription", "linkInputChangesSubscription", "_isActive", "isActive", "routerLinkActiveOptions", "exact", "ariaCurrentWhenActive", "isActiveChange", "EventEmitter", "update", "ngAfterContentInit", "of", "pipe", "mergeAll", "_", "subscribeToEachLinkOnChanges", "allLinkChanges", "toArray", "filter", "map", "from", "isLinkActive", "routerLinkActive", "data", "split", "c", "navigated", "queueMicrotask", "hasActiveLinks", "forEach", "addClass", "removeClass", "toString", "markForCheck", "emit", "options", "isActiveMatchOptions", "isActiveCheckFn", "some", "ChangeDetectorRef", "contentQueries", "dirIndex", "\u0275\u0275contentQuery", "_t", "\u0275\u0275queryRefresh", "\u0275\u0275loadQuery", "outputs", "exportAs", "paths", "PreloadingStrategy", "RouterPreloader", "router", "injector", "preloadingStrategy", "loader", "subscription", "constructor", "setUpPreloading", "events", "pipe", "filter", "e", "NavigationEnd", "concatMap", "preload", "subscribe", "processRoutes", "config", "ngOnDestroy", "unsubscribe", "routes", "res", "route", "providers", "_injector", "createEnvironmentInjector", "path", "injectorForCurrentRoute", "injectorForChildren", "_loadedInjector", "loadChildren", "_loadedRoutes", "canLoad", "undefined", "loadComponent", "_loadedComponent", "push", "preloadConfig", "children", "from", "mergeAll", "loadedChildren$", "of", "recursiveLoadChildren$", "mergeMap", "loadComponent$", "\u0275\u0275inject", "Router", "EnvironmentInjector", "PreloadingStrategy", "RouterConfigLoader", "\u0275prov", "\u0275\u0275defineInjectable", "token", "factory", "\u0275fac", "providedIn", "ROUTER_SCROLLER", "InjectionToken", "RouterScroller", "urlSerializer", "transitions", "viewportScroller", "zone", "options", "routerEventsSubscription", "scrollEventsSubscription", "lastId", "lastSource", "restoredId", "store", "scrollPositionRestoration", "anchorScrolling", "init", "setHistoryScrollRestoration", "createScrollEvents", "consumeScrollEvents", "NavigationStart", "getScrollPosition", "navigationTrigger", "restoredState", "navigationId", "id", "scheduleScrollEvent", "parse", "urlAfterRedirects", "fragment", "NavigationSkipped", "code", "NavigationSkippedCode", "IgnoredSameUrlNavigation", "url", "Scroll", "position", "scrollToPosition", "anchor", "scrollToAnchor", "routerEvent", "runOutsideAngular", "setTimeout", "run", "next", "\u0275\u0275invalidFactory", "provideRouter", "features", "makeEnvironmentProviders", "provide", "ROUTES", "multi", "useValue", "ActivatedRoute", "useFactory", "rootRoute", "deps", "APP_BOOTSTRAP_LISTENER", "getBootstrapListener", "map", "feature", "\u0275providers", "routerState", "root", "routerFeature", "kind", "\u0275kind", "getBootstrapListener", "injector", "inject", "Injector", "bootstrappedComponentRef", "ref", "get", "ApplicationRef", "components", "router", "Router", "bootstrapDone", "BOOTSTRAP_DONE", "INITIAL_NAVIGATION", "initialNavigation", "ROUTER_PRELOADER", "InjectFlags", "Optional", "setUpPreloading", "ROUTER_SCROLLER", "init", "resetRootComponentType", "componentTypes", "closed", "next", "complete", "unsubscribe", "InjectionToken", "factory", "Subject", "providedIn", "withEnabledBlockingInitialNavigation", "providers", "provide", "useValue", "provideAppInitializer", "LOCATION_INITIALIZED", "Promise", "resolve", "then", "afterNextNavigation", "NavigationTransitions", "afterPreactivation", "of", "routerFeature", "withDisabledInitialNavigation", "setUpLocationChangeListener", "ROUTER_PRELOADER", "InjectionToken", "withPreloading", "preloadingStrategy", "routerFeature", "provide", "useExisting", "RouterPreloader", "PreloadingStrategy", "withComponentInputBinding", "routerFeature", "RoutedComponentInputBinder", "provide", "INPUT_BINDER", "useExisting", "withViewTransitions", "options", "_performanceMarkFeature", "providers", "CREATE_VIEW_TRANSITION", "useValue", "createViewTransition", "VIEW_TRANSITION_OPTIONS", "__spreadValues", "skipNextTransition", "skipInitialTransition", "ROUTER_PROVIDERS", "Location", "provide", "UrlSerializer", "useClass", "DefaultUrlSerializer", "Router", "ChildrenOutletContexts", "ActivatedRoute", "useFactory", "rootRoute", "deps", "RouterConfigLoader", "RouterModule", "constructor", "forRoot", "routes", "config", "ngModule", "providers", "ROUTES", "multi", "useValue", "errorHandler", "NAVIGATION_ERROR_HANDLER", "ROUTER_CONFIGURATION", "useHash", "provideHashLocationStrategy", "providePathLocationStrategy", "provideRouterScroller", "preloadingStrategy", "withPreloading", "\u0275providers", "initialNavigation", "provideInitialNavigation", "bindToComponentInputs", "withComponentInputBinding", "enableViewTransitions", "withViewTransitions", "provideRouterInitializer", "forChild", "\u0275mod", "\u0275\u0275defineNgModule", "type", "\u0275\u0275defineInjector", "ROUTER_SCROLLER", "viewportScroller", "inject", "ViewportScroller", "zone", "NgZone", "transitions", "NavigationTransitions", "urlSerializer", "scrollOffset", "setOffset", "RouterScroller", "LocationStrategy", "HashLocationStrategy", "PathLocationStrategy", "provideInitialNavigation", "config", "initialNavigation", "withDisabledInitialNavigation", "\u0275providers", "withEnabledBlockingInitialNavigation", "ROUTER_INITIALIZER", "InjectionToken", "provideRouterInitializer", "provide", "useFactory", "getBootstrapListener", "APP_BOOTSTRAP_LISTENER", "multi", "useExisting", "ApiService", "http", "baseUrl", "apiKey", "httpOptions", "headers", "constructor", "transformCandidate", "backendCandidate", "id", "name", "role", "appliedRole", "department", "employmentType", "workType", "appliedDate", "appliedDateStr", "attachments", "resumeUrl", "attachment", "fileName", "status", "score", "email", "phone", "position", "experience", "jobId", "transformCandidateForAPI", "candidate", "undefined", "Number", "getAssessmentTemplates", "getAuthHeaders", "get", "pipe", "catchError", "handleError", "getAssessmentTemplatesByRole", "login", "credentials", "post", "register", "userData", "createJob", "jobData", "getJobs", "updateJob", "put", "deleteJob", "delete", "getJobById", "createCandidate", "candidateData", "FormData", "HttpHeaders", "map", "requestData", "getCandidates", "candidates", "getCandidateById", "updateCandidate", "deleteCandidate", "getCandidateSteps", "candidateId", "res", "steps", "getCandidateAssessment", "createAssessment", "getAssessments", "createReview", "stepId", "reviewData", "getStepStatusSummary", "completedSteps", "filter", "step", "completed", "length", "totalSteps", "currentStep", "find", "stepName", "total", "token", "localStorage", "getItem", "set", "error", "errorMessage", "ErrorEvent", "message", "throwError", "getFallbackJobs", "title", "location", "description", "isActive", "salaryMin", "salaryMax", "type", "level", "getFallbackCandidates", "getFallbackCandidateSteps", "template", "index", "assessmentId", "stepOrder", "getFallbackAssessments", "mode", "passingCriteria", "\u0275\u0275inject", "HttpClient", "factory", "\u0275fac", "providedIn"]
}
